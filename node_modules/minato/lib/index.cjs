"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  $: () => Eval3,
  Database: () => Database,
  Driver: () => Driver,
  Eval: () => Eval3,
  Field: () => Field,
  Logger: () => import_cordis3.Logger,
  Model: () => Model,
  Primary: () => Primary,
  RuntimeError: () => RuntimeError,
  Schema: () => import_cordis3.Schema,
  Selection: () => Selection,
  Tables: () => Tables,
  Type: () => Type,
  Types: () => Types,
  default: () => src_default,
  executeEval: () => executeEval,
  executeQuery: () => executeQuery,
  executeSort: () => executeSort,
  executeUpdate: () => executeUpdate,
  hasSubquery: () => hasSubquery,
  isComparable: () => isComparable,
  isEvalExpr: () => isEvalExpr,
  makeRegExp: () => makeRegExp,
  randomId: () => randomId,
  unravel: () => unravel,
  z: () => import_cordis3.Schema
});
module.exports = __toCommonJS(src_exports);

// src/database.ts
var import_cosmokit5 = require("cosmokit");
var import_cordis = require("cordis");

// src/utils.ts
function isComparable(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value instanceof Date;
}
__name(isComparable, "isComparable");
var letters = "abcdefghijklmnopqrstuvwxyz";
function randomId() {
  return Array(8).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join("");
}
__name(randomId, "randomId");
function makeRegExp(source) {
  return source instanceof RegExp ? source : new RegExp(source);
}
__name(makeRegExp, "makeRegExp");
function unravel(source, init) {
  const result = {};
  for (const key in source) {
    let node = result;
    const segments = key.split(".").reverse();
    for (let index = segments.length - 1; index > 0; index--) {
      const segment = segments[index];
      node = node[segment] ??= {};
      if (init)
        node = init(node);
    }
    node[segments[0]] = source[key];
  }
  return result;
}
__name(unravel, "unravel");

// src/selection.ts
var import_cosmokit4 = require("cosmokit");

// src/eval.ts
var import_cosmokit3 = require("cosmokit");

// src/type.ts
var import_cosmokit = require("cosmokit");
var Type;
((Type2) => {
  Type2.kType = Symbol.for("minato.type");
  Type2.Boolean = (0, import_cosmokit.defineProperty)({ type: "boolean" }, Type2.kType, true);
  Type2.Number = (0, import_cosmokit.defineProperty)({ type: "double" }, Type2.kType, true);
  Type2.String = (0, import_cosmokit.defineProperty)({ type: "string" }, Type2.kType, true);
  Type2.Object = /* @__PURE__ */ __name((obj) => (0, import_cosmokit.defineProperty)({
    type: "json",
    inner: globalThis.Object.keys(obj ?? {}).length ? (0, import_cosmokit.mapValues)(obj, (value) => isType(value) ? value : fromField(value)) : void 0
  }, Type2.kType, true), "Object");
  Type2.Array = /* @__PURE__ */ __name((type) => (0, import_cosmokit.defineProperty)({
    type: "json",
    inner: type,
    array: true
  }, Type2.kType, true), "Array");
  function fromPrimitive(value) {
    if ((0, import_cosmokit.isNullable)(value))
      return fromField("expr");
    else if (typeof value === "number")
      return Type2.Number;
    else if (typeof value === "string")
      return Type2.String;
    else if (typeof value === "boolean")
      return Type2.Boolean;
    else if (typeof value === "bigint")
      return fromField("bigint");
    else if (value instanceof Date)
      return fromField("timestamp");
    else if (import_cosmokit.Binary.is(value))
      return fromField("binary");
    else if (globalThis.Array.isArray(value))
      return (0, Type2.Array)(value.length ? fromPrimitive(value[0]) : void 0);
    else if (typeof value === "object")
      return fromField("json");
    throw new TypeError(`invalid primitive: ${value}`);
  }
  Type2.fromPrimitive = fromPrimitive;
  __name(fromPrimitive, "fromPrimitive");
  function fromField(field) {
    if (isType(field))
      return field;
    if (typeof field === "string")
      return (0, import_cosmokit.defineProperty)({ type: field }, Type2.kType, true);
    else if (field.type)
      return field.type;
    else if (field.expr?.[Type2.kType])
      return field.expr[Type2.kType];
    throw new TypeError(`invalid field: ${field}`);
  }
  Type2.fromField = fromField;
  __name(fromField, "fromField");
  function fromTerm(value) {
    if (isEvalExpr(value))
      return value[Type2.kType] ?? fromField("expr");
    else
      return fromPrimitive(value);
  }
  Type2.fromTerm = fromTerm;
  __name(fromTerm, "fromTerm");
  function fromTerms(values, initial) {
    return values.map(fromTerm).find((type) => type.type !== "expr") ?? initial ?? fromField("expr");
  }
  Type2.fromTerms = fromTerms;
  __name(fromTerms, "fromTerms");
  function isType(value) {
    return value?.[Type2.kType] === true;
  }
  Type2.isType = isType;
  __name(isType, "isType");
  function isArray(type) {
    return type.type === "json" && type.array;
  }
  Type2.isArray = isArray;
  __name(isArray, "isArray");
  function getInner(type, key) {
    if (!type?.inner)
      return;
    if (isArray(type) && (0, import_cosmokit.isNullable)(key))
      return type.inner;
    if ((0, import_cosmokit.isNullable)(key))
      return;
    if (type.inner[key])
      return type.inner[key];
    if (key.includes("."))
      return key.split(".").reduce((t, k) => getInner(t, k), type);
    return (0, Type2.Object)(globalThis.Object.fromEntries(
      globalThis.Object.entries(type.inner).filter(([k]) => k.startsWith(`${key}.`)).map(([k, v]) => [k.slice(key.length + 1), v])
    ));
  }
  Type2.getInner = getInner;
  __name(getInner, "getInner");
})(Type || (Type = {}));

// src/model.ts
var import_cosmokit2 = require("cosmokit");
var Primary = Symbol("Primary");
var Field;
((Field3) => {
  Field3.number = ["integer", "unsigned", "float", "double", "decimal"];
  Field3.string = ["char", "string", "text"];
  Field3.boolean = ["boolean"];
  Field3.date = ["timestamp", "date", "time"];
  Field3.object = ["list", "json"];
  const NewType = Symbol("newtype");
  const regexp = /^(\w+)(?:\((.+)\))?$/;
  function parse(source) {
    if (typeof source === "function")
      throw new TypeError("view field is not supported");
    if (typeof source !== "string") {
      return {
        initial: null,
        deftype: source.type,
        ...source,
        type: Type.fromField(source.type)
      };
    }
    const capture = regexp.exec(source);
    if (!capture)
      throw new TypeError("invalid field definition");
    const type = capture[1];
    const args = (capture[2] || "").split(",");
    const field = { deftype: type, type: Type.fromField(type) };
    if (field.initial === void 0)
      field.initial = getInitial(type);
    if (type === "decimal") {
      field.precision = +args[0];
      field.scale = +args[1];
    } else if (args[0]) {
      field.length = +args[0];
    }
    return field;
  }
  Field3.parse = parse;
  __name(parse, "parse");
  function getInitial(type, initial) {
    if (initial === void 0) {
      if (Field3.number.includes(type))
        return 0;
      if (Field3.string.includes(type))
        return "";
      if (type === "list")
        return [];
      if (type === "json")
        return {};
    }
    return initial;
  }
  Field3.getInitial = getInitial;
  __name(getInitial, "getInitial");
})(Field || (Field = {}));
var Model = class {
  constructor(name) {
    this.name = name;
    this.autoInc = false;
    this.primary = "id";
    this.unique = [];
    this.foreign = {};
  }
  static {
    __name(this, "Model");
  }
  ctx;
  fields = {};
  migrations = /* @__PURE__ */ new Map();
  type;
  extend(fields = {}, config = {}) {
    const { primary, autoInc, unique = [], foreign, callback } = config;
    this.primary = primary || this.primary;
    this.autoInc = autoInc || this.autoInc;
    unique.forEach((key) => this.unique.includes(key) || this.unique.push(key));
    Object.assign(this.foreign, foreign);
    if (callback)
      this.migrations.set(callback, Object.keys(fields));
    for (const key in fields) {
      this.fields[key] = Field.parse(fields[key]);
      this.fields[key].deprecated = !!callback;
    }
    if (typeof this.primary === "string" && this.fields[this.primary]?.deftype === "primary") {
      this.autoInc = true;
    }
    this.checkIndex(this.primary);
    this.unique.forEach((index) => this.checkIndex(index));
  }
  checkIndex(index) {
    for (const key of (0, import_cosmokit2.makeArray)(index)) {
      if (!this.fields[key]) {
        throw new TypeError(`missing field definition for index key "${key}"`);
      }
    }
  }
  resolveValue(field, value) {
    if ((0, import_cosmokit2.isNullable)(value))
      return value;
    if (typeof field === "string")
      field = this.fields[field];
    if (field)
      field = Type.fromField(field);
    if (field?.type === "time") {
      const date = /* @__PURE__ */ new Date(0);
      date.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
      return date;
    } else if (field?.type === "date") {
      const date = new Date(value);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    return value;
  }
  resolveModel(obj, model) {
    if (!model)
      model = this.getType();
    if ((0, import_cosmokit2.isNullable)(obj) || !model.inner)
      return obj;
    if (Type.isArray(model) && Array.isArray(obj)) {
      return obj.map((x) => this.resolveModel(x, Type.getInner(model)));
    }
    const result = {};
    for (const key in obj) {
      const type = Type.getInner(model, key);
      if (!type || (0, import_cosmokit2.isNullable)(obj[key])) {
        result[key] = obj[key];
      } else if (type.type !== "json") {
        result[key] = this.resolveValue(type, obj[key]);
      } else if (type.inner && Type.isArray(type) && Array.isArray(obj[key])) {
        result[key] = obj[key].map((x) => this.resolveModel(x, Type.getInner(type)));
      } else if (type.inner) {
        result[key] = this.resolveModel(obj[key], type);
      } else {
        result[key] = obj[key];
      }
    }
    return result;
  }
  format(source, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields);
    Object.entries(source).map(([key, value]) => {
      key = prefix + key;
      if (value === void 0)
        return;
      if (fields.includes(key)) {
        result[key] = value;
        return;
      }
      const field = fields.find((field2) => key.startsWith(field2 + "."));
      if (field) {
        result[key] = value;
      } else if (!value || typeof value !== "object" || isEvalExpr(value) || Object.keys(value).length === 0) {
        if (strict) {
          throw new TypeError(`unknown field "${key}" in model ${this.name}`);
        }
      } else {
        this.format(value, strict, key + ".", result);
      }
    });
    return prefix === "" ? this.resolveModel(result) : result;
  }
  parse(source, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields);
    if (strict && prefix === "") {
      Object.assign(result, unravel(
        Object.fromEntries(fields.filter((key) => key.includes(".")).map((key) => [key.slice(0, key.lastIndexOf(".")), {}]))
      ));
    }
    for (const key in source) {
      let node = result;
      const segments = key.split(".").reverse();
      for (let index = segments.length - 1; index > 0; index--) {
        const segment = segments[index];
        node = node[segment] ??= {};
      }
      if (key in source) {
        const fullKey = prefix + key, value = source[key];
        const field = fields.find((field2) => fullKey === field2 || fullKey.startsWith(field2 + "."));
        if (field) {
          node[segments[0]] = value;
        } else if (!value || typeof value !== "object" || isEvalExpr(value) || Array.isArray(value) || import_cosmokit2.Binary.is(value) || Object.keys(value).length === 0) {
          if (strict) {
            throw new TypeError(`unknown field "${fullKey}" in model ${this.name}`);
          } else {
            node[segments[0]] = value;
          }
        } else {
          this.parse(value, strict, fullKey + ".", node[segments[0]] ??= {});
        }
      }
    }
    return prefix === "" ? this.resolveModel(result) : result;
  }
  create(data) {
    const result = {};
    const keys = (0, import_cosmokit2.makeArray)(this.primary);
    for (const key in this.fields) {
      const { initial, deprecated } = this.fields[key];
      if (deprecated)
        continue;
      if (!keys.includes(key) && !(0, import_cosmokit2.isNullable)(initial)) {
        result[key] = (0, import_cosmokit2.clone)(initial);
      }
    }
    return this.parse({ ...result, ...data });
  }
  getType(key) {
    this.type ??= Type.Object((0, import_cosmokit2.mapValues)(this.fields, (field) => Type.fromField(field)));
    return key ? Type.getInner(this.type, key) : this.type;
  }
};

// src/eval.ts
function isEvalExpr(value) {
  return value && Object.keys(value).some((key) => key.startsWith("$"));
}
__name(isEvalExpr, "isEvalExpr");
function hasSubquery(value) {
  if (!isEvalExpr(value))
    return false;
  return Object.entries(value).filter(([k]) => k.startsWith("$")).some(([k, v]) => {
    if ((0, import_cosmokit3.isNullable)(v) || isComparable(v))
      return false;
    if (k === "$exec")
      return true;
    if (isEvalExpr(v))
      return hasSubquery(v);
    if (Array.isArray(v))
      return v.some((x) => hasSubquery(x));
    if (typeof v === "object")
      return Object.values(v).some((x) => hasSubquery(x));
    return false;
  });
}
__name(hasSubquery, "hasSubquery");
var kExpr = Symbol("expr");
var kType = Symbol("type");
var kAggr = Symbol("aggr");
var Eval3 = /* @__PURE__ */ __name((key, value, type) => (0, import_cosmokit3.defineProperty)((0, import_cosmokit3.defineProperty)({ ["$" + key]: value }, kExpr, true), Type.kType, type), "Eval");
var operators = /* @__PURE__ */ Object.create(null);
operators["$"] = getRecursive;
function unary(key, callback, type) {
  operators[`$${key}`] = callback;
  return (value) => Eval3(key, value, typeof type === "function" ? type(value) : type);
}
__name(unary, "unary");
function multary(key, callback, type) {
  operators[`$${key}`] = callback;
  return (...args) => Eval3(key, args, typeof type === "function" ? type(...args) : type);
}
__name(multary, "multary");
function comparator(key, callback) {
  operators[`$${key}`] = (args, data) => {
    const left = executeEval(data, args[0]);
    const right = executeEval(data, args[1]);
    if ((0, import_cosmokit3.isNullable)(left) || (0, import_cosmokit3.isNullable)(right))
      return true;
    return callback(left.valueOf(), right.valueOf());
  };
  return (...args) => Eval3(key, args, Type.Boolean);
}
__name(comparator, "comparator");
Eval3.switch = (branches, vDefault) => Eval3("switch", { branches, default: vDefault }, Type.fromTerm(branches[0]));
operators.$switch = (args, data) => {
  for (const branch of args.branches) {
    if (executeEval(data, branch.case))
      return executeEval(data, branch.then);
  }
  return executeEval(data, args.default);
};
Eval3.if = multary("if", ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse), (cond, vThen, vElse) => Type.fromTerm(vThen));
Eval3.ifNull = multary("ifNull", ([value, fallback], data) => executeEval(data, value) ?? executeEval(data, fallback), (value) => Type.fromTerm(value));
Eval3.add = multary("add", (args, data) => args.reduce((prev, curr) => prev + executeEval(data, curr), 0), Type.Number);
Eval3.mul = Eval3.multiply = multary("multiply", (args, data) => args.reduce((prev, curr) => prev * executeEval(data, curr), 1), Type.Number);
Eval3.sub = Eval3.subtract = multary("subtract", ([left, right], data) => executeEval(data, left) - executeEval(data, right), Type.Number);
Eval3.div = Eval3.divide = multary("divide", ([left, right], data) => executeEval(data, left) / executeEval(data, right), Type.Number);
Eval3.mod = Eval3.modulo = multary("modulo", ([left, right], data) => executeEval(data, left) % executeEval(data, right), Type.Number);
Eval3.abs = unary("abs", (arg, data) => Math.abs(executeEval(data, arg)), Type.Number);
Eval3.floor = unary("floor", (arg, data) => Math.floor(executeEval(data, arg)), Type.Number);
Eval3.ceil = unary("ceil", (arg, data) => Math.ceil(executeEval(data, arg)), Type.Number);
Eval3.round = unary("round", (arg, data) => Math.round(executeEval(data, arg)), Type.Number);
Eval3.exp = unary("exp", (arg, data) => Math.exp(executeEval(data, arg)), Type.Number);
Eval3.log = multary("log", ([left, right], data) => Math.log(executeEval(data, left)) / Math.log(executeEval(data, right ?? Math.E)), Type.Number);
Eval3.pow = Eval3.power = multary("power", ([left, right], data) => Math.pow(executeEval(data, left), executeEval(data, right)), Type.Number);
Eval3.random = () => Eval3("random", {}, Type.Number);
operators.$random = () => Math.random();
Eval3.eq = comparator("eq", (left, right) => left === right);
Eval3.ne = comparator("ne", (left, right) => left !== right);
Eval3.gt = comparator("gt", (left, right) => left > right);
Eval3.ge = Eval3.gte = comparator("gte", (left, right) => left >= right);
Eval3.lt = comparator("lt", (left, right) => left < right);
Eval3.le = Eval3.lte = comparator("lte", (left, right) => left <= right);
Eval3.in = multary("in", ([value, array], data) => executeEval(data, array).includes(executeEval(data, value)), Type.Boolean);
Eval3.nin = multary("nin", ([value, array], data) => !executeEval(data, array).includes(executeEval(data, value)), Type.Boolean);
Eval3.concat = multary("concat", (args, data) => args.map((arg) => executeEval(data, arg)).join(""), Type.String);
Eval3.regex = multary("regex", ([value, regex], data) => makeRegExp(executeEval(data, regex)).test(executeEval(data, value)), Type.Boolean);
Eval3.and = multary("and", (args, data) => {
  const type = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type.type))
    return args.every((arg) => executeEval(data, arg));
  else if (Field.number.includes(type.type))
    return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev & curr);
  else if (type.type === "bigint")
    return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev & curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.or = multary("or", (args, data) => {
  const type = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type.type))
    return args.some((arg) => executeEval(data, arg));
  else if (Field.number.includes(type.type))
    return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev | curr);
  else if (type.type === "bigint")
    return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev | curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.not = unary("not", (value, data) => {
  const type = Type.fromTerms([value], Type.Boolean);
  if (Field.boolean.includes(type.type))
    return !executeEval(data, value);
  else if (Field.number.includes(type.type))
    return ~executeEval(data, value);
  else if (type.type === "bigint")
    return ~BigInt(executeEval(data, value) ?? 0);
}, (value) => Type.fromTerms([value], Type.Boolean));
Eval3.xor = multary("xor", (args, data) => {
  const type = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type.type))
    return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev !== curr);
  else if (Field.number.includes(type.type))
    return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev ^ curr);
  else if (type.type === "bigint")
    return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev ^ curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.literal = multary("literal", ([value, type]) => {
  if (type)
    throw new TypeError("literal cast is not supported");
  else
    return value;
}, (value, type) => type ? Type.fromField(type) : Type.fromTerm(value));
Eval3.number = unary("number", (arg, data) => {
  const value = executeEval(data, arg);
  return value instanceof Date ? Math.floor(value.valueOf() / 1e3) : Number(value);
}, Type.Number);
var unwrapAggr = /* @__PURE__ */ __name((expr, def) => {
  let type = Type.fromTerm(expr);
  type = Type.getInner(type) ?? type;
  return def && type.type === "expr" ? def : type;
}, "unwrapAggr");
Eval3.sum = unary("sum", (expr, table) => Array.isArray(table) ? table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) : Array.from(executeEval(table, expr)).reduce((prev, curr) => prev + curr, 0), Type.Number);
Eval3.avg = unary("avg", (expr, table) => {
  if (Array.isArray(table))
    return table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length;
  else {
    const array = Array.from(executeEval(table, expr));
    return array.reduce((prev, curr) => prev + curr, 0) / array.length;
  }
}, Type.Number);
Eval3.max = unary("max", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x > y ? x : y, -Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x > y ? x : y, -Infinity), (expr) => unwrapAggr(expr, Type.Number));
Eval3.min = unary("min", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x < y ? x : y, Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x < y ? x : y, Infinity), (expr) => unwrapAggr(expr, Type.Number));
Eval3.count = unary("count", (expr, table) => new Set(table.map((data) => executeAggr(expr, data))).size, Type.Number);
(0, import_cosmokit3.defineProperty)(Eval3, "length", unary("length", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).length : Array.from(executeEval(table, expr)).length, Type.Number));
operators.$object = (field, table) => (0, import_cosmokit3.mapValues)(field, (value) => executeAggr(value, table));
Eval3.object = (fields) => {
  if (fields.$model) {
    const modelFields = Object.entries(fields.$model.fields);
    const prefix = fields.$prefix;
    fields = Object.fromEntries(modelFields.filter(([, field]) => !field.deprecated).filter(([path]) => path.startsWith(prefix)).map(([k]) => [k.slice(prefix.length), fields[k.slice(prefix.length)]]));
    return Eval3("object", fields, Type.Object((0, import_cosmokit3.mapValues)(fields, (value) => Type.fromTerm(value))));
  }
  return Eval3("object", fields, Type.Object((0, import_cosmokit3.mapValues)(fields, (value) => Type.fromTerm(value))));
};
Eval3.array = unary("array", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)) : Array.from(executeEval(table, expr)), (expr) => Type.Array(Type.fromTerm(expr)));
Eval3.exec = unary("exec", (expr, data) => expr.driver.executeSelection(expr, data), (expr) => Type.fromTerm(expr.args[0]));
function getRecursive(args, data) {
  if (typeof args === "string") {
    return getRecursive(["_", args], data);
  }
  const [ref, path] = args;
  let value = data[ref];
  if (!value)
    return value;
  if (path in value)
    return value[path];
  const prefix = Object.keys(value).find((s) => path.startsWith(s + ".")) || path.split(".", 1)[0];
  const rest = path.slice(prefix.length + 1).split(".").filter(Boolean);
  rest.unshift(prefix);
  for (const key of rest) {
    value = value[key];
    if (!value)
      return value;
  }
  return value;
}
__name(getRecursive, "getRecursive");
function executeEvalExpr(expr, data) {
  for (const key in expr) {
    if (key in operators) {
      return operators[key](expr[key], data);
    }
  }
  return expr;
}
__name(executeEvalExpr, "executeEvalExpr");
function executeAggr(expr, data) {
  if (typeof expr === "string") {
    return getRecursive(expr, data);
  }
  return executeEvalExpr(expr, data);
}
__name(executeAggr, "executeAggr");
function executeEval(data, expr) {
  if (isComparable(expr) || (0, import_cosmokit3.isNullable)(expr)) {
    return expr;
  }
  if (Array.isArray(expr)) {
    return expr.map((item) => executeEval(data, item));
  }
  return executeEvalExpr(expr, data);
}
__name(executeEval, "executeEval");
function executeUpdate(data, update, ref) {
  for (const key in update) {
    let root = data;
    const path = key.split(".");
    const last = path.pop();
    for (const key2 of path) {
      root = root[key2] ||= {};
    }
    root[last] = executeEval({ [ref]: data, _: data }, update[key]);
  }
  return data;
}
__name(executeUpdate, "executeUpdate");

// src/selection.ts
var createRow = /* @__PURE__ */ __name((ref, expr = {}, prefix = "", model) => new Proxy(expr, {
  get(target, key) {
    if (key === "$prefix")
      return prefix;
    if (key === "$model")
      return model;
    if (typeof key === "symbol" || key in target || key.startsWith("$"))
      return Reflect.get(target, key);
    let type;
    const field = model?.fields[prefix + key];
    if (Type.getInner(expr?.[Type.kType], key)) {
      type = Type.getInner(expr?.[Type.kType], key);
    } else if (field) {
      type = Type.fromField(field);
    } else if (Object.keys(model?.fields).some((k) => k.startsWith(`${prefix}${key}.`))) {
      type = Type.Object(Object.fromEntries(Object.entries(model?.fields).filter(([k]) => k.startsWith(`${prefix}${key}`)).map(([k, field2]) => [k.slice(prefix.length + key.length + 1), Type.fromField(field2)])));
    } else {
      type = Type.fromField("expr");
    }
    const row = createRow(ref, Eval3("", [ref, `${prefix}${key}`], type), `${prefix}${key}.`, model);
    if (Object.keys(model?.fields).some((k) => k.startsWith(`${prefix}${key}.`))) {
      return createRow(ref, Eval3.object(row), `${prefix}${key}.`, model);
    } else {
      return row;
    }
  }
}), "createRow");
var Executable = class {
  static {
    __name(this, "Executable");
  }
  row;
  model;
  driver;
  constructor(driver, payload) {
    Object.assign(this, payload);
    (0, import_cosmokit4.defineProperty)(this, "driver", driver);
    (0, import_cosmokit4.defineProperty)(this, "model", driver.model(this.table));
    (0, import_cosmokit4.defineProperty)(this, "row", createRow(this.ref, {}, "", this.model));
  }
  resolveQuery(query = {}) {
    if (typeof query === "function")
      return { $expr: query(this.row) };
    if (Array.isArray(query) || query instanceof RegExp || ["string", "number"].includes(typeof query)) {
      const { primary } = this.model;
      if (Array.isArray(primary)) {
        throw new TypeError("invalid shorthand for composite primary key");
      }
      return { [primary]: query };
    }
    return query;
  }
  resolveField(field) {
    if (typeof field === "string") {
      return this.row[field];
    } else if (typeof field === "function") {
      return field(this.row);
    } else {
      throw new TypeError("invalid field definition");
    }
  }
  resolveFields(fields) {
    if (typeof fields === "string")
      fields = [fields];
    if (Array.isArray(fields)) {
      const modelFields = Object.keys(this.model.fields);
      const entries = fields.flatMap((key) => {
        if (this.model.fields[key])
          return [[key, this.row[key]]];
        else if (modelFields.some((path) => path.startsWith(key + "."))) {
          return modelFields.filter((path) => path.startsWith(key + ".")).map((path) => [path, this.row[path]]);
        }
        return [[key, key.split(".").reduce((row, k) => row[k], this.row)]];
      });
      return Object.fromEntries(entries);
    } else {
      const entries = Object.entries(fields).flatMap(([key, field]) => {
        const expr = this.resolveField(field);
        if (expr["$object"]) {
          return Object.entries(expr["$object"]).map(([key2, expr2]) => [`${key}.${key2}`, expr2]);
        }
        return [[key, expr]];
      });
      return Object.fromEntries(entries);
    }
  }
  async execute() {
    await this.driver.database.prepared();
    await this.driver._ensureSession();
    return this.driver[this.type](this, ...this.args);
  }
};
var Selection = class _Selection extends Executable {
  static {
    __name(this, "Selection");
  }
  tables = {};
  constructor(driver, table, query) {
    super(driver, {
      type: "get",
      ref: randomId(),
      table,
      query: null,
      args: [{ sort: [], limit: Infinity, offset: 0, group: void 0, having: Eval3.and(), optional: {} }]
    });
    this.tables[this.ref] = this.model;
    this.query = this.resolveQuery(query);
    if (typeof table !== "string") {
      Object.assign(this.tables, table.tables);
    }
  }
  where(query) {
    this.query.$and ||= [];
    this.query.$and.push(this.resolveQuery(query));
    return this;
  }
  limit(...args) {
    if (args.length > 1)
      this.offset(args.shift());
    this.args[0].limit = args[0];
    return this;
  }
  offset(offset) {
    this.args[0].offset = offset;
    return this;
  }
  orderBy(field, direction = "asc") {
    this.args[0].sort.push([this.resolveField(field), direction]);
    return this;
  }
  groupBy(fields, ...args) {
    this.args[0].fields = this.resolveFields(fields);
    this.args[0].group = Object.keys(this.args[0].fields);
    const extra = typeof args[0] === "function" ? void 0 : args.shift();
    Object.assign(this.args[0].fields, this.resolveFields(extra || {}));
    if (args[0])
      this.having(args[0]);
    return new _Selection(this.driver, this);
  }
  having(query) {
    this.args[0].having["$and"].push(this.resolveField(query));
    return this;
  }
  project(fields) {
    this.args[0].fields = this.resolveFields(fields);
    return new _Selection(this.driver, this);
  }
  _action(type, ...args) {
    return new Executable(this.driver, { ...this, type, args });
  }
  evaluate(callback) {
    const selection = new _Selection(this.driver, this);
    if (!callback)
      callback = /* @__PURE__ */ __name((row) => Eval3.array(Eval3.object(row)), "callback");
    const expr = this.resolveField(callback);
    if (expr["$"])
      (0, import_cosmokit4.defineProperty)(expr, Type.kType, Type.Array(Type.fromTerm(expr)));
    return Eval3.exec(selection._action("eval", expr));
  }
  async execute(cursor) {
    if (typeof cursor === "function") {
      const selection = new _Selection(this.driver, this);
      return selection._action("eval", this.resolveField(cursor)).execute();
    }
    if (Array.isArray(cursor)) {
      cursor = { fields: cursor };
    } else if (!cursor) {
      cursor = {};
    }
    if (cursor.fields)
      this.project(cursor.fields);
    if (cursor.limit !== void 0)
      this.limit(cursor.limit);
    if (cursor.offset !== void 0)
      this.offset(cursor.offset);
    if (cursor.sort) {
      for (const field in cursor.sort) {
        this.orderBy(field, cursor.sort[field]);
      }
    }
    const rows = await super.execute();
    if (!cursor.fields)
      return rows;
    return rows.map((row) => {
      return (0, import_cosmokit4.filterKeys)(row, (key) => {
        return cursor.fields.some((k) => k === key || k.startsWith(`${key}.`));
      });
    });
  }
};
function executeSort(data, modifier, name) {
  const { limit, offset, sort } = modifier;
  data.sort((a, b) => {
    for (const [field, direction] of sort) {
      const sign = direction === "asc" ? 1 : -1;
      const x = executeEval({ [name]: a, _: a }, field);
      const y = executeEval({ [name]: b, _: b }, field);
      if (x < y)
        return -sign;
      if (x > y)
        return sign;
    }
    return 0;
  });
  return data.slice(offset, offset + limit);
}
__name(executeSort, "executeSort");

// src/database.ts
var Database = class _Database extends import_cordis.Service {
  static {
    __name(this, "Database");
  }
  static [import_cordis.Service.provide] = "model";
  static [import_cordis.Service.immediate] = true;
  static transact = Symbol("minato.transact");
  static migrate = Symbol("minato.migrate");
  tables = /* @__PURE__ */ Object.create(null);
  drivers = [];
  types = /* @__PURE__ */ Object.create(null);
  _driver;
  stashed = /* @__PURE__ */ new Set();
  prepareTasks = /* @__PURE__ */ Object.create(null);
  migrateTasks = /* @__PURE__ */ Object.create(null);
  async connect(driver, ...args) {
    this.ctx.plugin(driver, args[0]);
    await this.ctx.start();
  }
  refresh() {
    for (const name in this.tables) {
      this.prepareTasks[name] = this.prepare(name);
    }
  }
  async prepared() {
    if (this[_Database.migrate])
      return;
    await Promise.all(Object.values(this.prepareTasks));
  }
  getDriver(table) {
    if (table instanceof Selection)
      return table.driver;
    const model = this.tables[table];
    if (!model)
      throw new Error(`cannot resolve table "${table}"`);
    return model.ctx?.get("database")?._driver;
  }
  async prepare(name) {
    this.stashed.add(name);
    await this.prepareTasks[name];
    await Promise.resolve();
    if (!this.stashed.delete(name))
      return;
    const driver = this.getDriver(name);
    if (!driver)
      return;
    const { fields } = driver.model(name);
    Object.values(fields).forEach((field) => field?.transformers?.forEach((x) => driver.define(x)));
    await driver.prepare(name);
  }
  extend(name, fields, config = {}) {
    let model = this.tables[name];
    if (!model) {
      model = this.tables[name] = new Model(name);
    }
    Object.entries(fields).forEach(([key, field]) => {
      const transformer = [];
      this.parseField(field, transformer, void 0, (value) => field = fields[key] = value);
      if (typeof field === "object")
        field.transformers = transformer;
    });
    model.extend(fields, config);
    if ((0, import_cosmokit5.makeArray)(model.primary).every((key) => key in fields)) {
      (0, import_cosmokit5.defineProperty)(model, "ctx", this[import_cordis.Context.origin]);
    }
    this.prepareTasks[name] = this.prepare(name);
    this.ctx.emit("model", name);
  }
  _parseField(field, transformers = [], setInitial, setField) {
    if (field === "object") {
      setInitial?.({});
      setField?.({ type: "json", initial: {} });
      return Type.Object();
    } else if (field === "array") {
      setInitial?.([]);
      setField?.({ type: "json", initial: [] });
      return Type.Array();
    } else if (typeof field === "string" && this.types[field]) {
      transformers.push({
        types: [field],
        load: this.types[field].load,
        dump: this.types[field].dump
      }, ...this.types[field].transformers ?? []);
      setInitial?.(this.types[field].initial);
      setField?.({ ...this.types[field], type: field });
      return Type.fromField(field);
    } else if (typeof field === "string") {
      setInitial?.(Field.getInitial(field.split("(")[0]));
      setField?.(field);
      return Type.fromField(field.split("(")[0]);
    } else if (typeof field === "object" && field.type === "object") {
      const inner = field.inner ? unravel(field.inner, (value) => (value.type = "object", value.inner ??= {})) : /* @__PURE__ */ Object.create(null);
      const initial = /* @__PURE__ */ Object.create(null);
      const res = Type.Object((0, import_cosmokit5.mapValues)(inner, (x, k) => this.parseField(x, transformers, (value) => initial[k] = value)));
      setInitial?.(Field.getInitial("json", initial));
      setField?.({ initial: Field.getInitial("json", initial), ...field, deftype: "json", type: res });
      return res;
    } else if (typeof field === "object" && field.type === "array") {
      const res = field.inner ? Type.Array(this.parseField(field.inner, transformers)) : Type.Array();
      setInitial?.([]);
      setField?.({ initial: [], ...field, deftype: "json", type: res });
      return res;
    } else if (typeof field === "object" && this.types[field.type]) {
      transformers.push({
        types: [field.type],
        load: this.types[field.type].load,
        dump: this.types[field.type].dump
      }, ...this.types[field.type].transformers ?? []);
      setInitial?.(field.initial === void 0 ? this.types[field.type].initial : field.initial);
      setField?.({ initial: this.types[field.type].initial, ...field });
      return Type.fromField(field.type);
    } else {
      setInitial?.(Field.getInitial(field.type, field.initial));
      setField?.(field);
      return Type.fromField(field.type);
    }
  }
  parseField(field, transformers = [], setInitial, setField) {
    let midfield;
    let type = this._parseField(field, transformers, setInitial, (value) => (midfield = value, setField?.(value)));
    if (typeof field === "object" && field.load && field.dump) {
      if (type.inner)
        type = Type.fromField(this.define({ ...(0, import_cosmokit5.omit)(midfield, ["load", "dump"]), type }));
      const name = this.define({ ...field, deftype: midfield.deftype, type: type.type });
      transformers.push({
        types: [name],
        load: field.load,
        dump: field.dump
      });
      setInitial?.(field.initial);
      setField?.({ ...field, deftype: midfield.deftype ?? this.types[type.type]?.deftype ?? type.type, initial: midfield.initial, type: name });
      return Type.fromField(name);
    }
    if (typeof midfield === "object")
      setField?.({ ...midfield, deftype: midfield.deftype ?? this.types[type.type]?.deftype ?? type?.type });
    return type;
  }
  define(name, field) {
    if (typeof name === "object") {
      field = name;
      name = void 0;
    }
    if (name && this.types[name])
      throw new Error(`type "${name}" already defined`);
    if (!name)
      while (this.types[name = "_define_" + randomId()])
        ;
    const transformers = [];
    const type = this._parseField(field, transformers, void 0, (value) => field = value);
    field.transformers = transformers;
    this[import_cordis.Context.current].effect(() => {
      this.types[name] = { ...field };
      this.types[name].deftype ??= this.types[field.type]?.deftype ?? type.type;
      return () => delete this.types[name];
    });
    return name;
  }
  migrate(name, fields, callback) {
    this.extend(name, fields, { callback });
  }
  select(table, query) {
    return new Selection(this.getDriver(table), table, query);
  }
  join(tables, query = (...args) => Eval3.and(), optional) {
    const oldTables = tables;
    if (Array.isArray(oldTables)) {
      tables = Object.fromEntries(oldTables.map((name) => [name, this.select(name)]));
    }
    let sels = (0, import_cosmokit5.mapValues)(tables, (t) => {
      return typeof t === "string" ? this.select(t) : t;
    });
    if (Object.keys(sels).length === 0)
      throw new Error("no tables to join");
    const drivers = new Set(Object.values(sels).map((sel2) => sel2.driver));
    if (drivers.size !== 1)
      throw new Error("cannot join tables from different drivers");
    if (Object.keys(sels).length === 2 && (optional?.[0] || optional?.[Object.keys(sels)[0]])) {
      if (optional[1] || optional[Object.keys(sels)[1]])
        throw new Error("full join is not supported");
      sels = Object.fromEntries(Object.entries(sels).reverse());
    }
    const sel = new Selection([...drivers][0], sels);
    if (Array.isArray(oldTables)) {
      sel.args[0].having = Eval3.and(query(...oldTables.map((name) => sel.row[name])));
      sel.args[0].optional = Object.fromEntries(oldTables.map((name, index) => [name, optional?.[index]]));
    } else {
      sel.args[0].having = Eval3.and(query(sel.row));
      sel.args[0].optional = optional;
    }
    return this.select(sel);
  }
  async get(table, query, cursor) {
    return this.select(table, query).execute(cursor);
  }
  async eval(table, expr, query) {
    return this.select(table, query).execute(typeof expr === "function" ? expr : () => expr);
  }
  async set(table, query, update) {
    const sel = this.select(table, query);
    if (typeof update === "function")
      update = update(sel.row);
    const primary = (0, import_cosmokit5.makeArray)(sel.model.primary);
    if (primary.some((key) => key in update)) {
      throw new TypeError(`cannot modify primary key`);
    }
    update = sel.model.format(update);
    if (Object.keys(update).length === 0)
      return {};
    return await sel._action("set", update).execute();
  }
  async remove(table, query) {
    const sel = this.select(table, query);
    return await sel._action("remove").execute();
  }
  async create(table, data) {
    const sel = this.select(table);
    const { primary, autoInc } = sel.model;
    if (!autoInc) {
      const keys = (0, import_cosmokit5.makeArray)(primary);
      if (keys.some((key) => !(key in data))) {
        throw new Error("missing primary key");
      }
    }
    return sel._action("create", sel.model.create(data)).execute();
  }
  async upsert(table, upsert, keys) {
    const sel = this.select(table);
    if (typeof upsert === "function")
      upsert = upsert(sel.row);
    upsert = upsert.map((item) => sel.model.format(item));
    keys = (0, import_cosmokit5.makeArray)(keys || sel.model.primary);
    return await sel._action("upsert", upsert, keys).execute();
  }
  makeProxy(marker, getDriver) {
    const drivers = /* @__PURE__ */ new Map();
    const database = new Proxy(this, {
      get: (target, p, receiver) => {
        if (p === marker)
          return true;
        if (p !== "getDriver")
          return Reflect.get(target, p, receiver);
        return (name) => {
          const original = this.getDriver(name);
          let driver = drivers.get(original);
          if (!driver) {
            driver = getDriver?.(original, database) ?? new Proxy(original, {
              get: (target2, p2, receiver2) => {
                if (p2 === "database")
                  return database;
                return Reflect.get(target2, p2, receiver2);
              }
            });
            drivers.set(original, driver);
          }
          return driver;
        };
      }
    });
    return database;
  }
  withTransaction(callback) {
    return this.transact(callback);
  }
  async transact(callback) {
    if (this[_Database.transact])
      throw new Error("nested transactions are not supported");
    const finalTasks = [];
    const database = this.makeProxy(_Database.transact, (driver) => {
      let session;
      let _resolve;
      const sessionTask = new Promise((resolve) => _resolve = resolve);
      driver = new Proxy(driver, {
        get: (target, p, receiver) => {
          if (p === "database")
            return database;
          if (p === "session")
            return session;
          if (p === "_ensureSession")
            return () => sessionTask;
          return Reflect.get(target, p, receiver);
        }
      });
      finalTasks.push(driver.withTransaction((_session) => {
        _resolve(session = _session);
        return initialTask;
      }));
      return driver;
    });
    const initialTask = (async () => {
      await Promise.resolve();
      await callback(database);
    })();
    await initialTask.finally(() => Promise.all(finalTasks));
  }
  async stopAll() {
    await Promise.all(this.drivers.splice(0, Infinity).map((driver) => driver.stop()));
  }
  async drop(table) {
    if (this[_Database.transact])
      throw new Error("cannot drop table in transaction");
    await this.getDriver(table).drop(table);
  }
  async dropAll() {
    if (this[_Database.transact])
      throw new Error("cannot drop table in transaction");
    await Promise.all(Object.values(this.drivers).map((driver) => driver.dropAll()));
  }
  async stats() {
    await this.prepared();
    const stats = { size: 0, tables: {} };
    await Promise.all(Object.values(this.drivers).map(async (driver) => {
      const { size = 0, tables } = await driver.stats();
      stats.size += size;
      Object.assign(stats.tables, tables);
    }));
    return stats;
  }
};

// src/driver.ts
var import_cosmokit6 = require("cosmokit");
var import_cordis2 = require("cordis");
var Driver = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.database = ctx.model;
    this.logger = ctx.logger(this.constructor.name);
    ctx.on("ready", async () => {
      await Promise.resolve();
      await this.start();
      ctx.model.drivers.push(this);
      ctx.model.refresh();
      const database = Object.create(ctx.model);
      database._driver = this;
      ctx.set("database", import_cordis2.Context.associate(database, "database"));
    });
    ctx.on("dispose", async () => {
      (0, import_cosmokit6.remove)(ctx.model.drivers, this);
      await this.stop();
    });
  }
  static {
    __name(this, "Driver");
  }
  static inject = ["model"];
  database;
  logger;
  types = /* @__PURE__ */ Object.create(null);
  model(table) {
    if (typeof table === "string") {
      const model2 = this.database.tables[table];
      if (model2)
        return model2;
      throw new TypeError(`unknown table name "${table}"`);
    }
    if (table instanceof Selection) {
      if (!table.args[0].fields && (typeof table.table === "string" || table.table instanceof Selection)) {
        return table.model;
      }
      const model2 = new Model("temp");
      if (table.args[0].fields) {
        model2.fields = (0, import_cosmokit6.mapValues)(table.args[0].fields, (expr) => ({
          type: Type.fromTerm(expr)
        }));
      } else {
        model2.fields = (0, import_cosmokit6.mapValues)(table.model.fields, (field) => ({
          type: Type.fromField(field)
        }));
      }
      return model2;
    }
    const model = new Model("temp");
    for (const key in table) {
      const submodel = this.model(table[key]);
      for (const field in submodel.fields) {
        if (submodel.fields[field].deprecated)
          continue;
        model.fields[`${key}.${field}`] = {
          expr: Eval3("", [table[key].ref, field], Type.fromField(submodel.fields[field])),
          type: Type.fromField(submodel.fields[field])
        };
      }
    }
    return model;
  }
  async migrate(name, hooks) {
    const database = this.database.makeProxy(Database.migrate);
    const model = this.model(name);
    await (database.migrateTasks[name] = Promise.resolve(database.migrateTasks[name]).then(() => {
      return Promise.all([...model.migrations].map(async ([migrate, keys]) => {
        try {
          if (!hooks.before(keys))
            return;
          await migrate(database);
          hooks.after(keys);
        } catch (reason) {
          hooks.error(reason);
        }
      }));
    }).then(hooks.finalize).catch(hooks.error));
  }
  define(converter) {
    converter.types.forEach((type) => this.types[type] = converter);
  }
  async _ensureSession() {
  }
};

// src/error.ts
var RuntimeError = class _RuntimeError extends Error {
  constructor(code, message) {
    super(message || code.replace("-", " "));
    this.code = code;
  }
  static {
    __name(this, "RuntimeError");
  }
  name = "RuntimeError";
  static check(error, code) {
    if (!(error instanceof _RuntimeError))
      return false;
    return !code || error.message === code;
  }
};

// src/query.ts
var import_cosmokit7 = require("cosmokit");
var queryOperators = {
  // logical
  $or: (query, data) => query.reduce((prev, query2) => prev || executeFieldQuery(query2, data), false),
  $and: (query, data) => query.reduce((prev, query2) => prev && executeFieldQuery(query2, data), true),
  $not: (query, data) => !executeFieldQuery(query, data),
  // existence
  $exists: (query, data) => query !== (0, import_cosmokit7.isNullable)(data),
  // comparison
  $eq: (query, data) => data.valueOf() === query.valueOf(),
  $ne: (query, data) => data.valueOf() !== query.valueOf(),
  $gt: (query, data) => data.valueOf() > query.valueOf(),
  $gte: (query, data) => data.valueOf() >= query.valueOf(),
  $lt: (query, data) => data.valueOf() < query.valueOf(),
  $lte: (query, data) => data.valueOf() <= query.valueOf(),
  // membership
  $in: (query, data) => query.includes(data),
  $nin: (query, data) => !query.includes(data),
  // regexp
  $regex: (query, data) => makeRegExp(query).test(data),
  $regexFor: (query, data) => new RegExp(data, "i").test(query),
  // bitwise
  $bitsAllSet: (query, data) => (query & data) === query,
  $bitsAllClear: (query, data) => (query & data) === 0,
  $bitsAnySet: (query, data) => (query & data) !== 0,
  $bitsAnyClear: (query, data) => (query & data) !== query,
  // list
  $el: (query, data) => data.some((item) => executeFieldQuery(query, item)),
  $size: (query, data) => data.length === query
};
function executeFieldQuery(query, data) {
  if (Array.isArray(query)) {
    return query.includes(data);
  } else if (query instanceof RegExp) {
    return query.test(data);
  } else if (isComparable(query)) {
    return data.valueOf() === query.valueOf();
  } else if ((0, import_cosmokit7.isNullable)(query)) {
    return (0, import_cosmokit7.isNullable)(data);
  }
  for (const key in query) {
    if (key in queryOperators) {
      if (!queryOperators[key](query[key], data))
        return false;
    }
  }
  return true;
}
__name(executeFieldQuery, "executeFieldQuery");
function executeQuery(data, query, ref, env = {}) {
  const entries = Object.entries(query);
  return entries.every(([key, value]) => {
    if (key === "$and") {
      return value.reduce((prev, query2) => prev && executeQuery(data, query2, ref, env), true);
    } else if (key === "$or") {
      return value.reduce((prev, query2) => prev || executeQuery(data, query2, ref, env), false);
    } else if (key === "$not") {
      return !executeQuery(data, value, ref, env);
    } else if (key === "$expr") {
      return executeEval({ ...env, [ref]: data, _: data }, value);
    }
    try {
      return executeFieldQuery(value, data[key]);
    } catch {
      return false;
    }
  });
}
__name(executeQuery, "executeQuery");

// src/index.ts
var import_cordis3 = require("cordis");
var Types = Symbol("minato.types");
var Tables = Symbol("minato.tables");
var src_default = Database;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  $,
  Database,
  Driver,
  Eval,
  Field,
  Logger,
  Model,
  Primary,
  RuntimeError,
  Schema,
  Selection,
  Tables,
  Type,
  Types,
  executeEval,
  executeQuery,
  executeSort,
  executeUpdate,
  hasSubquery,
  isComparable,
  isEvalExpr,
  makeRegExp,
  randomId,
  unravel,
  z
});
//# sourceMappingURL=index.cjs.map
