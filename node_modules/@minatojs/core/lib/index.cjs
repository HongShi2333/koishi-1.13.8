"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// minato/packages/core/src/index.ts
var src_exports = {};
__export(src_exports, {
  $: () => Eval,
  Database: () => Database,
  Driver: () => Driver,
  Eval: () => Eval,
  Field: () => Field,
  Model: () => Model,
  Primary: () => Primary,
  RuntimeError: () => RuntimeError,
  Selection: () => Selection,
  executeEval: () => executeEval,
  executeQuery: () => executeQuery,
  executeSort: () => executeSort,
  executeUpdate: () => executeUpdate,
  isComparable: () => isComparable,
  isEvalExpr: () => isEvalExpr,
  makeRegExp: () => makeRegExp,
  randomId: () => randomId
});
module.exports = __toCommonJS(src_exports);

// minato/packages/core/src/driver.ts
var import_cosmokit4 = require("cosmokit");

// minato/packages/core/src/eval.ts
var import_cosmokit = require("cosmokit");

// minato/packages/core/src/utils.ts
function isComparable(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value instanceof Date;
}
__name(isComparable, "isComparable");
var letters = "abcdefghijklmnopqrstuvwxyz";
function randomId() {
  return Array(8).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join("");
}
__name(randomId, "randomId");
function makeRegExp(source) {
  return source instanceof RegExp ? source : new RegExp(source);
}
__name(makeRegExp, "makeRegExp");

// minato/packages/core/src/eval.ts
function isEvalExpr(value) {
  return value && Object.keys(value).some((key) => key.startsWith("$"));
}
__name(isEvalExpr, "isEvalExpr");
var kExpr = Symbol("expr");
var kType = Symbol("type");
var kAggr = Symbol("aggr");
var Eval = /* @__PURE__ */ __name((key, value) => (0, import_cosmokit.defineProperty)({ ["$" + key]: value }, kExpr, true), "Eval");
var operators = {};
operators["$"] = getRecursive;
function unary(key, callback) {
  operators[`$${key}`] = callback;
  return (value) => Eval(key, value);
}
__name(unary, "unary");
function multary(key, callback) {
  operators[`$${key}`] = callback;
  return (...args) => Eval(key, args);
}
__name(multary, "multary");
function comparator(key, callback) {
  operators[`$${key}`] = (args, data) => {
    const left = executeEval(data, args[0]);
    const right = executeEval(data, args[1]);
    if ((0, import_cosmokit.isNullable)(left) || (0, import_cosmokit.isNullable)(right))
      return true;
    return callback(left.valueOf(), right.valueOf());
  };
  return (...args) => Eval(key, args);
}
__name(comparator, "comparator");
Eval.switch = (branches, vDefault) => Eval("switch", { branches, default: vDefault });
operators.$switch = (args, data) => {
  for (const branch of args.branches) {
    if (executeEval(data, branch.case))
      return executeEval(data, branch.then);
  }
  return executeEval(data, args.default);
};
Eval.if = multary("if", ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse));
Eval.ifNull = multary("ifNull", ([value, fallback], data) => {
  var _a;
  return (_a = executeEval(data, value)) != null ? _a : executeEval(data, fallback);
});
Eval.add = multary("add", (args, data) => args.reduce((prev, curr) => prev + executeEval(data, curr), 0));
Eval.mul = Eval.multiply = multary("multiply", (args, data) => args.reduce((prev, curr) => prev * executeEval(data, curr), 1));
Eval.sub = Eval.subtract = multary("subtract", ([left, right], data) => executeEval(data, left) - executeEval(data, right));
Eval.div = Eval.divide = multary("divide", ([left, right], data) => executeEval(data, left) / executeEval(data, right));
Eval.mod = Eval.modulo = multary("modulo", ([left, right], data) => executeEval(data, left) % executeEval(data, right));
Eval.abs = unary("abs", (arg, data) => Math.abs(executeEval(data, arg)));
Eval.floor = unary("floor", (arg, data) => Math.floor(executeEval(data, arg)));
Eval.ceil = unary("ceil", (arg, data) => Math.ceil(executeEval(data, arg)));
Eval.round = unary("round", (arg, data) => Math.round(executeEval(data, arg)));
Eval.exp = unary("exp", (arg, data) => Math.exp(executeEval(data, arg)));
Eval.log = multary("log", ([left, right], data) => Math.log(executeEval(data, left)) / Math.log(executeEval(data, right != null ? right : Math.E)));
Eval.pow = Eval.power = multary("power", ([left, right], data) => Math.pow(executeEval(data, left), executeEval(data, right)));
Eval.random = () => Eval("random", {});
operators.$random = () => Math.random();
Eval.eq = comparator("eq", (left, right) => left === right);
Eval.ne = comparator("ne", (left, right) => left !== right);
Eval.gt = comparator("gt", (left, right) => left > right);
Eval.ge = Eval.gte = comparator("gte", (left, right) => left >= right);
Eval.lt = comparator("lt", (left, right) => left < right);
Eval.le = Eval.lte = comparator("lte", (left, right) => left <= right);
Eval.in = multary("in", ([value, array], data) => executeEval(data, array).includes(executeEval(data, value)));
Eval.nin = multary("nin", ([value, array], data) => !executeEval(data, array).includes(executeEval(data, value)));
Eval.concat = multary("concat", (args, data) => args.map((arg) => executeEval(data, arg)).join(""));
Eval.regex = multary("regex", ([value, regex], data) => makeRegExp(executeEval(data, regex)).test(executeEval(data, value)));
Eval.and = multary("and", (args, data) => args.every((arg) => executeEval(data, arg)));
Eval.or = multary("or", (args, data) => args.some((arg) => executeEval(data, arg)));
Eval.not = unary("not", (value, data) => !executeEval(data, value));
Eval.number = unary("number", (arg, data) => {
  const value = executeEval(data, arg);
  return value instanceof Date ? Math.floor(value.valueOf() / 1e3) : Number(value);
});
Eval.sum = unary("sum", (expr, table) => Array.isArray(table) ? table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) : Array.from(executeEval(table, expr)).reduce((prev, curr) => prev + curr, 0));
Eval.avg = unary("avg", (expr, table) => {
  if (Array.isArray(table))
    return table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length;
  else {
    const array = Array.from(executeEval(table, expr));
    return array.reduce((prev, curr) => prev + curr, 0) / array.length;
  }
});
Eval.max = unary("max", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x > y ? x : y, -Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x > y ? x : y, -Infinity));
Eval.min = unary("min", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x < y ? x : y, Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x < y ? x : y, Infinity));
Eval.count = unary("count", (expr, table) => new Set(table.map((data) => executeAggr(expr, data))).size);
(0, import_cosmokit.defineProperty)(Eval, "length", unary("length", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).length : Array.from(executeEval(table, expr)).length));
operators.$object = (field, table) => (0, import_cosmokit.valueMap)(field, (value) => executeAggr(value, table));
Eval.object = (fields) => {
  if (fields.$model) {
    const modelFields = Object.keys(fields.$model.fields);
    const prefix = fields.$prefix;
    return Eval("object", Object.fromEntries(
      modelFields.filter((path) => path.startsWith(prefix)).map((k) => [k.slice(prefix.length), fields[k.slice(prefix.length)]])
    ));
  }
  return Eval("object", fields);
};
Eval.array = unary("array", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)) : Array.from(executeEval(table, expr)));
Eval.exec = unary("exec", (expr, data) => expr.driver.executeSelection(expr, data));
function getRecursive(args, data) {
  if (typeof args === "string") {
    return getRecursive(["_", args], data);
  }
  const [ref, path] = args;
  let value = data[ref];
  if (!value)
    return value;
  if (path in value)
    return value[path];
  const prefix = Object.keys(value).find((s) => path.startsWith(s + ".")) || path.split(".", 1)[0];
  const rest = path.slice(prefix.length + 1).split(".").filter(Boolean);
  rest.unshift(prefix);
  for (const key of rest) {
    value = value[key];
    if (!value)
      return value;
  }
  return value;
}
__name(getRecursive, "getRecursive");
function executeEvalExpr(expr, data) {
  for (const key in expr) {
    if (key in operators) {
      return operators[key](expr[key], data);
    }
  }
  return expr;
}
__name(executeEvalExpr, "executeEvalExpr");
function executeAggr(expr, data) {
  if (typeof expr === "string") {
    return getRecursive(expr, data);
  }
  return executeEvalExpr(expr, data);
}
__name(executeAggr, "executeAggr");
function executeEval(data, expr) {
  if (isComparable(expr) || (0, import_cosmokit.isNullable)(expr)) {
    return expr;
  }
  if (Array.isArray(expr)) {
    return expr.map((item) => executeEval(data, item));
  }
  return executeEvalExpr(expr, data);
}
__name(executeEval, "executeEval");
function executeUpdate(data, update, ref) {
  for (const key in update) {
    let root = data;
    const path = key.split(".");
    const last = path.pop();
    for (const key2 of path) {
      root = root[key2] || (root[key2] = {});
    }
    root[last] = executeEval({ [ref]: data, _: data }, update[key]);
  }
  return data;
}
__name(executeUpdate, "executeUpdate");

// minato/packages/core/src/model.ts
var import_cosmokit2 = require("cosmokit");
var Primary = Symbol("Primary");
var Field;
((Field3) => {
  Field3.number = ["integer", "unsigned", "float", "double", "decimal"];
  Field3.string = ["char", "string", "text"];
  Field3.boolean = ["boolean"];
  Field3.date = ["timestamp", "date", "time"];
  Field3.object = ["list", "json"];
  const regexp = /^(\w+)(?:\((.+)\))?$/;
  function parse(source) {
    if (typeof source === "function")
      return { type: "expr", expr: source };
    if (typeof source !== "string")
      return { initial: null, ...source };
    const capture = regexp.exec(source);
    if (!capture)
      throw new TypeError("invalid field definition");
    const type = capture[1];
    const args = (capture[2] || "").split(",");
    const field = { type };
    if (field.initial === void 0) {
      if (Field3.number.includes(field.type))
        field.initial = 0;
      if (Field3.string.includes(field.type))
        field.initial = "";
      if (field.type === "list")
        field.initial = [];
      if (field.type === "json")
        field.initial = {};
    }
    if (type === "decimal") {
      field.precision = +args[0];
      field.scale = +args[1];
    } else if (args[0]) {
      field.length = +args[0];
    }
    return field;
  }
  Field3.parse = parse;
  __name(parse, "parse");
})(Field || (Field = {}));
var _Model = class _Model {
  constructor(name) {
    this.name = name;
    this.autoInc = false;
    this.primary = "id";
    this.unique = [];
    this.foreign = {};
  }
  fields = {};
  migrations = /* @__PURE__ */ new Map();
  extend(fields = {}, config = {}) {
    var _a;
    const { primary, autoInc, unique = [], foreign, callback } = config;
    this.primary = primary || this.primary;
    this.autoInc = autoInc || this.autoInc;
    unique.forEach((key) => this.unique.includes(key) || this.unique.push(key));
    Object.assign(this.foreign, foreign);
    if (callback)
      this.migrations.set(callback, Object.keys(fields));
    for (const key in fields) {
      this.fields[key] = Field.parse(fields[key]);
      this.fields[key].deprecated = !!callback;
    }
    if (typeof this.primary === "string" && ((_a = this.fields[this.primary]) == null ? void 0 : _a.type) === "primary") {
      this.autoInc = true;
    }
    this.checkIndex(this.primary);
    this.unique.forEach((index) => this.checkIndex(index));
  }
  checkIndex(index) {
    for (const key of (0, import_cosmokit2.makeArray)(index)) {
      if (!this.fields[key]) {
        throw new TypeError(`missing field definition for index key "${key}"`);
      }
    }
  }
  resolveValue(key, value) {
    var _a, _b;
    if ((0, import_cosmokit2.isNullable)(value))
      return value;
    if (((_a = this.fields[key]) == null ? void 0 : _a.type) === "time") {
      const date = /* @__PURE__ */ new Date(0);
      date.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
      return date;
    } else if (((_b = this.fields[key]) == null ? void 0 : _b.type) === "date") {
      const date = new Date(value);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    return value;
  }
  format(source, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields);
    Object.entries(source).map(([key, value]) => {
      key = prefix + key;
      if (value === void 0)
        return;
      if (fields.includes(key)) {
        result[key] = this.resolveValue(key, value);
        return;
      }
      const field = fields.find((field2) => key.startsWith(field2 + "."));
      if (field) {
        result[key] = value;
      } else if (!value || typeof value !== "object" || isEvalExpr(value) || Object.keys(value).length === 0) {
        if (strict) {
          throw new TypeError(`unknown field "${key}" in model ${this.name}`);
        }
      } else {
        this.format(value, strict, key + ".", result);
      }
    });
    return result;
  }
  parse(source, strict = true, prefix = "", result = {}) {
    var _a, _b, _c;
    const fields = Object.keys(this.fields);
    for (const key in source) {
      let node = result;
      const segments = key.split(".").reverse();
      for (let index = segments.length - 1; index > 0; index--) {
        const segment = segments[index];
        node = (_a = node[segment]) != null ? _a : node[segment] = {};
      }
      if (key in source) {
        const fullKey = prefix + key, value = source[key];
        const field = fields.find((field2) => fullKey === field2 || fullKey.startsWith(field2 + "."));
        if (field) {
          node[segments[0]] = this.resolveValue(key, value);
        } else if (!value || typeof value !== "object" || isEvalExpr(value) || Array.isArray(value) || Object.keys(value).length === 0) {
          if (strict) {
            throw new TypeError(`unknown field "${fullKey}" in model ${this.name}`);
          } else {
            node[segments[0]] = this.resolveValue(key, value);
          }
        } else {
          this.parse(value, strict, fullKey + ".", (_c = node[_b = segments[0]]) != null ? _c : node[_b] = {});
        }
      }
    }
    return result;
  }
  create(data) {
    const result = {};
    const keys = (0, import_cosmokit2.makeArray)(this.primary);
    for (const key in this.fields) {
      const { initial, deprecated } = this.fields[key];
      if (deprecated)
        continue;
      if (!keys.includes(key) && !(0, import_cosmokit2.isNullable)(initial)) {
        result[key] = (0, import_cosmokit2.clone)(initial);
      }
    }
    return this.parse({ ...result, ...data });
  }
};
__name(_Model, "Model");
var Model = _Model;

// minato/packages/core/src/selection.ts
var import_cosmokit3 = require("cosmokit");
var createRow = /* @__PURE__ */ __name((ref, expr = {}, prefix = "", model) => new Proxy(expr, {
  get(target, key) {
    if (key === "$prefix")
      return prefix;
    if (key === "$model")
      return model;
    if (typeof key === "symbol" || key in target || key.startsWith("$"))
      return Reflect.get(target, key);
    return createRow(ref, Eval("", [ref, `${prefix}${key}`]), `${prefix}${key}.`, model);
  }
}), "createRow");
var _Executable = class _Executable {
  row;
  model;
  driver;
  constructor(driver, payload) {
    Object.assign(this, payload);
    (0, import_cosmokit3.defineProperty)(this, "driver", driver);
    (0, import_cosmokit3.defineProperty)(this, "model", driver.model(this.table));
    (0, import_cosmokit3.defineProperty)(this, "row", createRow(this.ref, {}, "", this.model));
  }
  resolveQuery(query = {}) {
    if (typeof query === "function")
      return { $expr: query(this.row) };
    if (Array.isArray(query) || query instanceof RegExp || ["string", "number"].includes(typeof query)) {
      const { primary } = this.model;
      if (Array.isArray(primary)) {
        throw new TypeError("invalid shorthand for composite primary key");
      }
      return { [primary]: query };
    }
    return query;
  }
  resolveField(field) {
    if (typeof field === "string") {
      return this.row[field];
    } else if (typeof field === "function") {
      return field(this.row);
    } else {
      throw new TypeError("invalid field definition");
    }
  }
  resolveFields(fields) {
    if (typeof fields === "string")
      fields = [fields];
    if (Array.isArray(fields)) {
      const modelFields = Object.keys(this.model.fields);
      const keys = fields.flatMap((key) => {
        if (this.model.fields[key])
          return key;
        return modelFields.filter((path) => path.startsWith(key + "."));
      });
      return Object.fromEntries(keys.map((key) => [key, this.row[key]]));
    } else {
      return (0, import_cosmokit3.valueMap)(fields, (field) => this.resolveField(field));
    }
  }
  async execute() {
    await this.driver.database.prepared();
    return this.driver[this.type](this, ...this.args);
  }
};
__name(_Executable, "Executable");
var Executable = _Executable;
var _Selection = class _Selection extends Executable {
  tables = {};
  constructor(driver, table, query) {
    super(driver, {
      type: "get",
      ref: randomId(),
      table,
      query: null,
      args: [{ sort: [], limit: Infinity, offset: 0, group: void 0, having: Eval.and(), optional: {} }]
    });
    this.tables[this.ref] = this.model;
    this.query = this.resolveQuery(query);
    if (typeof table !== "string") {
      Object.assign(this.tables, table.tables);
    }
  }
  where(query) {
    var _a;
    (_a = this.query).$and || (_a.$and = []);
    this.query.$and.push(this.resolveQuery(query));
    return this;
  }
  limit(...args) {
    if (args.length > 1)
      this.offset(args.shift());
    this.args[0].limit = args[0];
    return this;
  }
  offset(offset) {
    this.args[0].offset = offset;
    return this;
  }
  orderBy(field, direction = "asc") {
    this.args[0].sort.push([this.resolveField(field), direction]);
    return this;
  }
  groupBy(fields, ...args) {
    this.args[0].fields = this.resolveFields(fields);
    this.args[0].group = Object.keys(this.args[0].fields);
    const extra = typeof args[0] === "function" ? void 0 : args.shift();
    Object.assign(this.args[0].fields, this.resolveFields(extra || {}));
    if (args[0])
      this.having(args[0]);
    return new _Selection(this.driver, this);
  }
  having(query) {
    this.args[0].having["$and"].push(this.resolveField(query));
    return this;
  }
  project(fields) {
    this.args[0].fields = this.resolveFields(fields);
    return new _Selection(this.driver, this);
  }
  _action(type, ...args) {
    return new Executable(this.driver, { ...this, type, args });
  }
  evaluate(callback) {
    const selection = new _Selection(this.driver, this);
    if (!callback)
      callback = /* @__PURE__ */ __name((row) => Eval.array(Eval.object(row)), "callback");
    return Eval("exec", selection._action("eval", this.resolveField(callback)));
  }
  execute(cursor) {
    if (typeof cursor === "function") {
      const selection = new _Selection(this.driver, this);
      return selection._action("eval", this.resolveField(cursor)).execute();
    }
    if (Array.isArray(cursor)) {
      cursor = { fields: cursor };
    } else if (!cursor) {
      cursor = {};
    }
    if (cursor.fields)
      this.project(cursor.fields);
    if (cursor.limit !== void 0)
      this.limit(cursor.limit);
    if (cursor.offset !== void 0)
      this.offset(cursor.offset);
    if (cursor.sort) {
      for (const field in cursor.sort) {
        this.orderBy(field, cursor.sort[field]);
      }
    }
    return super.execute();
  }
};
__name(_Selection, "Selection");
var Selection = _Selection;
function executeSort(data, modifier, name) {
  const { limit, offset, sort } = modifier;
  data.sort((a, b) => {
    for (const [field, direction] of sort) {
      const sign = direction === "asc" ? 1 : -1;
      const x = executeEval({ [name]: a, _: a }, field);
      const y = executeEval({ [name]: b, _: b }, field);
      if (x < y)
        return -sign;
      if (x > y)
        return sign;
    }
    return 0;
  });
  return data.slice(offset, offset + limit);
}
__name(executeSort, "executeSort");

// minato/packages/core/src/driver.ts
var kTransaction = Symbol("transaction");
var _Database = class _Database {
  tables = /* @__PURE__ */ Object.create(null);
  drivers = /* @__PURE__ */ Object.create(null);
  migrating = false;
  prepareTasks = /* @__PURE__ */ Object.create(null);
  migrateTasks = /* @__PURE__ */ Object.create(null);
  stashed = /* @__PURE__ */ new Set();
  refresh() {
    for (const name in this.tables) {
      this.prepareTasks[name] = this.prepare(name);
    }
  }
  async prepared() {
    await Promise.all(Object.values(this.prepareTasks));
    if (!this.migrating) {
      await Promise.all(Object.values(this.migrateTasks));
    }
  }
  getDriver(table) {
    const driver = Object.values(this.drivers)[0];
    if (driver)
      driver.database = this;
    return driver;
  }
  async prepare(name) {
    var _a;
    this.stashed.add(name);
    await this.prepareTasks[name];
    await Promise.resolve();
    if (!this.stashed.delete(name))
      return;
    await ((_a = this.getDriver(name)) == null ? void 0 : _a.prepare(name));
  }
  extend(name, fields, config = {}) {
    let model = this.tables[name];
    if (!model) {
      model = this.tables[name] = new Model(name);
    }
    model.extend(fields, config);
    this.prepareTasks[name] = this.prepare(name);
  }
  migrate(name, fields, callback) {
    this.extend(name, fields, { callback });
  }
  select(table, query) {
    return new Selection(this.getDriver(table), table, query);
  }
  join(tables, query, optional) {
    if (Array.isArray(tables)) {
      const sel = new Selection(this.getDriver(tables[0]), Object.fromEntries(tables.map((name) => [name, this.select(name)])));
      if (typeof query === "function") {
        sel.args[0].having = Eval.and(query(...tables.map((name) => sel.row[name])));
      }
      sel.args[0].optional = Object.fromEntries(tables.map((name, index) => [name, optional == null ? void 0 : optional[index]]));
      return this.select(sel);
    } else {
      const sel = new Selection(this.getDriver(Object.values(tables)[0]), (0, import_cosmokit4.valueMap)(tables, (t) => typeof t === "string" ? this.select(t) : t));
      if (typeof query === "function") {
        sel.args[0].having = Eval.and(query(sel.row));
      }
      sel.args[0].optional = optional;
      return this.select(sel);
    }
  }
  async get(table, query, cursor) {
    return this.select(table, query).execute(cursor);
  }
  async eval(table, expr, query) {
    return this.select(table, query).execute(typeof expr === "function" ? expr : () => expr);
  }
  async set(table, query, update) {
    const sel = this.select(table, query);
    if (typeof update === "function")
      update = update(sel.row);
    const primary = (0, import_cosmokit4.makeArray)(sel.model.primary);
    if (primary.some((key) => key in update)) {
      throw new TypeError(`cannot modify primary key`);
    }
    update = sel.model.format(update);
    if (Object.keys(update).length === 0)
      return {};
    return await sel._action("set", update).execute();
  }
  async remove(table, query) {
    const sel = this.select(table, query);
    return await sel._action("remove").execute();
  }
  async create(table, data) {
    const sel = this.select(table);
    const { primary, autoInc } = sel.model;
    if (!autoInc) {
      const keys = (0, import_cosmokit4.makeArray)(primary);
      if (keys.some((key) => !(key in data))) {
        throw new Error("missing primary key");
      }
    }
    return sel._action("create", sel.model.create(data)).execute();
  }
  async upsert(table, upsert, keys) {
    const sel = this.select(table);
    if (typeof upsert === "function")
      upsert = upsert(sel.row);
    upsert = upsert.map((item) => sel.model.format(item));
    keys = (0, import_cosmokit4.makeArray)(keys || sel.model.primary);
    return await sel._action("upsert", upsert, keys).execute();
  }
  async withTransaction(arg, ...args) {
    if (this[kTransaction])
      throw new Error("nested transactions are not supported");
    const [table, callback] = typeof arg === "string" ? [arg, ...args] : [null, arg, ...args];
    const driver = this.getDriver(table);
    return await driver.withTransaction(async (session) => {
      const database = new Proxy(this, {
        get(target, p, receiver) {
          if (p === kTransaction)
            return true;
          else if (p === "getDriver")
            return () => session;
          else
            return Reflect.get(target, p, receiver);
        }
      });
      await callback(database);
    });
  }
  async stopAll() {
    const drivers = Object.values(this.drivers);
    this.drivers = /* @__PURE__ */ Object.create(null);
    await Promise.all(drivers.map((driver) => driver.stop()));
  }
  async drop(table) {
    await this.getDriver(table).drop(table);
  }
  async dropAll() {
    await Promise.all(Object.values(this.drivers).map((driver) => driver.drop()));
  }
  async stats() {
    await this.prepared();
    const stats = { size: 0, tables: {} };
    await Promise.all(Object.values(this.drivers).map(async (driver) => {
      const { size = 0, tables } = await driver.stats();
      stats.size += size;
      Object.assign(stats.tables, tables);
    }));
    return stats;
  }
};
__name(_Database, "Database");
var Database = _Database;
var _Driver = class _Driver {
  constructor(database) {
    this.database = database;
  }
  model(table) {
    if (typeof table === "string") {
      const model2 = this.database.tables[table];
      if (model2)
        return model2;
      throw new TypeError(`unknown table name "${table}"`);
    }
    if (table instanceof Selection) {
      if (!table.args[0].fields)
        return table.model;
      const model2 = new Model("temp");
      model2.fields = (0, import_cosmokit4.valueMap)(table.args[0].fields, (_, key) => ({
        type: "expr"
      }));
      return model2;
    }
    const model = new Model("temp");
    for (const key in table) {
      const submodel = this.model(table[key]);
      for (const field in submodel.fields) {
        if (submodel.fields[field].deprecated)
          continue;
        model.fields[`${key}.${field}`] = {
          type: "expr",
          expr: { $: [key, field] }
        };
      }
    }
    return model;
  }
  async migrate(name, hooks) {
    const database = Object.create(this.database);
    const model = this.model(name);
    database.migrating = true;
    if (this.database.migrating)
      await database.migrateTasks[name];
    database.migrateTasks[name] = Promise.resolve(database.migrateTasks[name]).then(() => {
      return Promise.all([...model.migrations].map(async ([migrate, keys]) => {
        try {
          if (!hooks.before(keys))
            return;
          await migrate(database);
          hooks.after(keys);
        } catch (reason) {
          hooks.error(reason);
        }
      }));
    }).then(hooks.finalize).catch(hooks.error);
  }
};
__name(_Driver, "Driver");
var Driver = _Driver;

// minato/packages/core/src/error.ts
var _RuntimeError = class _RuntimeError extends Error {
  constructor(code, message) {
    super(message || code.replace("-", " "));
    this.code = code;
  }
  name = "RuntimeError";
  static check(error, code) {
    if (!(error instanceof _RuntimeError))
      return false;
    return !code || error.message === code;
  }
};
__name(_RuntimeError, "RuntimeError");
var RuntimeError = _RuntimeError;

// minato/packages/core/src/query.ts
var import_cosmokit5 = require("cosmokit");
var queryOperators = {
  // logical
  $or: (query, data) => query.reduce((prev, query2) => prev || executeFieldQuery(query2, data), false),
  $and: (query, data) => query.reduce((prev, query2) => prev && executeFieldQuery(query2, data), true),
  $not: (query, data) => !executeFieldQuery(query, data),
  // existence
  $exists: (query, data) => query !== (0, import_cosmokit5.isNullable)(data),
  // comparison
  $eq: (query, data) => data.valueOf() === query.valueOf(),
  $ne: (query, data) => data.valueOf() !== query.valueOf(),
  $gt: (query, data) => data.valueOf() > query.valueOf(),
  $gte: (query, data) => data.valueOf() >= query.valueOf(),
  $lt: (query, data) => data.valueOf() < query.valueOf(),
  $lte: (query, data) => data.valueOf() <= query.valueOf(),
  // membership
  $in: (query, data) => query.includes(data),
  $nin: (query, data) => !query.includes(data),
  // regexp
  $regex: (query, data) => makeRegExp(query).test(data),
  $regexFor: (query, data) => new RegExp(data, "i").test(query),
  // bitwise
  $bitsAllSet: (query, data) => (query & data) === query,
  $bitsAllClear: (query, data) => (query & data) === 0,
  $bitsAnySet: (query, data) => (query & data) !== 0,
  $bitsAnyClear: (query, data) => (query & data) !== query,
  // list
  $el: (query, data) => data.some((item) => executeFieldQuery(query, item)),
  $size: (query, data) => data.length === query
};
function executeFieldQuery(query, data) {
  if (Array.isArray(query)) {
    return query.includes(data);
  } else if (query instanceof RegExp) {
    return query.test(data);
  } else if (isComparable(query)) {
    return data.valueOf() === query.valueOf();
  } else if ((0, import_cosmokit5.isNullable)(query)) {
    return (0, import_cosmokit5.isNullable)(data);
  }
  for (const key in query) {
    if (key in queryOperators) {
      if (!queryOperators[key](query[key], data))
        return false;
    }
  }
  return true;
}
__name(executeFieldQuery, "executeFieldQuery");
function executeQuery(data, query, ref, env = {}) {
  const entries = Object.entries(query);
  return entries.every(([key, value]) => {
    if (key === "$and") {
      return value.reduce((prev, query2) => prev && executeQuery(data, query2, ref, env), true);
    } else if (key === "$or") {
      return value.reduce((prev, query2) => prev || executeQuery(data, query2, ref, env), false);
    } else if (key === "$not") {
      return !executeQuery(data, value, ref, env);
    } else if (key === "$expr") {
      return executeEval({ ...env, [ref]: data, _: data }, value);
    }
    try {
      return executeFieldQuery(value, data[key]);
    } catch {
      return false;
    }
  });
}
__name(executeQuery, "executeQuery");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  $,
  Database,
  Driver,
  Eval,
  Field,
  Model,
  Primary,
  RuntimeError,
  Selection,
  executeEval,
  executeQuery,
  executeSort,
  executeUpdate,
  isComparable,
  isEvalExpr,
  makeRegExp,
  randomId
});
//# sourceMappingURL=index.cjs.map
