import { Intersect, Dict, Extract, MaybeArray, Awaitable } from 'cosmokit';
export type Values<S> = S[keyof S];
export type Keys<O, T = any> = Values<{
    [K in keyof O]: O[K] extends T | undefined ? K : never;
}> & string;
export type Atomic = number | string | boolean | bigint | symbol | Date;
export type Indexable = string | number;
export type Comparable = string | number | boolean | Date;
type FlatWrap<S, T, P extends string> = {
    [K in P]?: S;
} | (S extends Atomic | T ? never : S extends any[] ? never : string extends keyof S ? never : FlatMap<S, T, `${P}.`>);
type FlatMap<S, T = never, P extends string = ''> = Values<{
    [K in keyof S & string as `${P}${K}`]: FlatWrap<S[K], S | T, `${P}${K}`>;
}>;
export type Flatten<S> = Intersect<FlatMap<S>>;
export type Row<S> = {
    [K in keyof S]-?: Row.Cell<NonNullable<S[K]>>;
};
export namespace Row {
    type Cell<T> = Eval.Expr<T, false> & (T extends Comparable ? {} : Row<T>);
    type Computed<S, T> = T | ((row: Row<S>) => T);
}
export function isComparable(value: any): value is Comparable;
export function randomId(): string;
export function makeRegExp(source: string | RegExp): RegExp;
export function isEvalExpr(value: any): value is Eval.Expr;
export type Uneval<U, A extends boolean> = U extends number ? Eval.Term<number, A> : U extends string ? Eval.Term<string, A> : U extends boolean ? Eval.Term<boolean, A> : U extends Date ? Eval.Term<Date, A> : U extends RegExp ? Eval.Term<RegExp, A> : any;
export type Eval<U> = U extends Comparable ? U : U extends Eval.Expr<infer T> ? T : never;
declare const kExpr: unique symbol;
declare const kType: unique symbol;
declare const kAggr: unique symbol;
export namespace Eval {
    interface Expr<T = any, A extends boolean = boolean> {
        [kExpr]: true;
        [kType]?: T;
        [kAggr]?: A;
    }
    type Any<A extends boolean = boolean> = Comparable | Expr<any, A>;
    type Term<T, A extends boolean = boolean> = T | Expr<T, A>;
    type Array<T, A extends boolean = boolean> = Term<T, A>[] | Expr<T[], A>;
    type Unary<S, R> = <T extends S, A extends boolean>(x: Term<T, A>) => Expr<R, A>;
    type Binary<S, R> = <T extends S, A extends boolean>(x: Term<T, A>, y: Term<T, A>) => Expr<R, A>;
    type Multi<S, R> = <T extends S, A extends boolean>(...args: Term<T, A>[]) => Expr<R, A>;
    interface Aggr<S, R> {
        <T extends S>(value: Term<T, false>): Expr<R, true>;
        <T extends S, A extends boolean>(value: Array<T, A>): Expr<R, A>;
    }
    interface Branch<T, A extends boolean> {
        case: Term<boolean, A>;
        then: Term<T, A>;
    }
    interface Static {
        <A extends boolean>(key: string, value: any): Eval.Expr<any, A>;
        if<T extends Comparable, A extends boolean>(cond: Any<A>, vThen: Term<T, A>, vElse: Term<T, A>): Expr<T, A>;
        ifNull<T extends Comparable, A extends boolean>(...args: Term<T, A>[]): Expr<T, A>;
        switch<T, A extends boolean>(branches: Branch<T, A>[], vDefault: Term<T, A>): Expr<T, A>;
        add: Multi<number, number>;
        mul: Multi<number, number>;
        multiply: Multi<number, number>;
        sub: Binary<number, number>;
        subtract: Binary<number, number>;
        div: Binary<number, number>;
        divide: Binary<number, number>;
        mod: Binary<number, number>;
        modulo: Binary<number, number>;
        abs: Unary<number, number>;
        floor: Unary<number, number>;
        ceil: Unary<number, number>;
        round: Unary<number, number>;
        exp: Unary<number, number>;
        log<A extends boolean>(x: Term<number, A>, base?: Term<number, A>): Expr<number, A>;
        pow: Binary<number, number>;
        power: Binary<number, number>;
        random(): Expr<number, false>;
        eq: Multi<Comparable, boolean>;
        ne: Binary<Comparable, boolean>;
        gt: Binary<Comparable, boolean>;
        ge: Binary<Comparable, boolean>;
        gte: Binary<Comparable, boolean>;
        lt: Binary<Comparable, boolean>;
        le: Binary<Comparable, boolean>;
        lte: Binary<Comparable, boolean>;
        in<T extends Comparable, A extends boolean>(x: Term<T, A>, array: Array<T, A>): Expr<boolean, A>;
        nin<T extends Comparable, A extends boolean>(x: Term<T, A>, array: Array<T, A>): Expr<boolean, A>;
        concat: Multi<string, string>;
        regex<A extends boolean>(x: Term<string, A>, y: Term<string, A> | Term<RegExp, A>): Expr<boolean, A>;
        and: Multi<boolean, boolean>;
        or: Multi<boolean, boolean>;
        not: Unary<boolean, boolean>;
        number: Unary<any, number>;
        sum: Aggr<number, number>;
        avg: Aggr<number, number>;
        max: Aggr<number, number> & Aggr<Date, Date>;
        min: Aggr<number, number> & Aggr<Date, Date>;
        count(value: Any<false>): Expr<number, true>;
        length(value: Any<false>): Expr<number, true>;
        size<A extends boolean>(value: (Any | Expr<Any, A>)[] | Expr<Any[], A>): Expr<number, A>;
        length<A extends boolean>(value: any[] | Expr<any[], A>): Expr<number, A>;
        object<T extends Dict<Expr>>(fields: T): Expr<T, false>;
        object<T extends any>(row: Row.Cell<T>): Expr<T, false>;
        array<T>(value: Expr<T, false>): Expr<T[], true>;
    }
}
export const Eval: Eval.Static;
export { Eval as $ };
type MapUneval<S> = {
    [K in keyof S]?: Uneval<S[K], false>;
};
export type Update<T = any> = MapUneval<Flatten<T>>;
export function executeEval(data: any, expr: any): any;
export function executeUpdate(data: any, update: any, ref: string): any;
export type Query<T = any> = Query.Expr<Flatten<T>> | Query.Shorthand<Indexable> | Selection.Callback<T, boolean>;
export namespace Query {
    interface FieldExpr<T = any> {
        $or?: FieldQuery<T>[];
        $and?: FieldQuery<T>[];
        $not?: FieldQuery<T>;
        $exists?: boolean;
        $in?: Extract<T, Indexable, T[]>;
        $nin?: Extract<T, Indexable, T[]>;
        $eq?: Extract<T, Comparable>;
        $ne?: Extract<T, Comparable>;
        $gt?: Extract<T, Comparable>;
        $gte?: Extract<T, Comparable>;
        $lt?: Extract<T, Comparable>;
        $lte?: Extract<T, Comparable>;
        $el?: T extends (infer U)[] ? FieldQuery<U> : never;
        $size?: Extract<T, any[], number>;
        $regex?: Extract<T, string, string | RegExp>;
        $regexFor?: Extract<T, string>;
        $bitsAllClear?: Extract<T, number>;
        $bitsAllSet?: Extract<T, number>;
        $bitsAnyClear?: Extract<T, number>;
        $bitsAnySet?: Extract<T, number>;
    }
    interface LogicalExpr<T = any> {
        $or?: Expr<T>[];
        $and?: Expr<T>[];
        $not?: Expr<T>;
        /** @deprecated use query callback instead */
        $expr?: Eval.Expr<boolean>;
    }
    type Shorthand<T = any> = Extract<T, Comparable> | Extract<T, Indexable, T[]> | Extract<T, string, RegExp>;
    type FieldQuery<T = any> = FieldExpr<T> | Shorthand<T>;
    type Expr<T = any> = LogicalExpr<T> & {
        [K in keyof T]?: null | FieldQuery<T[K]>;
    };
}
export function executeQuery(data: any, query: Query.Expr, ref: string, env?: any): boolean;
export namespace Eval {
    interface Static {
        exec<S, T>(value: Executable<S, T>): Expr<T>;
    }
}
export type Direction = 'asc' | 'desc';
export interface Modifier {
    limit: number;
    offset: number;
    sort: [Eval.Expr, Direction][];
    group?: string[];
    having: Eval.Expr<boolean>;
    fields?: Dict<Eval.Expr>;
    optional: Dict<boolean>;
}
declare namespace Executable {
    type Action = 'get' | 'set' | 'remove' | 'create' | 'upsert' | 'eval';
    interface Payload {
        type: Action;
        table: string | Selection | Dict<Selection.Immutable>;
        ref: string;
        query: Query.Expr;
        args: any[];
    }
}
export interface Executable extends Executable.Payload {
}
declare class Executable<S = any, T = any> {
    readonly row: Row<S>;
    readonly model: Model;
    readonly driver: Driver;
    constructor(driver: Driver, payload: Executable.Payload);
    protected resolveQuery(query?: Query<S>): Query.Expr<S>;
    protected resolveField(field: FieldLike<S>): Eval.Expr;
    protected resolveFields(fields: string | string[] | Dict<FieldLike<S>>): {
        [k: string]: any;
    };
    execute(): Promise<T>;
}
type FieldLike<S = any> = Keys<S> | Selection.Callback<S>;
type FieldType<S, T extends FieldLike<S>> = T extends Keys<S> ? S[T] : T extends Selection.Callback<S> ? Eval<ReturnType<T>> : never;
type FieldMap<S, M extends Dict<FieldLike<S>>> = {
    [K in keyof M]: FieldType<S, M[K]>;
};
export namespace Selection {
    type Callback<S = any, T = any, A extends boolean = boolean> = (row: Row<S>) => Eval.Expr<T, A>;
    interface Immutable extends Executable, Executable.Payload {
        tables: Dict<Model>;
    }
    interface Mutable extends Executable, Executable.Payload {
        tables: Dict<Model>;
        table: string;
    }
}
export interface Selection extends Executable.Payload {
    args: [Modifier];
}
export class Selection<S = any> extends Executable<S, S[]> {
    tables: Dict<Model>;
    constructor(driver: Driver, table: string | Selection | Dict<Selection.Immutable>, query?: Query);
    where(query: Query<S>): this;
    limit(limit: number): this;
    limit(offset: number, limit: number): this;
    offset(offset: number): this;
    orderBy(field: FieldLike<S>, direction?: Direction): this;
    groupBy<K extends Keys<S>>(fields: K | K[], query?: Selection.Callback<S, boolean>): Selection<Pick<S, K>>;
    groupBy<K extends Keys<S>, U extends Dict<FieldLike<S>>>(fields: K | K[], extra?: U, query?: Selection.Callback<S, boolean>): Selection<Pick<S, K> & FieldMap<S, U>>;
    groupBy<K extends Dict<FieldLike<S>>>(fields: K, query?: Selection.Callback<S, boolean>): Selection<FieldMap<S, K>>;
    groupBy<K extends Dict<FieldLike<S>>, U extends Dict<FieldLike<S>>>(fields: K, extra?: U, query?: Selection.Callback<S, boolean>): Selection<FieldMap<S, K & U>>;
    having(query: Selection.Callback<S, boolean>): this;
    project<K extends Keys<S>>(fields: K | K[]): Selection<Pick<S, K>>;
    project<U extends Dict<FieldLike<S>>>(fields: U): Selection<FieldMap<S, U>>;
    _action(type: Executable.Action, ...args: any[]): Executable<any, any>;
    evaluate<T>(callback: Selection.Callback<S, T, true>): Eval.Expr<T, true>;
    evaluate<K extends Keys<S>>(field: K): Eval.Expr<S[K][], boolean>;
    evaluate(): Eval.Expr<S[], boolean>;
    execute<K extends Keys<S> = Keys<S>>(cursor?: Driver.Cursor<K>): Promise<Pick<S, K>[]>;
    execute<T>(callback: Selection.Callback<S, T, true>): Promise<T>;
}
export function executeSort(data: any[], modifier: Modifier, name: string): any[];
export const Primary: unique symbol;
export type Primary = (string | number) & {
    [Primary]: true;
};
export interface Field<T = any> {
    type: Field.Type<T>;
    length?: number;
    nullable?: boolean;
    initial?: T;
    precision?: number;
    scale?: number;
    expr?: Eval.Expr;
    legacy?: string[];
    deprecated?: boolean;
}
export namespace Field {
    export const number: Type[];
    export const string: Type[];
    export const boolean: Type[];
    export const date: Type[];
    export const object: Type[];
    export type Type<T = any> = T extends Primary ? 'primary' : T extends number ? 'integer' | 'unsigned' | 'float' | 'double' | 'decimal' : T extends string ? 'char' | 'string' | 'text' : T extends boolean ? 'boolean' : T extends Date ? 'timestamp' | 'date' | 'time' : T extends unknown[] ? 'list' | 'json' : T extends object ? 'json' : 'expr';
    type Shorthand<S extends string> = S | `${S}(${any})`;
    type MapField<O = any> = {
        [K in keyof O]?: Field<O[K]> | Shorthand<Type<O[K]>> | Selection.Callback<O, O[K]>;
    };
    export type Extension<O = any> = MapField<Flatten<O>>;
    export type Config<O = any> = {
        [K in keyof O]?: Field<O[K]>;
    };
    export function parse(source: string | Field): Field;
}
export namespace Model {
    type Migration = (database: Database) => Promise<void>;
    interface Config<O = {}> {
        callback?: Migration;
        autoInc: boolean;
        primary: MaybeArray<Keys<O>>;
        unique: MaybeArray<Keys<O>>[];
        foreign: {
            [K in keyof O]?: [string, string];
        };
    }
}
export interface Model<S> extends Model.Config<S> {
}
export class Model<S = any> {
    name: string;
    fields: Field.Config<S>;
    migrations: Map<Model.Migration, string[]>;
    constructor(name: string);
    extend(fields: Field.Extension<S>, config?: Partial<Model.Config<S>>): void;
    private checkIndex;
    resolveValue(key: string, value: any): any;
    format(source: object, strict?: boolean, prefix?: string, result?: S): S;
    parse(source: object, strict?: boolean, prefix?: string, result?: S): S;
    create(data?: {}): S;
}
export namespace Driver {
    interface Stats {
        size: number;
        tables: Dict<TableStats>;
    }
    interface TableStats {
        count: number;
        size: number;
    }
    type Cursor<K extends string = never> = K[] | CursorOptions<K>;
    interface CursorOptions<K> {
        limit?: number;
        offset?: number;
        fields?: K[];
        sort?: Dict<Direction>;
    }
    interface WriteResult {
        inserted?: number;
        matched?: number;
        modified?: number;
        removed?: number;
    }
}
type TableLike<S> = Keys<S> | Selection;
type TableType<S, T extends TableLike<S>> = T extends Keys<S> ? S[T] : T extends Selection<infer U> ? U : never;
type TableMap1<S, M extends readonly Keys<S>[]> = Intersect<M extends readonly (infer K extends Keys<S>)[] ? {
    [P in K]: TableType<S, P>;
} : never>;
type TableMap2<S, U extends Dict<TableLike<S>>> = {
    [K in keyof U]: TableType<S, U[K]>;
};
type JoinParameters<S, U extends readonly Keys<S>[]> = U extends readonly [infer K extends Keys<S>, ...infer R] ? [Row<S[K]>, ...JoinParameters<S, Extract<R, readonly Keys<S>[]>>] : [];
type JoinCallback1<S, U extends readonly Keys<S>[]> = (...args: JoinParameters<S, U>) => Eval.Expr<boolean>;
type JoinCallback2<S, U extends Dict<TableLike<S>>> = (args: {
    [K in keyof U]: Row<TableType<S, U[K]>>;
}) => Eval.Expr<boolean>;
export class Database<S = any> {
    tables: {
        [K in Keys<S>]: Model<S[K]>;
    };
    drivers: Record<keyof any, Driver>;
    migrating: boolean;
    private prepareTasks;
    private migrateTasks;
    private stashed;
    refresh(): void;
    prepared(): Promise<void>;
    private getDriver;
    private prepare;
    extend<K extends Keys<S>>(name: K, fields: Field.Extension<S[K]>, config?: Partial<Model.Config<S[K]>>): void;
    migrate<K extends Keys<S>>(name: K, fields: Field.Extension<S[K]>, callback: Model.Migration): void;
    select<T>(table: Selection<T>, query?: Query<T>): Selection<T>;
    select<T extends Keys<S>>(table: T, query?: Query<S[T]>): Selection<S[T]>;
    join<U extends readonly Keys<S>[]>(tables: U, callback?: JoinCallback1<S, U>, optional?: boolean[]): Selection<TableMap1<S, U>>;
    join<U extends Dict<TableLike<S>>>(tables: U, callback?: JoinCallback2<S, U>, optional?: Dict<boolean, Keys<U>>): Selection<TableMap2<S, U>>;
    get<T extends Keys<S>, K extends Keys<S[T]>>(table: T, query: Query<S[T]>, cursor?: Driver.Cursor<K>): Promise<Pick<S[T], K>[]>;
    eval<T extends Keys<S>, U>(table: T, expr: Selection.Callback<S[T], U, true>, query?: Query<S[T]>): Promise<U>;
    set<T extends Keys<S>>(table: T, query: Query<S[T]>, update: Row.Computed<S[T], Update<S[T]>>): Promise<Driver.WriteResult>;
    remove<T extends Keys<S>>(table: T, query: Query<S[T]>): Promise<Driver.WriteResult>;
    create<T extends Keys<S>>(table: T, data: Partial<S[T]>): Promise<S[T]>;
    upsert<T extends Keys<S>>(table: T, upsert: Row.Computed<S[T], Update<S[T]>[]>, keys?: MaybeArray<Keys<Flatten<S[T]>, Indexable>>): Promise<Driver.WriteResult>;
    withTransaction(callback: (database: Database<S>) => Promise<void>): Promise<void>;
    withTransaction<T extends Keys<S>>(table: T, callback: (database: Database<S>) => Promise<void>): Promise<void>;
    stopAll(): Promise<void>;
    drop<T extends Keys<S>>(table: T): Promise<void>;
    dropAll(): Promise<void>;
    stats(): Promise<Driver.Stats>;
}
export namespace Driver {
    type Constructor<T = any> = new (database: Database, config?: T) => Driver;
}
export abstract class Driver {
    database: Database;
    abstract start(): Promise<void>;
    abstract stop(): Promise<void>;
    abstract drop(table?: string): Promise<void>;
    abstract stats(): Promise<Partial<Driver.Stats>>;
    abstract prepare(name: string): Promise<void>;
    abstract get(sel: Selection.Immutable, modifier: Modifier): Promise<any>;
    abstract eval(sel: Selection.Immutable, expr: Eval.Expr): Promise<any>;
    abstract set(sel: Selection.Mutable, data: Update): Promise<Driver.WriteResult>;
    abstract remove(sel: Selection.Mutable): Promise<Driver.WriteResult>;
    abstract create(sel: Selection.Mutable, data: any): Promise<any>;
    abstract upsert(sel: Selection.Mutable, data: any[], keys: string[]): Promise<Driver.WriteResult>;
    abstract withTransaction(callback: (driver: Driver) => Promise<void>): Promise<void>;
    constructor(database: Database);
    model<S = any>(table: string | Selection.Immutable | Dict<string | Selection.Immutable>): Model<S>;
    migrate(name: string, hooks: MigrationHooks): Promise<void>;
}
export interface MigrationHooks {
    before: (keys: string[]) => boolean;
    after: (keys: string[]) => void;
    finalize: () => Awaitable<void>;
    error: (reason: any) => void;
}
export namespace RuntimeError {
    type Code = 'duplicate-entry' | 'unsupported-expression';
}
export class RuntimeError<T extends RuntimeError.Code> extends Error {
    code: T;
    name: string;
    constructor(code: T, message?: string);
    static check<T extends RuntimeError.Code>(error: any, code?: RuntimeError.Code): error is RuntimeError<T>;
}
