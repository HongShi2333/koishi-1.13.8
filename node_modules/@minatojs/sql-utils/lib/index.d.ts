import { Dict } from 'cosmokit';
import { Eval, Field, Model, Modifier, Query, Selection } from 'minato';
export function escapeId(value: string): string;
export function isBracketed(value: string): boolean;
export type QueryOperators = {
    [K in keyof Query.FieldExpr]?: (key: string, value: NonNullable<Query.FieldExpr[K]>) => string;
};
export type ExtractUnary<T> = T extends [infer U] ? U : T;
export type EvalOperators = {
    [K in keyof Eval.Static as `$${K}`]?: (expr: ExtractUnary<Parameters<Eval.Static[K]>>) => string;
} & {
    $: (expr: any) => string;
};
export interface Transformer<S = any, T = any> {
    types: Field.Type<S>[];
    dump: (value: S) => T | null;
    load: (value: T, initial?: S) => S | null;
}
type SQLType = 'raw' | 'json' | 'list' | 'date' | 'time' | 'timestamp';
declare interface State {
    sqlType?: SQLType;
    sqlTypes?: Dict<SQLType>;
    group?: boolean;
    tables?: Dict<Model>;
    refFields?: Dict<string>;
    refTables?: Dict<Model>;
    wrappedSubquery?: boolean;
}
export class Builder {
    protected escapeMap: {};
    protected escapeRegExp?: RegExp;
    protected types: Dict<Transformer>;
    protected createEqualQuery: (key: string, value: any) => string;
    protected queryOperators: QueryOperators;
    protected evalOperators: EvalOperators;
    protected state: State;
    protected $true: string;
    protected $false: string;
    protected modifiedTable?: string;
    private readonly _timezone;
    constructor(tables?: Dict<Model>);
    protected unescapeId(value: string): string;
    protected createNullQuery(key: string, value: boolean): string;
    protected createMemberQuery(key: string, value: any, notStr?: string): string;
    protected createRegExpQuery(key: string, value: string | RegExp): string;
    protected createElementQuery(key: string, value: any): string;
    protected comparator(operator: string): (key: string, value: any) => string;
    protected binary(operator: string): ([left, right]: [any, any]) => string;
    protected logicalAnd(conditions: string[]): string;
    protected logicalOr(conditions: string[]): string;
    protected logicalNot(condition: string): string;
    protected parseSelection(sel: Selection): string;
    protected jsonLength(value: string): string;
    protected jsonContains(obj: string, value: string): string;
    protected jsonUnquote(value: string, pure?: boolean): string;
    protected jsonQuote(value: string, pure?: boolean): string;
    protected createAggr(expr: any, aggr: (value: string) => string, nonaggr?: (value: string) => string): string;
    protected groupObject(fields: any): string;
    protected groupArray(value: string): string;
    protected parseFieldQuery(key: string, query: Query.FieldExpr): string;
    parseQuery(query: Query.Expr): string;
    protected parseEvalExpr(expr: any): any;
    protected transformJsonField(obj: string, path: string): string;
    protected transformKey(key: string, fields: {}, prefix: string, fullKey: string): string;
    protected getRecursive(args: string | string[]): any;
    parseEval(expr: any, unquote?: boolean): string;
    protected saveState(extra?: Partial<State>): () => void;
    suffix(modifier: Modifier): string;
    get(sel: Selection.Immutable, inline?: boolean, group?: boolean, addref?: boolean): any;
    define<S, T>(converter: Transformer<S, T>): void;
    dump(model: Model, obj: any): any;
    load(obj: any): any;
    load(model: Model, obj: any): any;
    escape(value: any, field?: Field): string;
    escapeId(value: string): string;
    escapeKey(value: string): string;
    stringify(value: any, field?: Field): any;
    quote(value: string): string;
}
