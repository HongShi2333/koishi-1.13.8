"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// minato/packages/sqlite/src/index.ts
var src_exports = {};
__export(src_exports, {
  SQLiteDriver: () => SQLiteDriver,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_cosmokit = require("cosmokit");
var import_core = require("@minatojs/core");
var import_sql_utils = require("@minatojs/sql-utils");
var import_fs = require("fs");
var import_sql = __toESM(require("@minatojs/sql.js"));
var import_reggol = __toESM(require("reggol"));
var logger = new import_reggol.default("sqlite");
function getTypeDef({ type }) {
  switch (type) {
    case "primary":
    case "boolean":
    case "integer":
    case "unsigned":
    case "date":
    case "time":
    case "timestamp":
      return `INTEGER`;
    case "float":
    case "double":
    case "decimal":
      return `REAL`;
    case "char":
    case "string":
    case "text":
    case "list":
    case "json":
      return `TEXT`;
  }
}
__name(getTypeDef, "getTypeDef");
var _SQLiteBuilder = class _SQLiteBuilder extends import_sql_utils.Builder {
  escapeMap = {
    "'": "''"
  };
  constructor(tables) {
    super(tables);
    this.evalOperators.$if = (args) => `iif(${args.map((arg) => this.parseEval(arg)).join(", ")})`;
    this.evalOperators.$concat = (args) => `(${args.map((arg) => this.parseEval(arg)).join("||")})`;
    this.evalOperators.$modulo = ([left, right]) => `modulo(${this.parseEval(left)}, ${this.parseEval(right)})`;
    this.evalOperators.$log = ([left, right]) => (0, import_cosmokit.isNullable)(right) ? `log(${this.parseEval(left)})` : `log(${this.parseEval(left)}) / log(${this.parseEval(right)})`;
    this.evalOperators.$length = (expr) => this.createAggr(expr, (value) => `count(${value})`, (value) => {
      if (this.state.sqlType === "json") {
        this.state.sqlType = "raw";
        return `${this.jsonLength(value)}`;
      } else {
        this.state.sqlType = "raw";
        return `iif(${value}, LENGTH(${value}) - LENGTH(REPLACE(${value}, ${this.escape(",")}, ${this.escape("")})) + 1, 0)`;
      }
    });
    this.evalOperators.$number = (arg) => {
      const value = this.parseEval(arg);
      const res = this.state.sqlType === "raw" ? `cast(${this.parseEval(arg)} as double)` : `cast(${value} / 1000 as integer)`;
      this.state.sqlType = "raw";
      return `ifnull(${res}, 0)`;
    };
    this.define({
      types: ["boolean"],
      dump: (value) => +value,
      load: (value) => !!value
    });
    this.define({
      types: ["json"],
      dump: (value) => JSON.stringify(value),
      load: (value, initial) => value ? JSON.parse(value) : initial
    });
    this.define({
      types: ["list"],
      dump: (value) => Array.isArray(value) ? value.join(",") : value,
      load: (value) => value ? value.split(",") : []
    });
    this.define({
      types: ["date", "time", "timestamp"],
      dump: (value) => value === null ? null : +new Date(value),
      load: (value) => value === null ? null : new Date(value)
    });
  }
  escape(value, field) {
    if (value instanceof Date)
      value = +value;
    else if (value instanceof RegExp)
      value = value.source;
    return super.escape(value, field);
  }
  createElementQuery(key, value) {
    var _a;
    if (((_a = this.state.sqlTypes) == null ? void 0 : _a[this.unescapeId(key)]) === "json") {
      return this.jsonContains(key, this.quote(JSON.stringify(value)));
    } else {
      return `(',' || ${key} || ',') LIKE ${this.escape("%," + value + ",%")}`;
    }
  }
  jsonLength(value) {
    return `json_array_length(${value})`;
  }
  jsonContains(obj, value) {
    return `json_array_contains(${obj}, ${value})`;
  }
  jsonUnquote(value, pure = false) {
    return value;
  }
  createAggr(expr, aggr, nonaggr) {
    if (!this.state.group && !nonaggr) {
      const value = this.parseEval(expr, false);
      return `(select ${aggr((0, import_sql_utils.escapeId)("value"))} from json_each(${value}) ${(0, import_core.randomId)()})`;
    } else {
      return super.createAggr(expr, aggr, nonaggr);
    }
  }
  groupArray(value) {
    const res = this.state.sqlType === "json" ? `('[' || group_concat(${value}) || ']')` : `('[' || group_concat(json_quote(${value})) || ']')`;
    this.state.sqlType = "json";
    return `ifnull(${res}, json_array())`;
  }
  transformJsonField(obj, path) {
    this.state.sqlType = "raw";
    return `json_extract(${obj}, '$${path}')`;
  }
};
__name(_SQLiteBuilder, "SQLiteBuilder");
var SQLiteBuilder = _SQLiteBuilder;
var _joinKeys, joinKeys_fn, _exec, exec_fn, _all, all_fn, _get, get_fn, _export, export_fn, _run, run_fn, _update, update_fn, _create, create_fn;
var _SQLiteDriver = class _SQLiteDriver extends import_core.Driver {
  constructor(database, config) {
    super(database);
    this.config = config;
    __privateAdd(this, _joinKeys);
    __privateAdd(this, _exec);
    __privateAdd(this, _all);
    __privateAdd(this, _get);
    __privateAdd(this, _export);
    __privateAdd(this, _run);
    __privateAdd(this, _update);
    __privateAdd(this, _create);
    __publicField(this, "db");
    __publicField(this, "sql");
    __publicField(this, "beforeUnload");
    __publicField(this, "_transactionTask");
    this.sql = new SQLiteBuilder();
  }
  /** synchronize table schema */
  async prepare(table, dropKeys) {
    const columns = __privateMethod(this, _all, all_fn).call(this, `PRAGMA table_info(${(0, import_sql_utils.escapeId)(table)})`);
    const model = this.model(table);
    const columnDefs = [];
    const indexDefs = [];
    const alter = [];
    const mapping = {};
    let shouldMigrate = false;
    for (const key in model.fields) {
      if (model.fields[key].deprecated) {
        if (dropKeys == null ? void 0 : dropKeys.includes(key))
          shouldMigrate = true;
        continue;
      }
      const legacy = [key, ...model.fields[key].legacy || []];
      const column = columns.find(({ name }) => legacy.includes(name));
      const { initial, nullable = true } = model.fields[key];
      const typedef = getTypeDef(model.fields[key]);
      let def = `${(0, import_sql_utils.escapeId)(key)} ${typedef}`;
      if (key === model.primary && model.autoInc) {
        def += " NOT NULL PRIMARY KEY AUTOINCREMENT";
      } else {
        def += (nullable ? " " : " NOT ") + "NULL";
        if (!(0, import_cosmokit.isNullable)(initial)) {
          def += " DEFAULT " + this.sql.escape(this.sql.dump(model, { [key]: initial })[key]);
        }
      }
      columnDefs.push(def);
      if (!column) {
        alter.push("ADD " + def);
      } else {
        mapping[column.name] = key;
        shouldMigrate || (shouldMigrate = column.name !== key || column.type !== typedef);
      }
    }
    if (model.primary && !model.autoInc) {
      indexDefs.push(`PRIMARY KEY (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, (0, import_cosmokit.makeArray)(model.primary))})`);
    }
    if (model.unique) {
      indexDefs.push(...model.unique.map((keys) => `UNIQUE (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, (0, import_cosmokit.makeArray)(keys))})`));
    }
    if (model.foreign) {
      indexDefs.push(...Object.entries(model.foreign).map(([key, value]) => {
        const [table2, key2] = value;
        return `FOREIGN KEY (\`${key}\`) REFERENCES ${(0, import_sql_utils.escapeId)(table2)} (\`${key2}\`)`;
      }));
    }
    if (!columns.length) {
      logger.info("auto creating table %c", table);
      __privateMethod(this, _run, run_fn).call(this, `CREATE TABLE ${(0, import_sql_utils.escapeId)(table)} (${[...columnDefs, ...indexDefs].join(", ")})`);
    } else if (shouldMigrate) {
      for (const { name, type, notnull, pk, dflt_value: value } of columns) {
        if (mapping[name] || (dropKeys == null ? void 0 : dropKeys.includes(name)))
          continue;
        let def = `${(0, import_sql_utils.escapeId)(name)} ${type}`;
        def += (notnull ? " NOT " : " ") + "NULL";
        if (pk)
          def += " PRIMARY KEY";
        if (value !== null)
          def += " DEFAULT " + this.sql.escape(value);
        columnDefs.push(def);
        mapping[name] = name;
      }
      const temp = table + "_temp";
      const fields = Object.keys(mapping).map(import_sql_utils.escapeId).join(", ");
      logger.info("auto migrating table %c", table);
      __privateMethod(this, _run, run_fn).call(this, `CREATE TABLE ${(0, import_sql_utils.escapeId)(temp)} (${[...columnDefs, ...indexDefs].join(", ")})`);
      try {
        __privateMethod(this, _run, run_fn).call(this, `INSERT INTO ${(0, import_sql_utils.escapeId)(temp)} SELECT ${fields} FROM ${(0, import_sql_utils.escapeId)(table)}`);
        __privateMethod(this, _run, run_fn).call(this, `DROP TABLE ${(0, import_sql_utils.escapeId)(table)}`);
      } catch (error) {
        __privateMethod(this, _run, run_fn).call(this, `DROP TABLE ${(0, import_sql_utils.escapeId)(temp)}`);
        throw error;
      }
      __privateMethod(this, _run, run_fn).call(this, `ALTER TABLE ${(0, import_sql_utils.escapeId)(temp)} RENAME TO ${(0, import_sql_utils.escapeId)(table)}`);
    } else if (alter.length) {
      logger.info("auto updating table %c", table);
      for (const def of alter) {
        __privateMethod(this, _run, run_fn).call(this, `ALTER TABLE ${(0, import_sql_utils.escapeId)(table)} ${def}`);
      }
    }
    if (dropKeys)
      return;
    dropKeys = [];
    this.migrate(table, {
      error: logger.warn,
      before: (keys) => keys.every((key) => columns.some(({ name }) => name === key)),
      after: (keys) => dropKeys.push(...keys),
      finalize: () => {
        if (!dropKeys.length)
          return;
        this.prepare(table, dropKeys);
      }
    });
  }
  async start() {
    const isBrowser = process.env.KOISHI_ENV === "browser";
    const sqlite = await (0, import_sql.default)({
      locateFile: (file) => process.env.KOISHI_BASE ? process.env.KOISHI_BASE + "/" + file : isBrowser ? "/modules/@koishijs/plugin-database-sqlite/" + file : require.resolve("@minatojs/sql.js/dist/" + file)
    });
    if (!isBrowser || this.config.path === ":memory:") {
      this.db = new sqlite.Database(this.config.path);
    } else {
      const buffer = await import_fs.promises.readFile(this.config.path).catch(() => null);
      this.db = new sqlite.Database(this.config.path, buffer);
      if (isBrowser) {
        window.addEventListener("beforeunload", this.beforeUnload = () => {
          __privateMethod(this, _export, export_fn).call(this);
        });
      }
    }
    this.db.create_function("regexp", (pattern, str) => +new RegExp(pattern).test(str));
    this.db.create_function("json_array_contains", (array, value) => +JSON.parse(array).includes(JSON.parse(value)));
    this.db.create_function("modulo", (left, right) => left % right);
    this.db.create_function("rand", () => Math.random());
  }
  async stop() {
    var _a;
    await new Promise((resolve) => setTimeout(resolve, 0));
    (_a = this.db) == null ? void 0 : _a.close();
    if (this.beforeUnload) {
      this.beforeUnload();
      window.removeEventListener("beforeunload", this.beforeUnload);
    }
  }
  async drop(table) {
    if (table)
      return __privateMethod(this, _run, run_fn).call(this, `DROP TABLE ${(0, import_sql_utils.escapeId)(table)}`);
    const tables = Object.keys(this.database.tables);
    for (const table2 of tables) {
      __privateMethod(this, _run, run_fn).call(this, `DROP TABLE ${(0, import_sql_utils.escapeId)(table2)}`);
    }
  }
  async stats() {
    const stats = { size: this.db.size(), tables: {} };
    const tableNames = __privateMethod(this, _all, all_fn).call(this, 'SELECT name FROM sqlite_master WHERE type="table" ORDER BY name;');
    const dbstats = __privateMethod(this, _all, all_fn).call(this, 'SELECT name, pgsize as size FROM "dbstat" WHERE aggregate=TRUE;');
    tableNames.forEach((tbl) => {
      stats.tables[tbl.name] = __privateMethod(this, _get, get_fn).call(this, `SELECT COUNT(*) as count FROM ${(0, import_sql_utils.escapeId)(tbl.name)};`);
      stats.tables[tbl.name].size = dbstats.find((o) => o.name === tbl.name).size;
    });
    return stats;
  }
  async remove(sel) {
    const { query, table } = sel;
    const filter = this.sql.parseQuery(query);
    if (filter === "0")
      return {};
    const result = __privateMethod(this, _run, run_fn).call(this, `DELETE FROM ${(0, import_sql_utils.escapeId)(table)} WHERE ${filter}`, [], () => __privateMethod(this, _get, get_fn).call(this, `SELECT changes() AS count`));
    return { matched: result.count, removed: result.count };
  }
  async get(sel) {
    const { model, tables } = sel;
    const builder = new SQLiteBuilder(tables);
    const sql = builder.get(sel);
    if (!sql)
      return [];
    const rows = __privateMethod(this, _all, all_fn).call(this, sql);
    return rows.map((row) => builder.load(model, row));
  }
  async eval(sel, expr) {
    const builder = new SQLiteBuilder(sel.tables);
    const inner = builder.get(sel.table, true, true);
    const output = builder.parseEval(expr, false);
    const { value } = __privateMethod(this, _get, get_fn).call(this, `SELECT ${output} AS value FROM ${inner}`);
    return builder.load(value);
  }
  async set(sel, update) {
    const { model, table, query } = sel;
    const { primary, fields } = model;
    const updateFields = [...new Set(Object.keys(update).map((key) => {
      return Object.keys(fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const primaryFields = (0, import_cosmokit.makeArray)(primary);
    const data = await this.database.get(table, query);
    let modified = 0;
    for (const row of data) {
      modified += __privateMethod(this, _update, update_fn).call(this, sel, primaryFields, updateFields, update, row);
    }
    return { matched: data.length, modified };
  }
  async create(sel, data) {
    const { model, table } = sel;
    data = model.create(data);
    const { id } = __privateMethod(this, _create, create_fn).call(this, table, data);
    const { autoInc, primary } = model;
    if (!autoInc || Array.isArray(primary))
      return data;
    return { ...data, [primary]: id };
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return {};
    const { model, table, ref } = sel;
    const result = { inserted: 0, matched: 0, modified: 0 };
    const dataFields = [...new Set(Object.keys(Object.assign({}, ...data)).map((key) => {
      return Object.keys(model.fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    let updateFields = (0, import_cosmokit.difference)(dataFields, keys);
    if (!updateFields.length)
      updateFields = [dataFields[0]];
    const step = Math.floor(960 / keys.length);
    for (let i = 0; i < data.length; i += step) {
      const chunk = data.slice(i, i + step);
      const results = await this.database.get(table, {
        $or: chunk.map((item) => Object.fromEntries(keys.map((key) => [key, item[key]])))
      });
      for (const item of chunk) {
        const row = results.find((row2) => keys.every((key) => (0, import_cosmokit.deepEqual)(row2[key], item[key], true)));
        if (row) {
          result.modified += __privateMethod(this, _update, update_fn).call(this, sel, keys, updateFields, item, row);
          result.matched++;
        } else {
          __privateMethod(this, _create, create_fn).call(this, table, (0, import_core.executeUpdate)(model.create(), item, ref));
          result.inserted++;
        }
      }
    }
    return result;
  }
  async withTransaction(callback) {
    if (this._transactionTask)
      await this._transactionTask;
    return this._transactionTask = new Promise((resolve, reject) => {
      __privateMethod(this, _run, run_fn).call(this, "BEGIN TRANSACTION");
      callback(this).then(() => resolve(__privateMethod(this, _run, run_fn).call(this, "COMMIT")), (e) => (__privateMethod(this, _run, run_fn).call(this, "ROLLBACK"), reject(e)));
    });
  }
};
_joinKeys = new WeakSet();
joinKeys_fn = /* @__PURE__ */ __name(function(keys) {
  return (keys == null ? void 0 : keys.length) ? keys.map((key) => `\`${key}\``).join(", ") : "*";
}, "#joinKeys");
_exec = new WeakSet();
exec_fn = /* @__PURE__ */ __name(function(sql, params, callback) {
  try {
    const stmt = this.db.prepare(sql);
    const result = callback(stmt);
    stmt.free();
    logger.debug("> %s", sql, params);
    return result;
  } catch (e) {
    logger.warn("> %s", sql, params);
    throw e;
  }
}, "#exec");
_all = new WeakSet();
all_fn = /* @__PURE__ */ __name(function(sql, params = []) {
  return __privateMethod(this, _exec, exec_fn).call(this, sql, params, (stmt) => {
    stmt.bind(params);
    const result = [];
    while (stmt.step()) {
      result.push(stmt.getAsObject());
    }
    return result;
  });
}, "#all");
_get = new WeakSet();
get_fn = /* @__PURE__ */ __name(function(sql, params = []) {
  return __privateMethod(this, _exec, exec_fn).call(this, sql, params, (stmt) => stmt.getAsObject(params));
}, "#get");
_export = new WeakSet();
export_fn = /* @__PURE__ */ __name(function() {
  const data = this.db.export();
  import_fs.promises.writeFile(this.config.path, data);
}, "#export");
_run = new WeakSet();
run_fn = /* @__PURE__ */ __name(function(sql, params = [], callback) {
  __privateMethod(this, _exec, exec_fn).call(this, sql, params, (stmt) => stmt.run(params));
  const result = callback == null ? void 0 : callback();
  return result;
}, "#run");
_update = new WeakSet();
update_fn = /* @__PURE__ */ __name(function(sel, indexFields, updateFields, update, data) {
  const { ref, table } = sel;
  const model = this.model(table);
  const modified = !(0, import_cosmokit.deepEqual)((0, import_cosmokit.clone)(data), (0, import_core.executeUpdate)(data, update, ref));
  if (!modified)
    return 0;
  const row = this.sql.dump(model, data);
  const assignment = updateFields.map((key) => `${(0, import_sql_utils.escapeId)(key)} = ?`).join(",");
  const query = Object.fromEntries(indexFields.map((key) => [key, row[key]]));
  const filter = this.sql.parseQuery(query);
  __privateMethod(this, _run, run_fn).call(this, `UPDATE ${(0, import_sql_utils.escapeId)(table)} SET ${assignment} WHERE ${filter}`, updateFields.map((key) => {
    var _a;
    return (_a = row[key]) != null ? _a : null;
  }));
  return 1;
}, "#update");
_create = new WeakSet();
create_fn = /* @__PURE__ */ __name(function(table, data) {
  const model = this.model(table);
  data = this.sql.dump(model, data);
  const keys = Object.keys(data);
  const sql = `INSERT INTO ${(0, import_sql_utils.escapeId)(table)} (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, keys)}) VALUES (${Array(keys.length).fill("?").join(", ")})`;
  return __privateMethod(this, _run, run_fn).call(this, sql, keys.map((key) => {
    var _a;
    return (_a = data[key]) != null ? _a : null;
  }), () => __privateMethod(this, _get, get_fn).call(this, `SELECT last_insert_rowid() AS id`));
}, "#create");
__name(_SQLiteDriver, "SQLiteDriver");
var SQLiteDriver = _SQLiteDriver;
var src_default = SQLiteDriver;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SQLiteDriver
});
//# sourceMappingURL=index.js.map
