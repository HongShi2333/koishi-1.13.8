var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/index.ts
import { clone, deepEqual, difference, isNullable as isNullable2, makeArray } from "cosmokit";
import { Driver, executeUpdate, z } from "minato";
import { escapeId as escapeId2 } from "@minatojs/sql-utils";
import { resolve } from "node:path";
import { readFile, writeFile } from "node:fs/promises";
import { createRequire } from "node:module";
import init from "@minatojs/sql.js";

// src/locales/en-US.yml
var en_US_default = { path: "Database path." };

// src/locales/zh-CN.yml
var zh_CN_default = { path: "数据库路径。" };

// src/builder.ts
import { Builder, escapeId } from "@minatojs/sql-utils";
import { isNullable } from "cosmokit";
import { randomId } from "minato";
var SQLiteBuilder = class extends Builder {
  static {
    __name(this, "SQLiteBuilder");
  }
  escapeMap = {
    "'": "''"
  };
  constructor(tables) {
    super(tables);
    this.evalOperators.$if = (args) => `iif(${args.map((arg) => this.parseEval(arg)).join(", ")})`;
    this.evalOperators.$concat = (args) => `(${args.map((arg) => this.parseEval(arg)).join("||")})`;
    this.evalOperators.$modulo = ([left, right]) => `modulo(${this.parseEval(left)}, ${this.parseEval(right)})`;
    this.evalOperators.$log = ([left, right]) => isNullable(right) ? `log(${this.parseEval(left)})` : `log(${this.parseEval(left)}) / log(${this.parseEval(right)})`;
    this.evalOperators.$length = (expr) => this.createAggr(expr, (value) => `count(${value})`, (value) => {
      if (this.state.sqlType === "json") {
        this.state.sqlType = "raw";
        return `${this.jsonLength(value)}`;
      } else {
        this.state.sqlType = "raw";
        return `iif(${value}, LENGTH(${value}) - LENGTH(REPLACE(${value}, ${this.escape(",")}, ${this.escape("")})) + 1, 0)`;
      }
    });
    this.evalOperators.$number = (arg) => {
      const value = this.parseEval(arg);
      const res = this.state.sqlType === "raw" ? `cast(${this.parseEval(arg)} as double)` : `cast(${value} / 1000 as integer)`;
      this.state.sqlType = "raw";
      return `ifnull(${res}, 0)`;
    };
    this.define({
      types: ["boolean"],
      dump: (value) => +value,
      load: (value) => !!value
    });
    this.define({
      types: ["json"],
      dump: (value) => JSON.stringify(value),
      load: (value, initial) => value ? JSON.parse(value) : initial
    });
    this.define({
      types: ["list"],
      dump: (value) => Array.isArray(value) ? value.join(",") : value,
      load: (value) => value ? value.split(",") : []
    });
    this.define({
      types: ["date", "time", "timestamp"],
      dump: (value) => value === null ? null : +new Date(value),
      load: (value) => value === null ? null : new Date(value)
    });
  }
  escape(value, field) {
    if (value instanceof Date)
      value = +value;
    else if (value instanceof RegExp)
      value = value.source;
    return super.escape(value, field);
  }
  createElementQuery(key, value) {
    if (this.state.sqlTypes?.[this.unescapeId(key)] === "json") {
      return this.jsonContains(key, this.quote(JSON.stringify(value)));
    } else {
      return `(',' || ${key} || ',') LIKE ${this.escape("%," + value + ",%")}`;
    }
  }
  jsonLength(value) {
    return `json_array_length(${value})`;
  }
  jsonContains(obj, value) {
    return `json_array_contains(${obj}, ${value})`;
  }
  jsonUnquote(value, pure = false) {
    return value;
  }
  createAggr(expr, aggr, nonaggr) {
    if (!this.state.group && !nonaggr) {
      const value = this.parseEval(expr, false);
      return `(select ${aggr(escapeId("value"))} from json_each(${value}) ${randomId()})`;
    } else {
      return super.createAggr(expr, aggr, nonaggr);
    }
  }
  groupArray(value) {
    const res = this.state.sqlType === "json" ? `('[' || group_concat(${value}) || ']')` : `('[' || group_concat(json_quote(${value})) || ']')`;
    this.state.sqlType = "json";
    return `ifnull(${res}, json_array())`;
  }
  transformJsonField(obj, path) {
    this.state.sqlType = "raw";
    return `json_extract(${obj}, '$${path}')`;
  }
};

// src/index.ts
import { pathToFileURL } from "node:url";
function getTypeDef({ type }) {
  switch (type) {
    case "primary":
    case "boolean":
    case "integer":
    case "unsigned":
    case "date":
    case "time":
    case "timestamp":
      return `INTEGER`;
    case "float":
    case "double":
    case "decimal":
      return `REAL`;
    case "char":
    case "string":
    case "text":
    case "list":
    case "json":
      return `TEXT`;
  }
}
__name(getTypeDef, "getTypeDef");
var SQLiteDriver = class extends Driver {
  static name = "sqlite";
  db;
  sql = new SQLiteBuilder();
  beforeUnload;
  _transactionTask;
  /** synchronize table schema */
  async prepare(table, dropKeys) {
    const columns = this.#all(`PRAGMA table_info(${escapeId2(table)})`);
    const model = this.model(table);
    const columnDefs = [];
    const indexDefs = [];
    const alter = [];
    const mapping = {};
    let shouldMigrate = false;
    for (const key in model.fields) {
      if (model.fields[key].deprecated) {
        if (dropKeys?.includes(key))
          shouldMigrate = true;
        continue;
      }
      const legacy = [key, ...model.fields[key].legacy || []];
      const column = columns.find(({ name }) => legacy.includes(name));
      const { initial, nullable = true } = model.fields[key];
      const typedef = getTypeDef(model.fields[key]);
      let def = `${escapeId2(key)} ${typedef}`;
      if (key === model.primary && model.autoInc) {
        def += " NOT NULL PRIMARY KEY AUTOINCREMENT";
      } else {
        def += (nullable ? " " : " NOT ") + "NULL";
        if (!isNullable2(initial)) {
          def += " DEFAULT " + this.sql.escape(this.sql.dump(model, { [key]: initial })[key]);
        }
      }
      columnDefs.push(def);
      if (!column) {
        alter.push("ADD " + def);
      } else {
        mapping[column.name] = key;
        shouldMigrate ||= column.name !== key || column.type !== typedef;
      }
    }
    if (model.primary && !model.autoInc) {
      indexDefs.push(`PRIMARY KEY (${this.#joinKeys(makeArray(model.primary))})`);
    }
    if (model.unique) {
      indexDefs.push(...model.unique.map((keys) => `UNIQUE (${this.#joinKeys(makeArray(keys))})`));
    }
    if (model.foreign) {
      indexDefs.push(...Object.entries(model.foreign).map(([key, value]) => {
        const [table2, key2] = value;
        return `FOREIGN KEY (\`${key}\`) REFERENCES ${escapeId2(table2)} (\`${key2}\`)`;
      }));
    }
    if (!columns.length) {
      this.logger.info("auto creating table %c", table);
      this.#run(`CREATE TABLE ${escapeId2(table)} (${[...columnDefs, ...indexDefs].join(", ")})`);
    } else if (shouldMigrate) {
      for (const { name, type, notnull, pk, dflt_value: value } of columns) {
        if (mapping[name] || dropKeys?.includes(name))
          continue;
        let def = `${escapeId2(name)} ${type}`;
        def += (notnull ? " NOT " : " ") + "NULL";
        if (pk)
          def += " PRIMARY KEY";
        if (value !== null)
          def += " DEFAULT " + this.sql.escape(value);
        columnDefs.push(def);
        mapping[name] = name;
      }
      const temp = table + "_temp";
      const fields = Object.keys(mapping).map(escapeId2).join(", ");
      this.logger.info("auto migrating table %c", table);
      this.#run(`CREATE TABLE ${escapeId2(temp)} (${[...columnDefs, ...indexDefs].join(", ")})`);
      try {
        this.#run(`INSERT INTO ${escapeId2(temp)} SELECT ${fields} FROM ${escapeId2(table)}`);
        this.#run(`DROP TABLE ${escapeId2(table)}`);
      } catch (error) {
        this.#run(`DROP TABLE ${escapeId2(temp)}`);
        throw error;
      }
      this.#run(`ALTER TABLE ${escapeId2(temp)} RENAME TO ${escapeId2(table)}`);
    } else if (alter.length) {
      this.logger.info("auto updating table %c", table);
      for (const def of alter) {
        this.#run(`ALTER TABLE ${escapeId2(table)} ${def}`);
      }
    }
    if (dropKeys)
      return;
    dropKeys = [];
    this.migrate(table, {
      error: this.logger.warn,
      before: (keys) => keys.every((key) => columns.some(({ name }) => name === key)),
      after: (keys) => dropKeys.push(...keys),
      finalize: () => {
        if (!dropKeys.length)
          return;
        this.prepare(table, dropKeys);
      }
    });
  }
  async start() {
    if (this.config.path !== ":memory:") {
      this.config.path = resolve(this.ctx.baseDir, this.config.path);
    }
    const isBrowser = process.env.KOISHI_ENV === "browser";
    const sqlite = await init({
      locateFile: (file) => process.env.KOISHI_BASE ? process.env.KOISHI_BASE + "/" + file : isBrowser ? "/modules/@koishijs/plugin-database-sqlite/" + file : createRequire(import.meta.url || pathToFileURL(__filename).href).resolve("@minatojs/sql.js/dist/" + file)
    });
    if (!isBrowser || this.config.path === ":memory:") {
      this.db = new sqlite.Database(this.config.path);
    } else {
      const buffer = await readFile(this.config.path).catch(() => null);
      this.db = new sqlite.Database(this.config.path, buffer);
      if (isBrowser) {
        window.addEventListener("beforeunload", this.beforeUnload = () => {
          this.#export();
        });
      }
    }
    this.db.create_function("regexp", (pattern, str) => +new RegExp(pattern).test(str));
    this.db.create_function("json_array_contains", (array, value) => +JSON.parse(array).includes(JSON.parse(value)));
    this.db.create_function("modulo", (left, right) => left % right);
    this.db.create_function("rand", () => Math.random());
  }
  #joinKeys(keys) {
    return keys?.length ? keys.map((key) => `\`${key}\``).join(", ") : "*";
  }
  async stop() {
    await new Promise((resolve2) => setTimeout(resolve2, 0));
    this.db?.close();
    if (this.beforeUnload) {
      this.beforeUnload();
      window.removeEventListener("beforeunload", this.beforeUnload);
    }
  }
  #exec(sql, params, callback) {
    try {
      const stmt = this.db.prepare(sql);
      const result = callback(stmt);
      stmt.free();
      this.logger.debug("> %s", sql, params);
      return result;
    } catch (e) {
      this.logger.warn("> %s", sql, params);
      throw e;
    }
  }
  #all(sql, params = []) {
    return this.#exec(sql, params, (stmt) => {
      stmt.bind(params);
      const result = [];
      while (stmt.step()) {
        result.push(stmt.getAsObject());
      }
      return result;
    });
  }
  #get(sql, params = []) {
    return this.#exec(sql, params, (stmt) => stmt.getAsObject(params));
  }
  #export() {
    const data = this.db.export();
    return writeFile(this.config.path, data);
  }
  #run(sql, params = [], callback) {
    this.#exec(sql, params, (stmt) => stmt.run(params));
    const result = callback?.();
    return result;
  }
  async drop(table) {
    this.#run(`DROP TABLE ${escapeId2(table)}`);
  }
  async dropAll() {
    const tables = Object.keys(this.database.tables);
    for (const table of tables) {
      this.#run(`DROP TABLE ${escapeId2(table)}`);
    }
  }
  async stats() {
    const stats = { size: this.db.size(), tables: {} };
    const tableNames = this.#all('SELECT name FROM sqlite_master WHERE type="table" ORDER BY name;');
    const dbstats = this.#all('SELECT name, pgsize as size FROM "dbstat" WHERE aggregate=TRUE;');
    tableNames.forEach((tbl) => {
      stats.tables[tbl.name] = this.#get(`SELECT COUNT(*) as count FROM ${escapeId2(tbl.name)};`);
      stats.tables[tbl.name].size = dbstats.find((o) => o.name === tbl.name).size;
    });
    return stats;
  }
  async remove(sel) {
    const { query, table } = sel;
    const filter = this.sql.parseQuery(query);
    if (filter === "0")
      return {};
    const result = this.#run(`DELETE FROM ${escapeId2(table)} WHERE ${filter}`, [], () => this.#get(`SELECT changes() AS count`));
    return { matched: result.count, removed: result.count };
  }
  async get(sel) {
    const { model, tables } = sel;
    const builder = new SQLiteBuilder(tables);
    const sql = builder.get(sel);
    if (!sql)
      return [];
    const rows = this.#all(sql);
    return rows.map((row) => builder.load(model, row));
  }
  async eval(sel, expr) {
    const builder = new SQLiteBuilder(sel.tables);
    const inner = builder.get(sel.table, true, true);
    const output = builder.parseEval(expr, false);
    const { value } = this.#get(`SELECT ${output} AS value FROM ${inner}`);
    return builder.load(value);
  }
  #update(sel, indexFields, updateFields, update, data) {
    const { ref, table } = sel;
    const model = this.model(table);
    const modified = !deepEqual(clone(data), executeUpdate(data, update, ref));
    if (!modified)
      return 0;
    const row = this.sql.dump(model, data);
    const assignment = updateFields.map((key) => `${escapeId2(key)} = ?`).join(",");
    const query = Object.fromEntries(indexFields.map((key) => [key, row[key]]));
    const filter = this.sql.parseQuery(query);
    this.#run(`UPDATE ${escapeId2(table)} SET ${assignment} WHERE ${filter}`, updateFields.map((key) => row[key] ?? null));
    return 1;
  }
  async set(sel, update) {
    const { model, table, query } = sel;
    const { primary, fields } = model;
    const updateFields = [...new Set(Object.keys(update).map((key) => {
      return Object.keys(fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const primaryFields = makeArray(primary);
    const data = await this.database.get(table, query);
    let modified = 0;
    for (const row of data) {
      modified += this.#update(sel, primaryFields, updateFields, update, row);
    }
    return { matched: data.length, modified };
  }
  #create(table, data) {
    const model = this.model(table);
    data = this.sql.dump(model, data);
    const keys = Object.keys(data);
    const sql = `INSERT INTO ${escapeId2(table)} (${this.#joinKeys(keys)}) VALUES (${Array(keys.length).fill("?").join(", ")})`;
    return this.#run(sql, keys.map((key) => data[key] ?? null), () => this.#get(`SELECT last_insert_rowid() AS id`));
  }
  async create(sel, data) {
    const { model, table } = sel;
    data = model.create(data);
    const { id } = this.#create(table, data);
    const { autoInc, primary } = model;
    if (!autoInc || Array.isArray(primary))
      return data;
    return { ...data, [primary]: id };
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return {};
    const { model, table, ref } = sel;
    const result = { inserted: 0, matched: 0, modified: 0 };
    const dataFields = [...new Set(Object.keys(Object.assign({}, ...data)).map((key) => {
      return Object.keys(model.fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    let updateFields = difference(dataFields, keys);
    if (!updateFields.length)
      updateFields = [dataFields[0]];
    const step = Math.floor(960 / keys.length);
    for (let i = 0; i < data.length; i += step) {
      const chunk = data.slice(i, i + step);
      const results = await this.database.get(table, {
        $or: chunk.map((item) => Object.fromEntries(keys.map((key) => [key, item[key]])))
      });
      for (const item of chunk) {
        const row = results.find((row2) => keys.every((key) => deepEqual(row2[key], item[key], true)));
        if (row) {
          result.modified += this.#update(sel, keys, updateFields, item, row);
          result.matched++;
        } else {
          this.#create(table, executeUpdate(model.create(), item, ref));
          result.inserted++;
        }
      }
    }
    return result;
  }
  async withTransaction(callback) {
    if (this._transactionTask)
      await this._transactionTask;
    return this._transactionTask = new Promise((resolve2, reject) => {
      this.#run("BEGIN TRANSACTION");
      callback(this).then(() => resolve2(this.#run("COMMIT")), (e) => (this.#run("ROLLBACK"), reject(e)));
    });
  }
};
((SQLiteDriver2) => {
  SQLiteDriver2.Config = z.object({
    path: z.string().role("path").required()
  }).i18n({
    "en-US": en_US_default,
    "zh-CN": zh_CN_default
  });
})(SQLiteDriver || (SQLiteDriver = {}));
var src_default = SQLiteDriver;
export {
  SQLiteDriver,
  src_default as default
};
//# sourceMappingURL=index.mjs.map
