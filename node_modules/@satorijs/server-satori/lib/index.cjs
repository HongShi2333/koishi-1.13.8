"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// satori/packages/server-satori/src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  Webhook: () => Webhook,
  apply: () => apply,
  inject: () => inject,
  name: () => name
});
module.exports = __toCommonJS(src_exports);
var import_satori = require("@satorijs/satori");
var name = "server";
var inject = ["server", "http"];
var kClient = Symbol("state");
var _Client = class _Client {
  authorized = false;
};
__name(_Client, "Client");
var Client = _Client;
var Webhook = import_satori.Schema.object({
  enabled: import_satori.Schema.boolean().default(true),
  endpoint: import_satori.Schema.string(),
  token: import_satori.Schema.string()
});
var Config = import_satori.Schema.object({
  path: import_satori.Schema.string().default("/satori"),
  token: import_satori.Schema.string().experimental(),
  api: import_satori.Schema.object({
    // enabled: Schema.boolean().default(true),
  }),
  websocket: import_satori.Schema.object({
    // enabled: Schema.boolean().default(true),
    resumeTimeout: import_satori.Schema.number().default(import_satori.Time.minute * 5)
  }),
  webhooks: import_satori.Schema.array(Webhook)
});
function transformKey(source, callback) {
  if (!source || typeof source !== "object")
    return source;
  if (Array.isArray(source))
    return source.map((value) => transformKey(value, callback));
  return Object.fromEntries(Object.entries(source).map(([key, value]) => {
    if (key.startsWith("_"))
      return [key, value];
    return [callback(key), transformKey(value, callback)];
  }));
}
__name(transformKey, "transformKey");
function apply(ctx, config) {
  const logger = ctx.logger("server");
  const path = (0, import_satori.sanitize)(config.path);
  ctx.server.get(path + "/v1(/.+)*", async (koa) => {
    koa.body = "Please use POST method to send requests.";
    koa.status = 405;
  });
  ctx.server.post(path + "/v1/:name", async (koa) => {
    const method = import_satori.Universal.Methods[koa.params.name];
    if (!method) {
      koa.body = "method not found";
      return koa.status = 404;
    }
    if (config.token) {
      if (koa.request.headers.authorization !== `Bearer ${config.token}`) {
        koa.body = "invalid token";
        return koa.status = 403;
      }
    }
    const json = koa.request.body;
    const selfId = koa.request.headers["x-self-id"];
    const platform = koa.request.headers["x-platform"];
    const bot = ctx.bots.find((bot2) => bot2.selfId === selfId && bot2.platform === platform);
    if (!bot) {
      koa.body = "bot not found";
      return koa.status = 403;
    }
    const args = method.fields.map(({ name: name2 }) => {
      return transformKey(json[name2], import_satori.camelCase);
    });
    const result = await bot[method.name](...args);
    koa.body = transformKey(result, import_satori.snakeCase);
    koa.status = 200;
  });
  ctx.server.post(path + "/v1/internal/:name", async (koa) => {
    var _a;
    const selfId = koa.request.headers["X-Self-ID"];
    const platform = koa.request.headers["X-Platform"];
    const bot = ctx.bots.find((bot2) => bot2.selfId === selfId && bot2.platform === platform);
    if (!bot) {
      koa.body = "bot not found";
      return koa.status = 403;
    }
    const name2 = (0, import_satori.camelCase)(koa.params.name);
    if (!((_a = bot.internal) == null ? void 0 : _a[name2])) {
      koa.body = "method not found";
      return koa.status = 404;
    }
    const result = await bot.internal[name2](...koa.request.body);
    koa.body = result;
    koa.status = 200;
  });
  const buffer = [];
  const timeout = setInterval(() => {
    var _a, _b;
    while (((_a = buffer[0]) == null ? void 0 : _a.timestamp) + ((_b = config.websocket) == null ? void 0 : _b.resumeTimeout) < Date.now()) {
      buffer.shift();
    }
  }, import_satori.Time.second * 10);
  ctx.on("dispose", () => clearInterval(timeout));
  const layer = ctx.server.ws(path + "/v1/events", (socket) => {
    const client = socket[kClient] = new Client();
    socket.addEventListener("message", (event) => {
      var _a, _b;
      let payload;
      try {
        payload = JSON.parse(event.data.toString());
      } catch (error) {
        return socket.close(4e3, "invalid message");
      }
      if (payload.op === import_satori.Universal.Opcode.IDENTIFY) {
        if (config.token) {
          if (((_a = payload.body) == null ? void 0 : _a.token) !== config.token) {
            return socket.close(4004, "invalid token");
          }
        }
        client.authorized = true;
        socket.send(JSON.stringify({
          op: import_satori.Universal.Opcode.READY,
          body: {
            logins: transformKey(ctx.bots.map((bot) => bot.toJSON()), import_satori.snakeCase)
          }
        }));
        if (!((_b = payload.body) == null ? void 0 : _b.sequence))
          return;
        for (const session of buffer) {
          if (session.id <= payload.body.sequence)
            continue;
          dispatch(socket, transformKey(session.toJSON(), import_satori.snakeCase));
        }
      } else if (payload.op === import_satori.Universal.Opcode.PING) {
        socket.send(JSON.stringify({
          op: import_satori.Universal.Opcode.PONG,
          body: {}
        }));
      }
    });
  });
  function dispatch(socket, body) {
    socket.send(JSON.stringify({
      op: import_satori.Universal.Opcode.EVENT,
      body
    }));
  }
  __name(dispatch, "dispatch");
  ctx.on("internal/session", (session) => {
    var _a;
    const body = transformKey(session.toJSON(), import_satori.snakeCase);
    for (const socket of layer.clients) {
      if (!((_a = socket[kClient]) == null ? void 0 : _a.authorized))
        continue;
      dispatch(socket, body);
    }
    for (const webhook of config.webhooks) {
      if (!webhook.enabled)
        continue;
      ctx.http.post(webhook.endpoint, body, {
        headers: webhook.token ? {
          Authorization: `Bearer ${webhook.token}`
        } : {}
      }).catch(logger.warn);
    }
  });
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  Webhook,
  apply,
  inject,
  name
});
//# sourceMappingURL=index.cjs.map
