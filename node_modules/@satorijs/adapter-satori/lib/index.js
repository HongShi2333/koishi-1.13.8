var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// satori/adapters/satori/src/index.ts
var src_exports = {};
__export(src_exports, {
  SatoriAdapter: () => SatoriAdapter,
  SatoriBot: () => SatoriBot,
  default: () => src_default,
  transformKey: () => transformKey
});
module.exports = __toCommonJS(src_exports);

// satori/adapters/satori/src/ws.ts
var import_satori2 = require("@satorijs/satori");

// satori/adapters/satori/src/bot.ts
var import_satori = require("@satorijs/satori");
function transformKey(source, callback) {
  if (!source || typeof source !== "object")
    return source;
  if (Array.isArray(source))
    return source.map((value) => transformKey(value, callback));
  return Object.fromEntries(Object.entries(source).map(([key, value]) => {
    if (key.startsWith("_"))
      return [key, value];
    return [callback(key), transformKey(value, callback)];
  }));
}
__name(transformKey, "transformKey");
function createInternal(bot, prefix = "") {
  return new Proxy(() => {
  }, {
    apply(target, thisArg, args) {
      return bot.http.post("/internal/" + (0, import_satori.snakeCase)(prefix.slice(1)), args);
    },
    get(target, key, receiver) {
      if (typeof key === "symbol" || key in target) {
        return Reflect.get(target, key, receiver);
      }
      return createInternal(bot, prefix + "." + key);
    }
  });
}
__name(createInternal, "createInternal");
var _SatoriBot = class _SatoriBot extends import_satori.Bot {
  http;
  internal = createInternal(this);
  constructor(ctx, config) {
    super(ctx, config, "satori");
    Object.assign(this, config);
  }
};
__name(_SatoriBot, "SatoriBot");
var SatoriBot = _SatoriBot;
for (const [key, method] of Object.entries(import_satori.Universal.Methods)) {
  SatoriBot.prototype[method.name] = function(...args) {
    const payload = {};
    for (const { name } of method.fields) {
      if (name === "content") {
        payload[name] = import_satori.h.normalize(args.shift()).join("");
      } else {
        payload[name] = transformKey(args.shift(), import_satori.snakeCase);
      }
    }
    this.logger.debug("[request]", key, payload);
    return this.http.post("/v1/" + key, payload);
  };
}

// satori/adapters/satori/src/ws.ts
var _SatoriAdapter = class _SatoriAdapter extends import_satori2.Adapter.WsClientBase {
  constructor(ctx, config) {
    super(ctx, config);
    this.ctx = ctx;
    this.config = config;
    this.logger = ctx.logger("satori");
    this.http = ctx.http.extend({
      endpoint: config.endpoint,
      headers: {
        "Authorization": `Bearer ${config.token}`
      }
    });
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => this.stop());
  }
  http;
  logger;
  _status = import_satori2.Universal.Status.OFFLINE;
  sequence;
  timeout;
  getActive() {
    return this._status !== import_satori2.Universal.Status.OFFLINE && this._status !== import_satori2.Universal.Status.DISCONNECT;
  }
  setStatus(status, error) {
    this._status = status;
    if (status === import_satori2.Universal.Status.ONLINE)
      return;
    for (const bot of this.bots) {
      bot.status = status;
      bot.error = error;
    }
  }
  async prepare() {
    return this.http.ws("/v1/events");
  }
  getBot(platform, selfId, login) {
    let bot = this.bots.find((bot2) => bot2.selfId === selfId && bot2.platform === platform);
    if (bot) {
      bot.update(login);
      return this.bots.includes(bot) ? bot : void 0;
    }
    if (!login) {
      this.logger.error("cannot find bot for", platform, selfId);
      return;
    }
    bot = new SatoriBot(this.ctx, login);
    bot.adapter = this;
    bot.http = this.http;
    this.bots.push(bot);
  }
  accept() {
    this.socket.send(JSON.stringify({
      op: import_satori2.Universal.Opcode.IDENTIFY,
      body: {
        token: this.config.token,
        sequence: this.sequence
      }
    }));
    this.timeout = setInterval(() => {
      this.socket.send(JSON.stringify({
        op: import_satori2.Universal.Opcode.PING,
        body: {}
      }));
    }, import_satori2.Time.second * 10);
    this.socket.addEventListener("message", async ({ data }) => {
      var _a;
      let parsed;
      try {
        parsed = transformKey(JSON.parse(data.toString()), import_satori2.camelize);
      } catch (error) {
        return this.logger.warn("cannot parse message", data);
      }
      if (parsed.op === import_satori2.Universal.Opcode.READY) {
        this.logger.debug("ready");
        for (const login of parsed.body.logins) {
          this.getBot(login.platform, login.selfId, login);
        }
      }
      if (parsed.op === import_satori2.Universal.Opcode.EVENT) {
        const { id, type, selfId, platform, login } = parsed.body;
        this.sequence = id;
        const bot = this.getBot(platform, selfId, type === "login-added" && login);
        if (!bot)
          return;
        if (type === "login-updated") {
          return bot.update(login);
        } else if (type === "login-removed") {
          return bot.dispose();
        }
        const session = bot.session(parsed.body);
        if ((_a = parsed.body.message) == null ? void 0 : _a.content) {
          session.content = parsed.body.message.content;
        }
        if (parsed.body._type && parsed.body.type !== "internal") {
          session.setInternal(parsed.body._type, parsed.body._data);
        }
        bot.dispatch(session);
      }
    });
    this.socket.addEventListener("close", () => {
      clearInterval(this.timeout);
    });
  }
  async start() {
    this.setStatus(import_satori2.Universal.Status.CONNECT);
    await super.start();
  }
  async stop() {
    this.setStatus(import_satori2.Universal.Status.DISCONNECT);
    await super.stop();
  }
};
__name(_SatoriAdapter, "SatoriAdapter");
__publicField(_SatoriAdapter, "schema", true);
__publicField(_SatoriAdapter, "reusable", true);
__publicField(_SatoriAdapter, "inject", ["http"]);
var SatoriAdapter = _SatoriAdapter;
((SatoriAdapter2) => {
  SatoriAdapter2.Config = import_satori2.Schema.intersect([
    import_satori2.Schema.object({
      endpoint: import_satori2.Schema.string().description("API 终结点。").required(),
      token: import_satori2.Schema.string().description("API 访问令牌。")
    }),
    import_satori2.Adapter.WsClientConfig
  ]);
})(SatoriAdapter || (SatoriAdapter = {}));

// satori/adapters/satori/src/index.ts
var src_default = SatoriAdapter;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SatoriAdapter,
  SatoriBot,
  transformKey
});
//# sourceMappingURL=index.js.map
