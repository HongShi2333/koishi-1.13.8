var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// satori/packages/core/src/index.ts
var src_exports = {};
__export(src_exports, {
  Adapter: () => Adapter,
  Bot: () => Bot,
  Context: () => Context,
  Element: () => import_element3.default,
  Logger: () => import_logger.Logger,
  MessageEncoder: () => MessageEncoder,
  Messenger: () => MessageEncoder,
  Modulator: () => MessageEncoder,
  Quester: () => import_cordis_axios.Quester,
  Satori: () => Satori,
  Schema: () => import_schemastery2.default,
  Service: () => Service2,
  Session: () => Session,
  Universal: () => Universal,
  defineAccessor: () => defineAccessor,
  h: () => import_element3.default,
  segment: () => import_element3.default,
  z: () => import_schemastery2.default
});
module.exports = __toCommonJS(src_exports);
var cordis = __toESM(require("cordis"), 1);
var import_cosmokit4 = require("cosmokit");

// satori/packages/core/src/session.ts
var import_cosmokit = require("cosmokit");
var import_protocol = require("@satorijs/protocol");
var import_element = __toESM(require("@satorijs/element"), 1);
var _Session = class _Session {
  id;
  bot;
  app;
  event;
  locales = [];
  constructor(bot, event) {
    var _a, _b, _c;
    (_a = event.selfId) != null ? _a : event.selfId = bot.selfId;
    (_b = event.platform) != null ? _b : event.platform = bot.platform;
    (_c = event.timestamp) != null ? _c : event.timestamp = Date.now();
    this.event = event;
    this.id = ++_Session.counter;
    (0, import_cosmokit.defineProperty)(this, "bot", bot);
    (0, import_cosmokit.defineProperty)(this, "app", bot.ctx.root);
    (0, import_cosmokit.defineProperty)(this, Context.current, bot.ctx);
    return Context.associate(this, "session");
  }
  /** @deprecated */
  get data() {
    return this.event;
  }
  get isDirect() {
    return this.event.channel.type === import_protocol.Channel.Type.DIRECT;
  }
  set isDirect(value) {
    var _a, _b;
    ((_b = (_a = this.event).channel) != null ? _b : _a.channel = {}).type = value ? import_protocol.Channel.Type.DIRECT : import_protocol.Channel.Type.TEXT;
  }
  get author() {
    var _a, _b, _c;
    return {
      ...this.event.user,
      ...this.event.member,
      userId: (_a = this.event.user) == null ? void 0 : _a.id,
      username: (_b = this.event.user) == null ? void 0 : _b.name,
      nickname: (_c = this.event.member) == null ? void 0 : _c.name
    };
  }
  get uid() {
    return `${this.platform}:${this.userId}`;
  }
  get gid() {
    return `${this.platform}:${this.guildId}`;
  }
  get cid() {
    return `${this.platform}:${this.channelId}`;
  }
  get fid() {
    return `${this.platform}:${this.channelId}:${this.userId}`;
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  get elements() {
    var _a;
    return (_a = this.event.message) == null ? void 0 : _a.elements;
  }
  set elements(value) {
    var _a, _b;
    (_b = (_a = this.event).message) != null ? _b : _a.message = {};
    this.event.message.elements = value;
  }
  get content() {
    var _a, _b;
    return (_b = (_a = this.event.message) == null ? void 0 : _a.elements) == null ? void 0 : _b.join("");
  }
  set content(value) {
    var _a, _b;
    ((_b = (_a = this.event).message) != null ? _b : _a.message = {}).elements = (0, import_cosmokit.isNullable)(value) ? value : import_element.default.parse(value);
  }
  setInternal(type, data) {
    this.event._type = type;
    this.event._data = data;
    const internal = Object.create(this.bot.internal);
    (0, import_cosmokit.defineProperty)(this, type, Object.assign(internal, data));
  }
  async transform(elements) {
    return await import_element.default.transformAsync(elements, ({ type, attrs, children }, session) => {
      var _a;
      const render = type === "component" ? attrs.is : this.app.get("component:" + type);
      return (_a = render == null ? void 0 : render(attrs, children, session)) != null ? _a : true;
    }, this);
  }
  toJSON() {
    return { ...this.event, id: this.id };
  }
};
__name(_Session, "Session");
__publicField(_Session, "counter", 0);
var Session = _Session;
function defineAccessor(prototype, name, keys) {
  Object.defineProperty(prototype, name, {
    get() {
      return keys.reduce((data, key) => data == null ? void 0 : data[key], this);
    },
    set(value) {
      if (value === void 0)
        return;
      const _keys = keys.slice();
      const last = _keys.pop();
      const data = _keys.reduce((data2, key) => {
        var _a;
        return (_a = data2[key]) != null ? _a : data2[key] = {};
      }, this);
      data[last] = value;
    }
  });
}
__name(defineAccessor, "defineAccessor");
defineAccessor(Session.prototype, "type", ["event", "type"]);
defineAccessor(Session.prototype, "subtype", ["event", "subtype"]);
defineAccessor(Session.prototype, "subsubtype", ["event", "subsubtype"]);
defineAccessor(Session.prototype, "selfId", ["event", "selfId"]);
defineAccessor(Session.prototype, "platform", ["event", "platform"]);
defineAccessor(Session.prototype, "timestamp", ["event", "timestamp"]);
defineAccessor(Session.prototype, "userId", ["event", "user", "id"]);
defineAccessor(Session.prototype, "channelId", ["event", "channel", "id"]);
defineAccessor(Session.prototype, "channelName", ["event", "channel", "name"]);
defineAccessor(Session.prototype, "guildId", ["event", "guild", "id"]);
defineAccessor(Session.prototype, "guildName", ["event", "guild", "name"]);
defineAccessor(Session.prototype, "messageId", ["event", "message", "id"]);
defineAccessor(Session.prototype, "operatorId", ["event", "operator", "id"]);
defineAccessor(Session.prototype, "roleId", ["event", "role", "id"]);
defineAccessor(Session.prototype, "quote", ["event", "message", "quote"]);

// satori/packages/core/src/index.ts
var import_schemastery2 = __toESM(require("schemastery"), 1);
var import_cordis_axios = require("cordis-axios");
var logger = __toESM(require("@cordisjs/logger"), 1);
var import_timer = require("@cordisjs/timer");
var import_element3 = __toESM(require("@satorijs/element"), 1);
var import_logger = require("@cordisjs/logger");
var Satori = __toESM(require("@satorijs/protocol"), 1);
var Universal = __toESM(require("@satorijs/protocol"), 1);

// satori/packages/core/src/bot.ts
var import_cosmokit2 = require("cosmokit");
var import_protocol2 = require("@satorijs/protocol");
var eventAliases = [
  ["message-created", "message"]
];
var _Bot = class _Bot {
  constructor(ctx, config, platform) {
    this.ctx = ctx;
    this.config = config;
    this.internal = null;
    this.context = ctx;
    ctx.bots.push(this);
    this.context.emit("bot-added", this);
    if (platform) {
      this.logger = ctx.logger(platform);
      this.platform = platform;
    }
    ctx.on("ready", async () => {
      await Promise.resolve();
      this.dispatchLoginEvent("login-added");
      return this.start();
    });
    ctx.on("dispose", () => this.dispose());
    ctx.on("interaction/button", (session) => {
      const cb = this.callbacks[session.event.button.id];
      if (cb)
        cb(session);
    });
  }
  user = {};
  isBot = true;
  hidden = false;
  platform;
  adapter;
  error;
  callbacks = {};
  logger;
  // Same as `this.ctx`, but with a more specific type.
  context;
  _status = import_protocol2.Status.OFFLINE;
  update(login) {
    const { status, ...rest } = login;
    Object.assign(this, rest);
    this.status = status;
  }
  dispose() {
    (0, import_cosmokit2.remove)(this.ctx.bots, this);
    this.context.emit("bot-removed", this);
    this.dispatchLoginEvent("login-removed");
    return this.stop();
  }
  dispatchLoginEvent(type) {
    const session = this.session();
    session.type = type;
    session.event.login = this.toJSON();
    this.dispatch(session);
  }
  get status() {
    return this._status;
  }
  set status(value) {
    if (value === this._status)
      return;
    this._status = value;
    if (this.ctx.bots.includes(this)) {
      this.context.emit("bot-status-updated", this);
      this.dispatchLoginEvent("login-updated");
    }
  }
  get isActive() {
    return this._status !== import_protocol2.Status.OFFLINE && this._status !== import_protocol2.Status.DISCONNECT;
  }
  online() {
    this.status = import_protocol2.Status.ONLINE;
    this.error = null;
  }
  offline(error) {
    this.status = import_protocol2.Status.OFFLINE;
    this.error = error;
  }
  async start() {
    var _a;
    if (this.isActive)
      return;
    this.status = import_protocol2.Status.CONNECT;
    try {
      await this.context.parallel("bot-connect", this);
      await ((_a = this.adapter) == null ? void 0 : _a.connect(this));
    } catch (error) {
      this.offline(error);
    }
  }
  async stop() {
    var _a;
    if (!this.isActive)
      return;
    this.status = import_protocol2.Status.DISCONNECT;
    try {
      await this.context.parallel("bot-disconnect", this);
      await ((_a = this.adapter) == null ? void 0 : _a.disconnect(this));
    } catch (error) {
      this.context.emit("internal/error", error);
    } finally {
      this.offline();
    }
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  session(event = {}) {
    const { Session: Session2 } = this.ctx.constructor;
    return new Session2(this, event);
  }
  dispatch(session) {
    if (!this.ctx.lifecycle.isActive)
      return;
    let events = [session.type];
    for (const aliases of eventAliases) {
      if (aliases.includes(session.type)) {
        events = aliases;
        session.type = aliases[0];
        break;
      }
    }
    this.context.emit("internal/session", session);
    if (session.type === "internal") {
      this.context.emit(session.event._type, session.event._data, session.bot);
      return;
    }
    for (const event of events) {
      this.context.emit(session, event, session);
    }
  }
  async createMessage(channelId, content, guildId, options) {
    const { MessageEncoder: MessageEncoder2 } = this.constructor;
    return new MessageEncoder2(this, channelId, guildId, options).send(content);
  }
  async sendMessage(channelId, content, guildId, options) {
    const messages = await this.createMessage(channelId, content, guildId, options);
    return messages.map((message) => message.id);
  }
  async sendPrivateMessage(userId, content, guildId, options) {
    var _a;
    const { id } = await this.createDirectChannel(userId, guildId != null ? guildId : (_a = options == null ? void 0 : options.session) == null ? void 0 : _a.guildId);
    return this.sendMessage(id, content, null, options);
  }
  async supports(name, session = {}) {
    var _a;
    return !!this[(_a = import_protocol2.Methods[name]) == null ? void 0 : _a.name];
  }
  async checkPermission(name, session) {
    if (name.startsWith("bot.")) {
      return this.supports(name.slice(4), session);
    }
  }
  toJSON() {
    return (0, import_cosmokit2.clone)((0, import_cosmokit2.pick)(this, ["platform", "selfId", "status", "user", "hidden"]));
  }
  async getLogin() {
    return this.toJSON();
  }
  /** @deprecated use `bot.getLogin()` instead */
  async getSelf() {
    const { user } = await this.getLogin();
    return user;
  }
};
__name(_Bot, "Bot");
__publicField(_Bot, "reusable", true);
__publicField(_Bot, "MessageEncoder");
var Bot = _Bot;
var iterableMethods = [
  "getMessage",
  "getReaction",
  "getFriend",
  "getGuild",
  "getGuildMember",
  "getGuildRole",
  "getChannel"
];
for (const name of iterableMethods) {
  Bot.prototype[name + "Iter"] = function(...args) {
    let list;
    if (!this[name + "List"])
      throw new Error(`not implemented: ${name}List`);
    const getList = /* @__PURE__ */ __name(async () => {
      list = await this[name + "List"](...args, list == null ? void 0 : list.next);
    }, "getList");
    return {
      async next() {
        if (list == null ? void 0 : list.data.length)
          return { done: false, value: list.data.shift() };
        if (list && !(list == null ? void 0 : list.next))
          return { done: true, value: void 0 };
        await getList();
        return this.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  };
}
defineAccessor(Bot.prototype, "selfId", ["user", "id"]);
defineAccessor(Bot.prototype, "userId", ["user", "id"]);

// satori/packages/core/src/adapter.ts
var import_cosmokit3 = require("cosmokit");
var import_protocol3 = require("@satorijs/protocol");
var import_schemastery = __toESM(require("schemastery"), 1);
var _Adapter = class _Adapter {
  constructor(ctx) {
    this.ctx = ctx;
  }
  bots = [];
  async connect(bot) {
  }
  async disconnect(bot) {
  }
  fork(ctx, bot) {
    bot.adapter = this;
    this.bots.push(bot);
    ctx.on("dispose", () => {
      (0, import_cosmokit3.remove)(this.bots, bot);
    });
  }
};
__name(_Adapter, "Adapter");
__publicField(_Adapter, "schema", false);
var Adapter = _Adapter;
((Adapter2) => {
  Adapter2.WsClientConfig = import_schemastery.default.object({
    retryTimes: import_schemastery.default.natural().description("初次连接时的最大重试次数。").default(6),
    retryInterval: import_schemastery.default.natural().role("ms").description("初次连接时的重试时间间隔。").default(5 * import_cosmokit3.Time.second),
    retryLazy: import_schemastery.default.natural().role("ms").description("连接关闭后的重试时间间隔。").default(import_cosmokit3.Time.minute)
  }).description("连接设置");
  const _WsClientBase = class _WsClientBase extends Adapter2 {
    constructor(ctx, config) {
      super(ctx);
      this.config = config;
    }
    socket;
    async start() {
      let _retryCount = 0;
      const logger2 = this.ctx.logger("adapter");
      const { retryTimes, retryInterval, retryLazy } = this.config;
      const reconnect = /* @__PURE__ */ __name(async (initial = false) => {
        logger2.debug("websocket client opening");
        const socket = await this.prepare();
        const url = socket.url.replace(/\?.+/, "");
        socket.addEventListener("error", (event) => {
          logger2.debug(event);
        });
        socket.addEventListener("close", ({ code, reason }) => {
          this.socket = null;
          logger2.debug(`websocket closed with ${code}`);
          if (!this.getActive())
            return;
          const message = reason.toString() || `failed to connect to ${url}, code: ${code}`;
          let timeout = retryInterval;
          if (_retryCount >= retryTimes) {
            if (initial) {
              return this.setStatus(import_protocol3.Status.OFFLINE, new Error(message));
            } else {
              timeout = retryLazy;
            }
          }
          _retryCount++;
          this.setStatus(import_protocol3.Status.RECONNECT);
          logger2.warn(`${message}, will retry in ${import_cosmokit3.Time.format(timeout)}...`);
          setTimeout(() => {
            if (this.getActive())
              reconnect();
          }, timeout);
        });
        socket.addEventListener("open", () => {
          _retryCount = 0;
          this.socket = socket;
          logger2.info("connect to server: %c", url);
          this.accept(socket);
        });
      }, "reconnect");
      reconnect(true);
    }
    async stop() {
      var _a;
      (_a = this.socket) == null ? void 0 : _a.close();
    }
  };
  __name(_WsClientBase, "WsClientBase");
  let WsClientBase = _WsClientBase;
  Adapter2.WsClientBase = _WsClientBase;
  const _WsClient = class _WsClient extends WsClientBase {
    constructor(ctx, bot) {
      super(ctx, bot.config);
      this.bot = bot;
      bot.adapter = this;
    }
    getActive() {
      return this.bot.isActive;
    }
    setStatus(status, error = null) {
      this.bot.status = status;
      this.bot.error = error;
    }
    async connect(bot) {
      this.start();
    }
    async disconnect(bot) {
      this.stop();
    }
  };
  __name(_WsClient, "WsClient");
  __publicField(_WsClient, "reusable", true);
  __publicField(_WsClient, "Config", Adapter2.WsClientConfig);
  let WsClient = _WsClient;
  Adapter2.WsClient = _WsClient;
})(Adapter || (Adapter = {}));

// satori/packages/core/src/message.ts
var import_element2 = __toESM(require("@satorijs/element"), 1);
var _AggregateError = class _AggregateError extends Error {
  constructor(errors, message = "") {
    super(message);
    this.errors = errors;
  }
};
__name(_AggregateError, "AggregateError");
var AggregateError = _AggregateError;
var _MessageEncoder = class _MessageEncoder {
  constructor(bot, channelId, guildId, options = {}) {
    this.bot = bot;
    this.channelId = channelId;
    this.guildId = guildId;
    this.options = options;
  }
  errors = [];
  results = [];
  session;
  async prepare() {
  }
  async render(elements, flush) {
    for (const element of elements) {
      await this.visit(element);
    }
    if (flush) {
      await this.flush();
    }
  }
  async send(content) {
    var _a, _b, _c, _d;
    this.session = this.bot.session({
      type: "send",
      channel: { id: this.channelId, ...(_a = this.options.session) == null ? void 0 : _a.event.channel },
      guild: (_b = this.options.session) == null ? void 0 : _b.event.guild
    });
    for (const key in this.options.session || {}) {
      if (key === "id" || key === "event")
        continue;
      this.session[key] = this.options.session[key];
    }
    await this.prepare();
    const session = (_c = this.options.session) != null ? _c : this.session;
    this.session.elements = await session.transform(import_element2.default.normalize(content));
    const btns = import_element2.default.select(this.session.elements, "button").filter((v) => v.attrs.type !== "link" && !v.attrs.id);
    for (const btn of btns) {
      const r = Math.random().toString(36).slice(2);
      (_d = btn.attrs).id || (_d.id = r);
      if (typeof btn.attrs.action === "function")
        this.bot.callbacks[btn.attrs.id] = btn.attrs.action;
    }
    if (await this.session.app.serial(this.session, "before-send", this.session, this.options))
      return;
    await this.render(this.session.elements);
    await this.flush();
    if (this.errors.length) {
      throw new AggregateError(this.errors);
    } else {
      return this.results;
    }
  }
};
__name(_MessageEncoder, "MessageEncoder");
var MessageEncoder = _MessageEncoder;

// satori/packages/core/src/index.ts
import_element3.default.warn = new logger.Logger("element").warn;
(0, import_cosmokit4.defineProperty)(import_cordis_axios.Quester, "Config", import_schemastery2.default.object({
  timeout: import_schemastery2.default.natural().role("ms").description("等待连接建立的最长时间。"),
  proxyAgent: import_schemastery2.default.string().description("使用的代理服务器地址。"),
  keepAlive: import_schemastery2.default.boolean().description("是否保持连接。")
}).description("请求设置"));
import_cordis_axios.Quester.createConfig = /* @__PURE__ */ __name(function createConfig(endpoint) {
  return import_schemastery2.default.object({
    endpoint: import_schemastery2.default.string().role("link").description("要连接的服务器地址。").default(typeof endpoint === "string" ? endpoint : null).required(typeof endpoint === "boolean" ? endpoint : false),
    headers: import_schemastery2.default.dict(String).role("table").description("要附加的额外请求头。"),
    ...this.Config.dict
  }).description("请求设置");
}, "createConfig");
var _Service = class _Service extends cordis.Service {
  logger;
  constructor(ctx, name, immediate) {
    super(ctx, name, immediate);
    this.logger = ctx.logger(name);
  }
};
__name(_Service, "Service");
var Service2 = _Service;
var _Context = class _Context extends cordis.Context {
  bots = new Proxy([], {
    get(target, prop) {
      if (prop in target || typeof prop === "symbol") {
        return Reflect.get(target, prop);
      }
      return target.find((bot) => bot.sid === prop);
    },
    deleteProperty(target, prop) {
      if (prop in target || typeof prop === "symbol") {
        return Reflect.deleteProperty(target, prop);
      }
      const bot = target.findIndex((bot2) => bot2.sid === prop);
      if (bot < 0)
        return true;
      target.splice(bot, 1);
      return true;
    }
  });
  constructor(config = {}) {
    super(config);
    this.provide("logger", void 0, true);
    this.provide("timer", void 0, true);
    this.provide("http", void 0, true);
    this.plugin(logger);
    this.plugin(import_timer.TimerService);
    this.http = new import_cordis_axios.Quester(config.request);
  }
  component(name, component, options = {}) {
    const render = /* @__PURE__ */ __name(async (attrs, children, session) => {
      if (options.session && session.type === "send") {
        throw new Error("interactive components is not available outside sessions");
      }
      const result = await component(attrs, children, session);
      return session.transform(import_element3.default.normalize(result));
    }, "render");
    const service = "component:" + name;
    this.provide(service);
    return this.effect(() => {
      this[service] = render;
      return () => this[service] = null;
    });
  }
};
__name(_Context, "Context");
__publicField(_Context, "session", Symbol("session"));
// remove generic type to loosen the constraint
__publicField(_Context, "Session", Session);
var Context = _Context;
((Context3) => {
  Context3.Config = import_schemastery2.default.intersect([
    import_schemastery2.default.object({})
  ]);
})(Context || (Context = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Adapter,
  Bot,
  Context,
  Element,
  Logger,
  MessageEncoder,
  Messenger,
  Modulator,
  Quester,
  Satori,
  Schema,
  Service,
  Session,
  Universal,
  defineAccessor,
  h,
  segment,
  z
});
//# sourceMappingURL=index.cjs.map
