import * as cordis from 'cordis';
import { Message, SendOptions, Event, GuildMember, User, Login, Methods, Status, WebSocket } from '@satorijs/protocol';
import h from '@satorijs/element';
import { Dict, Awaitable } from 'cosmokit';
import { z } from 'cordis';
import { HTTP } from 'undios';
export abstract class MessageEncoder<C extends Context = Context, B extends Bot<C> = Bot<C>> {
    bot: B;
    channelId: string;
    guildId?: string;
    options: SendOptions;
    errors: Error[];
    results: Message[];
    session: C[typeof Context.session];
    constructor(bot: B, channelId: string, guildId?: string, options?: SendOptions);
    prepare(): Promise<void>;
    abstract flush(): Promise<void>;
    abstract visit(element: h): Promise<void>;
    render(elements: h[], flush?: boolean): Promise<void>;
    send(content: h.Fragment): Promise<Message[]>;
}
export { MessageEncoder as Modulator, MessageEncoder as Messenger };
declare module '@satorijs/protocol' {
    interface SendOptions {
        session?: Session;
    }
}
export interface Session {
    type: string;
    subtype: string;
    subsubtype: string;
    selfId: string;
    platform: string;
    timestamp: number;
    userId: string;
    channelId: string;
    guildId: string;
    messageId: string;
    operatorId: string;
    roleId: string;
    quote: Message;
}
export interface Session extends Context.Associate<'session'> {
}
export class Session<C extends Context = Context> {
    static counter: number;
    id: number;
    bot: Bot<C>;
    app: C['root'];
    event: Event;
    locales: string[];
    constructor(bot: Bot<C>, event: Partial<Event>);
    /** @deprecated */
    get data(): Event;
    get isDirect(): boolean;
    set isDirect(value: boolean);
    get author(): GuildMember & User;
    get uid(): string;
    get gid(): string;
    get cid(): string;
    get fid(): string;
    get sid(): string;
    get elements(): h[];
    set elements(value: h[]);
    get content(): string | undefined;
    set content(value: string | undefined);
    setInternal(type: string, data: any): void;
    transform(elements: h[]): Promise<h[]>;
    toJSON(): Event;
}
export function defineAccessor(prototype: {}, name: string, keys: string[]): void;
export interface Bot extends Methods {
    userId: string;
    selfId: string;
    internal: any;
}
export abstract class Bot<C extends Context = Context, T = any> implements Login {
    ctx: C;
    config: T;
    static reusable: boolean;
    static MessageEncoder?: new (bot: Bot, channelId: string, guildId?: string, options?: SendOptions) => MessageEncoder;
    user: User;
    isBot: boolean;
    hidden: boolean;
    platform: string;
    adapter?: Adapter<C, this>;
    error?: Error;
    callbacks: Dict<Function>;
    logger: cordis.Logger;
    protected context: Context;
    protected _status: Status;
    constructor(ctx: C, config: T, platform?: string);
    update(login: Login): void;
    dispose(): Promise<void>;
    private dispatchLoginEvent;
    get status(): Status;
    set status(value: Status);
    get isActive(): boolean;
    online(): void;
    offline(error?: Error): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    get sid(): string;
    session(event?: Partial<Event>): C[typeof Context.session];
    dispatch(session: C[typeof Context.session]): void;
    createMessage(channelId: string, content: h.Fragment, guildId?: string, options?: SendOptions): Promise<import("@satorijs/protocol").Message[]>;
    sendMessage(channelId: string, content: h.Fragment, guildId?: string, options?: SendOptions): Promise<string[]>;
    sendPrivateMessage(userId: string, content: h.Fragment, guildId?: string, options?: SendOptions): Promise<string[]>;
    supports(name: string, session?: Partial<C[typeof Context.session]>): Promise<boolean>;
    checkPermission(name: string, session: Partial<C[typeof Context.session]>): Promise<boolean>;
    toJSON(): Login;
    getLogin(): Promise<Login>;
    /** @deprecated use `bot.getLogin()` instead */
    getSelf(): Promise<User>;
}
export type { Fragment, Render } from '@satorijs/element';
export { h, h as Element, h as segment, HTTP, HTTP as Quester };
export * from 'cordis';
export * as file from 'undios-file';
export * as Universal from '@satorijs/protocol';
declare module 'undios' {
    namespace HTTP {
        const Config: z<Config>;
        function createConfig(this: typeof HTTP, endpoint?: string | boolean): z<Config>;
    }
}
export type Component<S extends Session = Session> = h.Render<Awaitable<h.Fragment>, S>;
export namespace Component {
    interface Options {
        session?: boolean;
    }
}
export type GetSession<C extends Context> = C[typeof Context.session];
export interface Events<C extends Context = Context> extends cordis.Events<C> {
    'internal/session'(session: GetSession<C>): void;
    'interaction/command'(session: GetSession<C>): void;
    'interaction/button'(session: GetSession<C>): void;
    'message'(session: GetSession<C>): void;
    'message-created'(session: GetSession<C>): void;
    'message-deleted'(session: GetSession<C>): void;
    'message-updated'(session: GetSession<C>): void;
    'message-pinned'(session: GetSession<C>): void;
    'message-unpinned'(session: GetSession<C>): void;
    'guild-added'(session: GetSession<C>): void;
    'guild-removed'(session: GetSession<C>): void;
    'guild-updated'(session: GetSession<C>): void;
    'guild-member-added'(session: GetSession<C>): void;
    'guild-member-removed'(session: GetSession<C>): void;
    'guild-member-updated'(session: GetSession<C>): void;
    'guild-role-created'(session: GetSession<C>): void;
    'guild-role-deleted'(session: GetSession<C>): void;
    'guild-role-updated'(session: GetSession<C>): void;
    'reaction-added'(session: GetSession<C>): void;
    'reaction-removed'(session: GetSession<C>): void;
    'login-added'(session: GetSession<C>): void;
    'login-removed'(session: GetSession<C>): void;
    'login-updated'(session: GetSession<C>): void;
    'friend-request'(session: GetSession<C>): void;
    'guild-request'(session: GetSession<C>): void;
    'guild-member-request'(session: GetSession<C>): void;
    'before-send'(session: GetSession<C>, options: SendOptions): Awaitable<void | boolean>;
    'send'(session: GetSession<C>): void;
    /** @deprecated use `login-added` instead */
    'bot-added'(client: Bot<C>): void;
    /** @deprecated use `login-removed` instead */
    'bot-removed'(client: Bot<C>): void;
    /** @deprecated use `login-updated` instead */
    'bot-status-updated'(client: Bot<C>): void;
    'bot-connect'(client: Bot<C>): Awaitable<void>;
    'bot-disconnect'(client: Bot<C>): Awaitable<void>;
}
export interface Events<C extends Context = Context> extends cordis.Events<C> {
}
export interface Context {
    [Context.events]: Events<this>;
    [Context.session]: Session<this>;
}
export class Context extends cordis.Context {
    static readonly session: unique symbol;
    static readonly Session: new (bot: Bot, event: Partial<Event>) => Session;
    bots: Bot<this, any>[] & Dict<Bot<this, any>>;
    constructor(config?: Context.Config);
    component(name: string, component: Component<this[typeof Context.session]>, options?: Component.Options): () => void;
}
export namespace Context {
    export interface Config {
        request?: HTTP.Config;
    }
    export const Config: Config.Static;
    namespace Config {
        interface Static extends z<Config> {
        }
    }
    export type Associate<P extends string, C extends Context = Context> = cordis.Context.Associate<P, C>;
}
export abstract class Service<T = any, C extends Context = Context> extends cordis.Service<T, C> {
    [cordis.Service.setup](): void;
}
export abstract class Adapter<C extends Context = Context, B extends Bot<C> = Bot<C>> {
    protected ctx: C;
    static schema: false;
    bots: B[];
    constructor(ctx: C);
    connect(bot: B): Promise<void>;
    disconnect(bot: B): Promise<void>;
    fork(ctx: Context, bot: B): void;
}
export namespace Adapter {
    interface WsClientConfig {
        retryLazy?: number;
        retryTimes?: number;
        retryInterval?: number;
    }
    const WsClientConfig: z<WsClientConfig>;
    abstract class WsClientBase<C extends Context, B extends Bot<C>> extends Adapter<C, B> {
        config: WsClientConfig;
        protected socket: WebSocket;
        protected abstract prepare(): Awaitable<WebSocket>;
        protected abstract accept(socket: WebSocket): void;
        protected abstract getActive(): boolean;
        protected abstract setStatus(status: Status, error?: Error): void;
        constructor(ctx: C, config: WsClientConfig);
        start(): Promise<void>;
        stop(): Promise<void>;
    }
    abstract class WsClient<C extends Context, B extends Bot<C, WsClientConfig>> extends WsClientBase<C, B> {
        bot: B;
        static reusable: boolean;
        constructor(ctx: C, bot: B);
        getActive(): boolean;
        setStatus(status: Status, error?: Error): void;
        connect(bot: B): Promise<void>;
        disconnect(bot: B): Promise<void>;
    }
}
