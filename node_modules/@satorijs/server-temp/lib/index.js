"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_satori = require("@satorijs/satori");
var import_fs = require("fs");
var import_url = require("url");
var import_promises = require("fs/promises");
var import_stream = __toESM(require("stream"));
var TempServer = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    const logger = ctx.logger("temp");
    this.path = (0, import_satori.sanitize)(config.path);
    this.selfUrl = config.selfUrl || ctx.server.config.selfUrl;
    if (!this.selfUrl) {
      logger.warn("missing selfUrl configuration");
    }
    ctx.server.get(this.path + "/:name", async (koa) => {
      logger.debug(koa.params.name);
      const entry = this.entries[koa.params.name];
      if (!entry)
        return koa.status = 404;
      koa.body = (0, import_fs.createReadStream)(entry.path);
    });
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => this.stop());
  }
  static {
    __name(this, "TempServer");
  }
  static inject = ["server", "http"];
  path;
  selfUrl;
  baseDir;
  entries = /* @__PURE__ */ Object.create(null);
  async start() {
    this.baseDir = this.ctx.baseDir + "/temp/" + Math.random().toString(36).slice(2) + "/";
    await (0, import_promises.mkdir)(this.baseDir, { recursive: true });
    this.ctx.provide("server.temp", this);
  }
  async stop() {
    await (0, import_promises.rm)(this.baseDir, { recursive: true });
  }
  async create(data) {
    const name = Math.random().toString(36).slice(2);
    const url = this.selfUrl + this.path + "/" + name;
    let path;
    if (typeof data === "string") {
      if (new URL(data).protocol === "file:") {
        path = (0, import_url.fileURLToPath)(data);
      } else {
        const stream = await this.ctx.http.get(data, { responseType: "stream" });
        path = this.baseDir + name;
        await (0, import_promises.writeFile)(path, import_stream.default.Readable.fromWeb(stream));
      }
    } else {
      path = this.baseDir + name;
      await (0, import_promises.writeFile)(path, data);
    }
    const dispose = this[import_satori.Context.current]?.collect("server.temp", async () => {
      clearTimeout(timer);
      delete this.entries[name];
      if (path.startsWith(this.baseDir))
        await (0, import_promises.rm)(path);
    });
    const timer = dispose && setTimeout(() => dispose(), this.config.maxAge);
    return this.entries[name] = { path, url, dispose };
  }
};
((TempServer2) => {
  TempServer2.Config = import_satori.Schema.object({
    path: import_satori.Schema.string().default("/temp"),
    selfUrl: import_satori.Schema.string().role("link").description("此服务暴露在公网的地址。缺省时将使用全局配置。"),
    maxAge: import_satori.Schema.number().default(import_satori.Time.minute * 5).description("临时文件的默认最大存活时间。")
  });
})(TempServer || (TempServer = {}));
var src_default = TempServer;
//# sourceMappingURL=index.js.map
