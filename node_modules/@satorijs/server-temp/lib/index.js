"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// satori/packages/server-temp/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_satori = require("@satorijs/satori");
var import_fs = require("fs");
var import_url = require("url");
var import_promises = require("fs/promises");
var _TempServer = class _TempServer {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    const logger = ctx.logger("temp");
    this.path = (0, import_satori.sanitize)(config.path);
    this.selfUrl = config.selfUrl || ctx.server.config.selfUrl;
    if (!this.selfUrl) {
      logger.warn("missing selfUrl configuration");
    }
    ctx.server.get(this.path + "/:name", async (koa) => {
      logger.debug(koa.params.name);
      const entry = this.entries[koa.params.name];
      if (!entry)
        return koa.status = 404;
      koa.body = (0, import_fs.createReadStream)(entry.path);
    });
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => this.stop());
  }
  path;
  selfUrl;
  baseDir;
  entries = /* @__PURE__ */ Object.create(null);
  async start() {
    this.baseDir = this.ctx.baseDir + "/temp/" + Math.random().toString(36).slice(2) + "/";
    await (0, import_promises.mkdir)(this.baseDir, { recursive: true });
    this.ctx.provide("server.temp", this);
  }
  async stop() {
    await (0, import_promises.rm)(this.baseDir, { recursive: true });
  }
  async create(data) {
    var _a;
    const name = Math.random().toString(36).slice(2);
    const url = this.selfUrl + this.path + "/" + name;
    let path;
    if (typeof data === "string") {
      if (new URL(data).protocol === "file:") {
        path = (0, import_url.fileURLToPath)(data);
      } else {
        data = await this.ctx.http.get(data, { responseType: "stream" });
        path = this.baseDir + name;
        await (0, import_promises.writeFile)(path, data);
      }
    } else {
      path = this.baseDir + name;
      await (0, import_promises.writeFile)(path, data);
    }
    const dispose = (_a = this[import_satori.Context.current]) == null ? void 0 : _a.collect("server.temp", async () => {
      clearTimeout(timer);
      delete this.entries[name];
      if (path.startsWith(this.baseDir))
        await (0, import_promises.rm)(path);
    });
    const timer = dispose && setTimeout(() => dispose(), this.config.maxAge);
    return this.entries[name] = { path, url, dispose };
  }
};
__name(_TempServer, "TempServer");
__publicField(_TempServer, "inject", ["server"]);
var TempServer = _TempServer;
((TempServer2) => {
  TempServer2.Config = import_satori.Schema.object({
    path: import_satori.Schema.string().default("/temp"),
    selfUrl: import_satori.Schema.string().role("link").description("此服务暴露在公网的地址。缺省时将使用全局配置。"),
    maxAge: import_satori.Schema.number().default(import_satori.Time.minute * 5).description("临时文件的默认最大存活时间。")
  });
})(TempServer || (TempServer = {}));
var src_default = TempServer;
//# sourceMappingURL=index.js.map
