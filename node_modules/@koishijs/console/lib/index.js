var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// external/webui/packages/console/src/index.ts
var src_exports = {};
__export(src_exports, {
  Client: () => Client,
  Console: () => Console,
  DataService: () => DataService,
  Entry: () => Entry,
  EntryProvider: () => EntryProvider,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_koishi3 = require("koishi");

// external/webui/packages/console/src/service.ts
var import_koishi = require("koishi");
var _DataService = class _DataService extends import_koishi.Service {
  constructor(ctx, key, options = {}) {
    super(ctx, `console.${key}`, options.immediate);
    this.ctx = ctx;
    this.key = key;
    this.options = options;
  }
  async get(forced, client) {
    return null;
  }
  start() {
    this.refresh();
  }
  async refresh(forced = true) {
    var _a;
    (_a = this.ctx.get("console")) == null ? void 0 : _a.broadcast("data", async (client) => ({
      key: this.key,
      value: await this.get(forced, client)
    }), this.options);
  }
  patch(value) {
    var _a;
    (_a = this.ctx.get("console")) == null ? void 0 : _a.broadcast("patch", {
      key: this.key,
      value
    }, this.options);
  }
};
__name(_DataService, "DataService");
__publicField(_DataService, "filter", false);
__publicField(_DataService, "inject", ["console"]);
var DataService = _DataService;

// external/webui/packages/console/src/schema.ts
var _SchemaProvider = class _SchemaProvider extends DataService {
  constructor(ctx) {
    super(ctx, "schema", { immediate: true });
    ctx.on("internal/schema", () => this.refresh());
  }
  async get() {
    return this.ctx.schema._data;
  }
};
__name(_SchemaProvider, "SchemaProvider");
var SchemaProvider = _SchemaProvider;

// external/webui/packages/console/src/permission.ts
var _PermissionProvider = class _PermissionProvider extends DataService {
  constructor(ctx) {
    super(ctx, "permissions", { immediate: true });
    ctx.on("internal/permission", () => this.refresh());
  }
  async get() {
    return this.ctx.permissions.list();
  }
};
__name(_PermissionProvider, "PermissionProvider");
var PermissionProvider = _PermissionProvider;

// external/webui/packages/console/src/client.ts
var import_koishi2 = require("koishi");
var logger = new import_koishi2.Logger("console");
var _Client = class _Client {
  constructor(ctx, socket, request) {
    this.ctx = ctx;
    this.socket = socket;
    this.request = request;
    socket.addEventListener("message", this.receive);
    ctx.on("dispose", () => {
      socket.removeEventListener("message", this.receive);
    });
    this.refresh();
  }
  id = import_koishi2.Random.id();
  send(payload) {
    this.socket.send(JSON.stringify(payload));
  }
  receive = async (data) => {
    const { type, args, id } = JSON.parse(data.data.toString());
    const listener = this.ctx.get("console").listeners[type];
    if (!listener) {
      logger.info("unknown message:", type, ...args);
      return this.send({ type: "response", body: { id, error: "not implemented" } });
    }
    if (await this.ctx.serial("console/intercept", this, listener)) {
      return this.send({ type: "response", body: { id, error: "unauthorized" } });
    }
    try {
      const value = await listener.callback.call(this, ...args);
      return this.send({ type: "response", body: { id, value } });
    } catch (e) {
      logger.debug(e);
      const error = (0, import_koishi2.coerce)(e);
      return this.send({ type: "response", body: { id, error } });
    }
  };
  refresh() {
    Object.keys(this.ctx.root[import_koishi2.Context.internal]).forEach(async (name) => {
      if (!name.startsWith("console."))
        return;
      const key = name.slice(8);
      const service = this.ctx.get(name);
      if (!service)
        return;
      if (await this.ctx.serial("console/intercept", this, service.options)) {
        return this.send({ type: "data", body: { key, value: null } });
      }
      try {
        const value = await service.get(false, this);
        if (!value)
          return;
        this.send({ type: "data", body: { key, value } });
      } catch (error) {
        logger.warn(error);
      }
    });
  }
};
__name(_Client, "Client");
var Client = _Client;

// external/webui/packages/console/src/entry.ts
var _Entry = class _Entry {
  constructor(ctx, files, data) {
    this.ctx = ctx;
    this.files = files;
    this.data = data;
    ctx.console.entries[this.id] = this;
    ctx.console.refresh("entry");
    this.dispose = ctx.collect("entry", () => {
      delete this.ctx.console.entries[this.id];
      ctx.console.refresh("entry");
    });
  }
  id = Math.random().toString(36).slice(2);
  dispose;
  refresh() {
    this.ctx.console.broadcast("entry-data", async (client) => ({
      id: this.id,
      data: await this.data(client)
    }));
  }
};
__name(_Entry, "Entry");
var Entry = _Entry;

// external/webui/packages/console/src/index.ts
var _EntryProvider = class _EntryProvider extends DataService {
  constructor(ctx) {
    super(ctx, "entry", { immediate: true });
  }
  async get(forced, client) {
    return this.ctx.get("console").get(client);
  }
};
__name(_EntryProvider, "EntryProvider");
__publicField(_EntryProvider, "inject", []);
var EntryProvider = _EntryProvider;
var _Console = class _Console extends import_koishi3.Service {
  constructor(ctx) {
    super(ctx, "console", true);
    this.ctx = ctx;
    ctx.plugin(EntryProvider);
    ctx.plugin(SchemaProvider);
    ctx.plugin(PermissionProvider);
    this.addListener("ping", () => "pong");
  }
  id = Math.random().toString(36).slice(2);
  entries = /* @__PURE__ */ Object.create(null);
  listeners = /* @__PURE__ */ Object.create(null);
  clients = /* @__PURE__ */ Object.create(null);
  accept(socket, request) {
    const client = new Client(this.ctx, socket, request);
    socket.addEventListener("close", () => {
      delete this.clients[client.id];
      this.ctx.emit("console/connection", client);
    });
    this.clients[client.id] = client;
    this.ctx.emit("console/connection", client);
  }
  async get(client) {
    const result = (0, import_koishi3.valueMap)(this.entries, ({ files, ctx, data }, key) => {
      var _a;
      return {
        files: this.resolveEntry(files, key),
        paths: (_a = this.ctx.get("loader")) == null ? void 0 : _a.paths(ctx.scope),
        data: data == null ? void 0 : data(client)
      };
    });
    result["_id"] = this.id;
    return result;
  }
  addEntry(files, data) {
    return new Entry(this[import_koishi3.Context.current], files, data);
  }
  addListener(event, callback, options) {
    this.listeners[event] = { callback, ...options };
  }
  async broadcast(type, body, options = {}) {
    const handles = Object.values(this.clients);
    if (!handles.length)
      return;
    await Promise.all(Object.values(this.clients).map(async (client) => {
      if (await this.ctx.serial("console/intercept", client, options))
        return;
      const data = { type, body };
      if (typeof body === "function")
        data.body = await body(client);
      client.socket.send(JSON.stringify(data));
    }));
  }
  refresh(type) {
    var _a;
    return (_a = this.ctx.get(`console.${type}`)) == null ? void 0 : _a.refresh();
  }
  patch(type, value) {
    var _a;
    return (_a = this.ctx.get(`console.${type}`)) == null ? void 0 : _a.patch(value);
  }
};
__name(_Console, "Console");
__publicField(_Console, "filter", false);
var Console = _Console;
var src_default = Console;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  Console,
  DataService,
  Entry,
  EntryProvider
});
//# sourceMappingURL=index.js.map
