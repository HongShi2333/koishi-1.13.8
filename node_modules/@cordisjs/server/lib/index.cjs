"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// cordis/server/packages/core/src/index.ts
var src_exports = {};
__export(src_exports, {
  Router: () => Router,
  WebSocketLayer: () => WebSocketLayer,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_cordis = require("cordis");
var import_cosmokit = require("cosmokit");
var import_http = require("http");
var import_path_to_regexp = require("path-to-regexp");
var import_koa_bodyparser = __toESM(require("koa-bodyparser"), 1);
var import_parseurl = __toESM(require("parseurl"), 1);
var import_ws = require("ws");
var import_schemastery = __toESM(require("schemastery"), 1);
var import_router = __toESM(require("@koa/router"), 1);
var import_koa = __toESM(require("koa"), 1);

// cordis/server/packages/core/src/listen.ts
var import_net = __toESM(require("net"), 1);
function listen({ host, port, maxPort = port }) {
  const server = import_net.default.createServer();
  return new Promise((resolve, reject) => {
    function onListen() {
      server.off("error", onError);
      server.close((err) => {
        err ? reject(err) : resolve(port);
      });
    }
    __name(onListen, "onListen");
    function onError(err) {
      server.off("listening", onListen);
      if (!(err.code === "EADDRINUSE" || err.code === "EACCES")) {
        return reject(err);
      }
      port++;
      if (port > maxPort) {
        return reject(new Error("No open ports available"));
      }
      testPort();
    }
    __name(onError, "onError");
    function testPort() {
      server.once("error", onError);
      server.once("listening", onListen);
      server.listen(port, host);
    }
    __name(testPort, "testPort");
    testPort();
  });
}
__name(listen, "listen");

// cordis/server/packages/core/src/index.ts
var _WebSocketLayer = class _WebSocketLayer {
  constructor(server, path, callback) {
    this.server = server;
    this.callback = callback;
    this.regexp = (0, import_path_to_regexp.pathToRegexp)(path);
  }
  clients = /* @__PURE__ */ new Set();
  regexp;
  accept(socket, request) {
    var _a;
    if (!this.regexp.test((0, import_parseurl.default)(request).pathname))
      return;
    this.clients.add(socket);
    socket.addEventListener("close", () => {
      this.clients.delete(socket);
    });
    (_a = this.callback) == null ? void 0 : _a.call(this, socket, request);
    return true;
  }
  close() {
    (0, import_cosmokit.remove)(this.server.wsStack, this);
    for (const socket of this.clients) {
      socket.close();
    }
  }
};
__name(_WebSocketLayer, "WebSocketLayer");
var WebSocketLayer = _WebSocketLayer;
var _Router = class _Router extends import_router.default {
  constructor(ctx, config) {
    super();
    this.ctx = ctx;
    this.config = config;
    ctx.provide("server");
    ctx.alias("server", ["router"]);
    this.logger = ctx.logger("server");
    const koa = new import_koa.default();
    koa.use((0, import_koa_bodyparser.default)({
      enableTypes: ["json", "form", "xml"],
      jsonLimit: "10mb",
      formLimit: "10mb",
      textLimit: "10mb",
      xmlLimit: "10mb"
    }));
    koa.use(this.routes());
    koa.use(this.allowedMethods());
    this._http = (0, import_http.createServer)(koa.callback());
    this._ws = new import_ws.WebSocketServer({
      server: this._http
    });
    this._ws.on("connection", (socket, request) => {
      for (const manager of this.wsStack) {
        if (manager.accept(socket, request))
          return;
      }
      socket.close();
    });
    ctx.decline(["selfUrl", "host", "port", "maxPort"]);
    if (config.selfUrl) {
      config.selfUrl = (0, import_cosmokit.trimSlash)(config.selfUrl);
    }
    ctx.on("ready", async () => {
      const { host = "127.0.0.1", port } = config;
      if (!port)
        return;
      this.host = host;
      this.port = await listen(config);
      this._http.listen(this.port, host);
      this.logger.info("server listening at %c", `http://${host}:${this.port}`);
      ctx.emit(this, "server/ready");
    }, true);
    ctx.on("dispose", () => {
      var _a, _b;
      if (config.port) {
        this.logger.info("http server closing");
      }
      (_a = this._ws) == null ? void 0 : _a.close();
      (_b = this._http) == null ? void 0 : _b.close();
    });
    const self = this;
    ctx.on("internal/listener", function(name, listener) {
      if (name !== "server/ready" || !self[import_cordis.Context.filter](this) || !self.port)
        return;
      this.scope.ensure(async () => listener());
      return () => false;
    });
    return ctx.server = import_cordis.Context.associate(this, "server");
  }
  _http;
  _ws;
  wsStack = [];
  host;
  port;
  logger;
  [import_cordis.Context.filter](ctx) {
    return ctx[import_cordis.Context.shadow].server === this.ctx[import_cordis.Context.shadow].server;
  }
  get selfUrl() {
    const wildcard = ["0.0.0.0", "::"];
    const host = wildcard.includes(this.host) ? "127.0.0.1" : this.host;
    return `http://${host}:${this.port}`;
  }
  /**
   * hack into router methods to make sure that koa middlewares are disposable
   */
  register(...args) {
    const layer = super.register(...args);
    const context = this[import_cordis.Context.current];
    context == null ? void 0 : context.state.disposables.push(() => {
      (0, import_cosmokit.remove)(this.stack, layer);
    });
    return layer;
  }
  ws(path, callback) {
    const layer = new WebSocketLayer(this, path, callback);
    this.wsStack.push(layer);
    const context = this[import_cordis.Context.current];
    context == null ? void 0 : context.state.disposables.push(() => layer.close());
    return layer;
  }
};
__name(_Router, "Router");
var Router = _Router;
((Router2) => {
  Router2.Config = import_schemastery.default.object({
    host: import_schemastery.default.string().default("127.0.0.1").description("要监听的 IP 地址。如果将此设置为 `0.0.0.0` 将监听所有地址，包括局域网和公网地址。"),
    port: import_schemastery.default.natural().max(65535).description("要监听的初始端口号。"),
    maxPort: import_schemastery.default.natural().max(65535).description("允许监听的最大端口号。"),
    selfUrl: import_schemastery.default.string().role("link").description("应用暴露在公网的地址。")
  });
})(Router || (Router = {}));
var src_default = Router;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Router,
  WebSocketLayer
});
//# sourceMappingURL=index.cjs.map
