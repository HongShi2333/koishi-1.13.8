var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/shared.ts
import { Context as Context2 } from "@cordisjs/core";
import { isNullable as isNullable2, valueMap } from "cosmokit";

// src/utils.ts
var evaluate = new Function("context", "expr", `
  try {
    with (context) {
      return eval(expr)
    }
  } catch {}
`);
function interpolate(template, context, pattern = /\{\{([\s\S]+?)\}\}/g) {
  let capture;
  let result = "", lastIndex = 0;
  while (capture = pattern.exec(template)) {
    if (capture[0] === template) {
      return evaluate(context, capture[1]);
    }
    result += template.slice(lastIndex, capture.index);
    result += evaluate(context, capture[1]) ?? "";
    lastIndex = capture.index + capture[0].length;
  }
  return result + template.slice(lastIndex);
}
__name(interpolate, "interpolate");

// src/entry.ts
import { Context } from "@cordisjs/core";
import { isNullable } from "cosmokit";
function swap(target, source) {
  for (const key of Reflect.ownKeys(target)) {
    Reflect.deleteProperty(target, key);
  }
  for (const key of Reflect.ownKeys(source || {})) {
    Reflect.defineProperty(target, key, Reflect.getOwnPropertyDescriptor(source, key));
  }
}
__name(swap, "swap");
function takeEntries(object, keys) {
  const result = [];
  for (const key of keys) {
    if (!(key in object))
      continue;
    result.push([key, object[key]]);
    delete object[key];
  }
  return result;
}
__name(takeEntries, "takeEntries");
function sortKeys(object, prepend = ["id", "name"], append = ["config"]) {
  const part1 = takeEntries(object, prepend);
  const part2 = takeEntries(object, append);
  const rest = takeEntries(object, Object.keys(object)).sort(([a], [b]) => a.localeCompare(b));
  return Object.assign(object, Object.fromEntries([...part1, ...rest, ...part2]));
}
__name(sortKeys, "sortKeys");
var Entry = class _Entry {
  constructor(loader, parent) {
    this.loader = loader;
    this.parent = parent;
  }
  static {
    __name(this, "Entry");
  }
  static key = Symbol("cordis.entry");
  fork;
  suspend = false;
  options;
  children;
  resolveRealm(label) {
    if (label === true) {
      return "#" + this.options.id;
    } else {
      return "@" + label;
    }
  }
  patch(ctx, ref = ctx) {
    const newMap = Object.create(Object.getPrototypeOf(ref[Context.isolate]));
    for (const [key, label] of Object.entries(this.options.isolate ?? {})) {
      const realm = this.resolveRealm(label);
      newMap[key] = (this.loader.realms[realm] ??= /* @__PURE__ */ Object.create(null))[key] ??= Symbol(`${key}${realm}`);
    }
    const diff = [];
    const oldMap = ctx[Context.isolate];
    for (const key in { ...oldMap, ...newMap, ...this.loader.delims }) {
      if (newMap[key] === oldMap[key])
        continue;
      const delim = this.loader.delims[key] ??= Symbol(key);
      ctx[delim] = Symbol(`${key}#${this.options.id}`);
      for (const symbol of [oldMap[key], newMap[key]]) {
        const value = symbol && ctx[symbol];
        if (!(value instanceof Object))
          continue;
        const source = Reflect.getOwnPropertyDescriptor(value, Context.origin)?.value;
        if (!source) {
          ctx.emit("internal/warning", new Error(`expected service ${key} to be implemented`));
          continue;
        }
        diff.push([key, oldMap[key], newMap[key], ctx[delim], source[delim]]);
        if (ctx[delim] !== source[delim])
          break;
      }
    }
    for (const [key, symbol1, symbol2, flag1, flag2] of diff) {
      const self = Object.create(ctx);
      self[Context.filter] = (target) => {
        if (![symbol1, symbol2].includes(target[Context.isolate][key]))
          return false;
        return flag1 === target[this.loader.delims[key]] !== (flag1 === flag2);
      };
      ctx.emit(self, "internal/before-service", key);
    }
    if (ctx === ref) {
      swap(ctx[Context.isolate], newMap);
      swap(ctx[Context.intercept], this.options.intercept);
      this.fork?.update(this.options.config);
    } else {
      Object.setPrototypeOf(ctx, Object.getPrototypeOf(ref));
      swap(ctx, ref);
    }
    for (const [, symbol1, symbol2, flag1, flag2] of diff) {
      if (flag1 === flag2 && ctx[symbol1] && !ctx[symbol2]) {
        ctx.root[symbol2] = ctx.root[symbol1];
        delete ctx.root[symbol1];
      }
    }
    for (const [key, symbol1, symbol2, flag1, flag2] of diff) {
      const self = Object.create(ctx);
      self[Context.filter] = (target) => {
        if (![symbol1, symbol2].includes(target[Context.isolate][key]))
          return false;
        return flag1 === target[this.loader.delims[key]] !== (flag1 === flag2);
      };
      ctx.emit(self, "internal/service", key);
    }
    for (const key in this.loader.delims) {
      if (!Reflect.ownKeys(newMap).includes(key)) {
        delete ctx[this.loader.delims[key]];
      }
    }
  }
  createContext() {
    return this.parent.ctx.extend({
      [Context.intercept]: Object.create(this.parent.ctx[Context.intercept]),
      [Context.isolate]: Object.create(this.parent.ctx[Context.isolate])
    });
  }
  get requiredInjects() {
    return Array.isArray(this.options.inject) ? this.options.inject : this.options.inject?.required ?? [];
  }
  get optionalInjects() {
    return Array.isArray(this.options.inject) ? this.options.inject : [
      ...this.options.inject?.required ?? [],
      ...this.options.inject?.optional ?? []
    ];
  }
  _check() {
    if (!this.loader.isTruthyLike(this.options.when))
      return false;
    if (this.options.disabled)
      return false;
    for (const name of this.requiredInjects) {
      let key = this.parent.ctx[Context.isolate][name];
      const label = this.options.isolate?.[name];
      if (label) {
        const realm = this.resolveRealm(label);
        key = (this.loader.realms[realm] ?? /* @__PURE__ */ Object.create(null))[name] ?? Symbol(`${name}${realm}`);
      }
      if (!key || isNullable(this.parent.ctx[key]))
        return false;
    }
    return true;
  }
  async checkService(name) {
    if (!this.requiredInjects.includes(name))
      return;
    const ready = this._check();
    if (ready && !this.fork) {
      await this.start();
    } else if (!ready && this.fork) {
      await this.stop();
    }
  }
  async update(options) {
    const legacy = this.options;
    this.options = sortKeys(options);
    if (!this._check()) {
      await this.stop();
    } else if (this.fork) {
      this.suspend = true;
      for (const [key, label] of Object.entries(legacy.isolate ?? {})) {
        if (this.options.isolate?.[key] === label)
          continue;
        const name = this.resolveRealm(label);
        this.loader._clearRealm(key, name);
      }
      this.patch(this.fork.parent);
    } else {
      await this.start();
    }
  }
  async start() {
    const ctx = this.createContext();
    const exports = await this.loader.import(this.options.name, this.parent.url).catch((error) => {
      ctx.emit("internal/error", new Error(`Cannot find package "${this.options.name}"`));
      ctx.emit("internal/error", error);
    });
    if (!exports)
      return;
    const plugin = this.loader.unwrapExports(exports);
    this.patch(ctx);
    ctx[_Entry.key] = this;
    this.fork = ctx.plugin(plugin, this.options.config);
    ctx.emit("loader/entry", "apply", this);
  }
  async stop() {
    this.fork?.dispose();
    this.fork = void 0;
    for (const [key, label] of Object.entries(this.options.isolate ?? {})) {
      const name = this.resolveRealm(label);
      this.loader._clearRealm(key, name);
    }
  }
};

// src/file.ts
import { dirname, extname, resolve } from "node:path";
import { access, constants, readdir, readFile, stat, writeFile } from "node:fs/promises";
import { fileURLToPath, pathToFileURL } from "node:url";
import * as yaml from "js-yaml";

// src/group.ts
var BaseGroup = class {
  constructor(ctx) {
    this.ctx = ctx;
    ctx.on("dispose", () => this.stop());
  }
  static {
    __name(this, "BaseGroup");
  }
  data = [];
  url;
  async _create(options) {
    const id = this.ctx.loader.ensureId(options);
    const entry = this.ctx.loader.entries[id] ??= new Entry(this.ctx.loader, this);
    entry.parent = this;
    await entry.update(options);
    return id;
  }
  _unlink(options) {
    const config = this.data;
    const index = config.indexOf(options);
    if (index >= 0)
      config.splice(index, 1);
  }
  _remove(id) {
    const entry = this.ctx.loader.entries[id];
    if (!entry)
      return;
    entry.stop();
    this._unlink(entry.options);
    delete this.ctx.loader.entries[id];
  }
  _update(config) {
    const oldConfig = this.data;
    this.data = config;
    const oldMap = Object.fromEntries(oldConfig.map((options) => [options.id, options]));
    const newMap = Object.fromEntries(config.map((options) => [options.id ?? Symbol("anonymous"), options]));
    for (const id of Reflect.ownKeys({ ...oldMap, ...newMap })) {
      if (newMap[id]) {
        this._create(newMap[id]).catch((error) => {
          this.ctx.emit("internal/error", error);
        });
      } else {
        this._remove(id);
      }
    }
  }
  write() {
    return this.ctx.scope.entry.parent.write();
  }
  stop() {
    for (const options of this.data) {
      this._remove(options.id);
    }
  }
};
var kGroup = Symbol.for("cordis.group");
function defineGroup(config, options = {}) {
  options.initial = config;
  class Group2 extends BaseGroup {
    constructor(ctx) {
      super(ctx);
      this.ctx = ctx;
      this.url = ctx.scope.entry.parent.url;
      ctx.scope.entry.children = this;
      ctx.accept((config2) => {
        this._update(config2);
      }, { passive: true, immediate: true });
    }
    static {
      __name(this, "Group");
    }
    static reusable = true;
    static [kGroup] = options;
  }
  return Group2;
}
__name(defineGroup, "defineGroup");
var Group = defineGroup();

// src/file.ts
import { remove } from "cosmokit";
var LoaderFile = class {
  constructor(loader, name, type) {
    this.loader = loader;
    this.name = name;
    this.type = type;
    this.url = pathToFileURL(name).href;
    loader.files[this.url] = this;
    this.readonly = !type;
  }
  static {
    __name(this, "LoaderFile");
  }
  suspend = false;
  readonly;
  url;
  groups = [];
  _writeTask;
  ref(group) {
    this.groups.push(group);
    group.url = pathToFileURL(this.name).href;
  }
  unref(group) {
    remove(this.groups, group);
    if (this.groups.length)
      return;
    clearTimeout(this._writeTask);
    delete this.loader.files[this.url];
  }
  async checkAccess() {
    if (!this.type)
      return;
    try {
      await access(this.name, constants.W_OK);
    } catch {
      this.readonly = true;
    }
  }
  async read() {
    if (this.type === "application/yaml") {
      return yaml.load(await readFile(this.name, "utf8"));
    } else if (this.type === "application/json") {
      return JSON.parse(await readFile(this.name, "utf8"));
    } else {
      const module = await import(this.name);
      return module.default || module;
    }
  }
  async _write(config) {
    this.suspend = true;
    if (this.readonly) {
      throw new Error(`cannot overwrite readonly config`);
    }
    if (this.type === "application/yaml") {
      await writeFile(this.name, yaml.dump(config));
    } else if (this.type === "application/json") {
      await writeFile(this.name, JSON.stringify(config, null, 2));
    }
  }
  write(config) {
    this.loader.ctx.emit("config");
    clearTimeout(this._writeTask);
    this._writeTask = setTimeout(() => {
      this._writeTask = void 0;
      this._write(config);
    }, 0);
  }
};
((LoaderFile3) => {
  LoaderFile3.writable = {
    ".json": "application/json",
    ".yaml": "application/yaml",
    ".yml": "application/yaml"
  };
  LoaderFile3.supported = new Set(Object.keys(LoaderFile3.writable));
  if (typeof __require !== "undefined") {
    for (const extname2 in __require.extensions) {
      LoaderFile3.supported.add(extname2);
    }
  }
})(LoaderFile || (LoaderFile = {}));
var ImportGroup = class extends BaseGroup {
  constructor(ctx) {
    super(ctx);
    this.ctx = ctx;
    ctx.on("ready", () => this.start());
  }
  static {
    __name(this, "ImportGroup");
  }
  static reusable = true;
  file;
  async start() {
    await this.refresh();
    await this.file.checkAccess();
  }
  async refresh() {
    this._update(await this.file.read());
  }
  stop() {
    this.file?.unref(this);
    return super.stop();
  }
  write() {
    return this.file.write(this.data);
  }
  _createFile(filename, type) {
    this.file = this.ctx.loader[filename] ??= new LoaderFile(this.ctx.loader, filename, type);
    this.file.ref(this);
  }
  async init(baseDir, options) {
    if (options.filename) {
      const filename = resolve(baseDir, options.filename);
      const stats = await stat(filename);
      if (stats.isFile()) {
        baseDir = dirname(filename);
        const ext = extname(filename);
        const type = LoaderFile.writable[ext];
        if (!LoaderFile.supported.has(ext)) {
          throw new Error(`extension "${ext}" not supported`);
        }
        this._createFile(filename, type);
      } else {
        baseDir = filename;
        await this._init(baseDir, options);
      }
    } else {
      await this._init(baseDir, options);
    }
    this.ctx.provide("baseDir", baseDir, true);
  }
  async _init(baseDir, options) {
    const { name, initial } = options;
    const dirents = await readdir(baseDir, { withFileTypes: true });
    for (const extension of LoaderFile.supported) {
      const dirent = dirents.find((dirent2) => dirent2.name === name + extension);
      if (!dirent)
        continue;
      if (!dirent.isFile()) {
        throw new Error(`config file "${dirent.name}" is not a file`);
      }
      const type = LoaderFile.writable[extension];
      const filename = resolve(baseDir, name + extension);
      this._createFile(filename, type);
      return;
    }
    if (initial) {
      const type = LoaderFile.writable[".yml"];
      const filename = resolve(baseDir, name + ".yml");
      this._createFile(filename, type);
      return this.file.write(initial);
    }
    throw new Error("config file not found");
  }
};
var Import = class extends ImportGroup {
  constructor(ctx, config) {
    super(ctx);
    this.config = config;
  }
  static {
    __name(this, "Import");
  }
  async start() {
    const { url } = this.config;
    const filename = fileURLToPath(new URL(url, this.ctx.scope.entry.parent.url));
    const ext = extname(filename);
    if (!LoaderFile.supported.has(ext)) {
      throw new Error(`extension "${ext}" not supported`);
    }
    this._createFile(filename, LoaderFile.writable[ext]);
    await super.start();
  }
};

// src/shared.ts
var Loader = class extends ImportGroup {
  constructor(ctx, config) {
    super(ctx);
    this.ctx = ctx;
    this.config = config;
    const self = this;
    this.ctx.set("loader", this);
    this.realms["#"] = ctx.root[Context2.isolate];
    this.ctx.on("internal/update", (fork) => {
      if (!fork.entry)
        return;
      fork.parent.emit("loader/entry", "reload", fork.entry);
    });
    this.ctx.on("internal/before-update", (fork, config2) => {
      if (!fork.entry)
        return;
      if (fork.entry.suspend)
        return fork.entry.suspend = false;
      const { schema } = fork.runtime;
      fork.entry.options.config = schema ? schema.simplify(config2) : config2;
      fork.entry.parent.write();
    });
    this.ctx.on("internal/fork", (fork) => {
      if (fork.parent[Entry.key]) {
        fork.entry = fork.parent[Entry.key];
        delete fork.parent[Entry.key];
      }
      if (fork.uid || !fork.entry)
        return;
      if (!this.ctx.registry.has(fork.runtime.plugin))
        return;
      fork.parent.emit("loader/entry", "unload", fork.entry);
      fork.entry.options.disabled = true;
      fork.entry.fork = void 0;
      fork.entry.stop();
      fork.entry.parent.write();
    });
    this.ctx.on("internal/before-service", function(name) {
      for (const entry of Object.values(self.entries)) {
        entry.checkService(name);
      }
    }, { global: true });
    this.ctx.on("internal/service", function(name) {
      for (const entry of Object.values(self.entries)) {
        entry.checkService(name);
      }
    }, { global: true });
    const checkInject = /* @__PURE__ */ __name((scope, name) => {
      if (!scope.runtime.plugin)
        return false;
      if (scope.runtime === scope) {
        return scope.runtime.children.every((fork) => checkInject(fork, name));
      }
      if (scope.entry?.optionalInjects.includes(name))
        return true;
      return checkInject(scope.parent.scope, name);
    }, "checkInject");
    this.ctx.on("internal/inject", function(name) {
      return checkInject(this.scope, name);
    });
  }
  static {
    __name(this, "Loader");
  }
  // TODO auto inject optional when provided?
  static inject = {
    optional: ["loader"]
  };
  // process
  envData = process.env.CORDIS_SHARED ? JSON.parse(process.env.CORDIS_SHARED) : { startTime: Date.now() };
  params = {
    env: process.env
  };
  files = /* @__PURE__ */ Object.create(null);
  entries = /* @__PURE__ */ Object.create(null);
  realms = /* @__PURE__ */ Object.create(null);
  delims = /* @__PURE__ */ Object.create(null);
  internal;
  async start() {
    await this.init(process.cwd(), this.config);
    await super.start();
  }
  interpolate(source) {
    if (typeof source === "string") {
      return interpolate(source, this.params, /\$\{\{(.+?)\}\}/g);
    } else if (!source || typeof source !== "object") {
      return source;
    } else if (Array.isArray(source)) {
      return source.map((item) => this.interpolate(item));
    } else {
      return valueMap(source, (item) => this.interpolate(item));
    }
  }
  isTruthyLike(expr) {
    if (isNullable2(expr))
      return true;
    return !!this.interpolate(`\${{ ${expr} }}`);
  }
  ensureId(options) {
    if (!options.id) {
      do {
        options.id = Math.random().toString(36).slice(2, 8);
      } while (this.entries[options.id]);
    }
    return options.id;
  }
  async update(id, options) {
    const entry = this.entries[id];
    if (!entry)
      throw new Error(`entry ${id} not found`);
    const override = { ...entry.options };
    for (const [key, value] of Object.entries(options)) {
      if (isNullable2(value)) {
        delete override[key];
      } else {
        override[key] = value;
      }
    }
    entry.parent.write();
    return entry.update(override);
  }
  resolveGroup(id) {
    const group = id ? this.entries[id]?.children : this;
    if (!group)
      throw new Error(`entry ${id} not found`);
    return group;
  }
  async create(options, parent = null, position = Infinity) {
    const group = this.resolveGroup(parent);
    group.data.splice(position, 0, options);
    group.write();
    return group._create(options);
  }
  remove(id) {
    const entry = this.entries[id];
    if (!entry)
      throw new Error(`entry ${id} not found`);
    entry.parent._remove(id);
    entry.parent.write();
  }
  transfer(id, parent, position = Infinity) {
    const entry = this.entries[id];
    if (!entry)
      throw new Error(`entry ${id} not found`);
    const source = entry.parent;
    const target = this.resolveGroup(parent);
    source._unlink(entry.options);
    target.data.splice(position, 0, entry.options);
    source.write();
    target.write();
    if (source === target)
      return;
    entry.parent = target;
    if (!entry.fork)
      return;
    const ctx = entry.createContext();
    entry.patch(entry.fork.parent, ctx);
  }
  locate(ctx = this[Context2.current]) {
    return this._locate(ctx.scope).map((entry) => entry.options.id);
  }
  _locate(scope) {
    if (!scope.runtime.plugin)
      return [];
    if (scope.runtime === scope) {
      return scope.runtime.children.flatMap((child) => this._locate(child));
    }
    if (scope.entry)
      return [scope.entry];
    return this._locate(scope.parent.scope);
  }
  async import(name, baseURL = this.url) {
    if (this.internal) {
      return this.internal.import(name, baseURL, {});
    } else {
      return import(name);
    }
  }
  exit() {
  }
  unwrapExports(exports) {
    if (isNullable2(exports))
      return exports;
    exports = exports.default ?? exports;
    if (!exports.__esModule)
      return exports;
    return exports.default ?? exports;
  }
  _clearRealm(key, name) {
    const hasRef = Object.values(this.entries).some((entry) => {
      if (!entry.fork)
        return false;
      const label = entry.options.isolate?.[key];
      if (!label)
        return false;
      return name === entry.resolveRealm(label);
    });
    if (hasRef)
      return;
    delete this.realms[name][key];
    if (!Object.keys(this.realms[name]).length) {
      delete this.realms[name];
    }
  }
};
var shared_default = Loader;
export {
  BaseGroup,
  Entry,
  Group,
  Import,
  ImportGroup,
  Loader,
  LoaderFile,
  shared_default as default,
  defineGroup,
  kGroup
};
//# sourceMappingURL=shared.js.map
