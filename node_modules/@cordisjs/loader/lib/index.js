var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/shared.ts
import { Context as Context2, Service } from "@cordisjs/core";
import { defineProperty, isNullable, valueMap } from "cosmokit";
import { constants, promises as fs } from "fs";

// src/utils.ts
var evaluate = new Function("context", "expr", `
  try {
    with (context) {
      return eval(expr)
    }
  } catch {}
`);
function interpolate(template, context, pattern = /\{\{([\s\S]+?)\}\}/g) {
  let capture;
  let result = "", lastIndex = 0;
  while (capture = pattern.exec(template)) {
    if (capture[0] === template) {
      return evaluate(context, capture[1]);
    }
    result += template.slice(lastIndex, capture.index);
    result += evaluate(context, capture[1]) ?? "";
    lastIndex = capture.index + capture[0].length;
  }
  return result + template.slice(lastIndex);
}
__name(interpolate, "interpolate");

// src/entry.ts
import { Context } from "@cordisjs/core";
function swapAssign(target, source) {
  const result = { ...target };
  for (const key in result) {
    delete target[key];
  }
  Object.assign(target, source);
  return result;
}
__name(swapAssign, "swapAssign");
var Entry = class {
  constructor(loader, parent, options) {
    this.loader = loader;
    this.parent = parent;
    this.options = options;
  }
  static {
    __name(this, "Entry");
  }
  fork = null;
  isUpdate = false;
  amend(ctx) {
    swapAssign(ctx[Context.intercept], this.options.intercept);
    const neoMap = Object.create(Object.getPrototypeOf(ctx[Context.isolate]));
    for (const [key, label] of Object.entries(this.options.isolate ?? {})) {
      if (typeof label === "string") {
        neoMap[key] = (this.loader.realms[label] ??= /* @__PURE__ */ Object.create(null))[key] ??= Symbol(key);
      } else if (label) {
        neoMap[key] = Symbol(key);
      }
    }
    for (const key in { ...ctx[Context.isolate], ...neoMap }) {
      if (neoMap[key] === ctx[Context.isolate][key])
        continue;
      const self = /* @__PURE__ */ Object.create(null);
      self[Context.filter] = (ctx2) => {
        return ctx[Context.isolate][key] === ctx2[Context.isolate][key];
      };
      ctx.emit(self, "internal/before-service", key);
    }
    const oldMap = swapAssign(ctx[Context.isolate], neoMap);
    for (const key in { ...oldMap, ...ctx[Context.isolate] }) {
      if (oldMap[key] === ctx[Context.isolate][key])
        continue;
      const self = /* @__PURE__ */ Object.create(null);
      self[Context.filter] = (ctx2) => {
        return ctx[Context.isolate][key] === ctx2[Context.isolate][key];
      };
      ctx.emit(self, "internal/service", key);
    }
  }
  // TODO: handle parent change
  update(parent, options) {
    this.options = options;
    if (!this.loader.isTruthyLike(options.when) || options.disabled) {
      this.stop();
    } else {
      this.start();
    }
  }
  async start() {
    if (this.fork) {
      this.isUpdate = true;
      this.amend(this.fork.parent);
      this.fork.update(this.options.config);
    } else {
      this.parent.emit("loader/entry", "apply", this);
      const plugin = await this.loader.resolve(this.options.name);
      if (!plugin)
        return;
      const ctx = this.parent.extend({
        [Context.intercept]: Object.create(this.parent[Context.intercept]),
        [Context.isolate]: Object.create(this.parent[Context.isolate])
      });
      this.amend(ctx);
      this.fork = ctx.plugin(plugin, this.loader.interpolate(this.options.config));
      this.fork.entry = this;
    }
  }
  stop() {
    if (!this.fork)
      return;
    this.parent.emit("loader/entry", "unload", this);
    this.fork.dispose();
    this.fork = null;
  }
};

// src/shared.ts
import * as yaml from "js-yaml";
import * as path from "path";
var writable = {
  ".json": "application/json",
  ".yaml": "application/yaml",
  ".yml": "application/yaml"
};
var supported = new Set(Object.keys(writable));
if (typeof __require !== "undefined") {
  for (const extname2 in __require.extensions) {
    supported.add(extname2);
  }
}
var Loader = class extends Service {
  constructor(app, options) {
    super(app, "loader", true);
    this.app = app;
    this.options = options;
    this.entryFork = this.app.plugin(group, []);
    this.realms.root = app.root[Context2.isolate];
    this.app.on("dispose", () => {
      this.exit();
    });
    this.app.on("internal/update", (fork) => {
      const entry = this.entries[fork.entry?.options.id];
      if (!entry)
        return;
      fork.parent.emit("loader/entry", "reload", entry);
    });
    this.app.on("internal/before-update", (fork, config) => {
      if (!fork.entry)
        return;
      if (fork.entry.isUpdate)
        return fork.entry.isUpdate = false;
      const { schema } = fork.runtime;
      fork.entry.options.config = schema ? schema.simplify(config) : config;
      this.writeConfig();
    });
    this.app.on("internal/fork", (fork) => {
      if (fork.uid || !fork.entry)
        return;
      fork.parent.emit("loader/entry", "unload", fork.entry);
      if (!this.app.registry.has(fork.runtime.plugin))
        return;
      fork.entry.options.disabled = true;
      this.writeConfig();
    });
  }
  static {
    __name(this, "Loader");
  }
  // process
  baseDir = process.cwd();
  envData = process.env.CORDIS_SHARED ? JSON.parse(process.env.CORDIS_SHARED) : { startTime: Date.now() };
  params = {
    env: process.env
  };
  entryFork;
  suspend = false;
  writable = false;
  mimeType;
  filename;
  entries = /* @__PURE__ */ Object.create(null);
  realms = /* @__PURE__ */ Object.create(null);
  tasks = /* @__PURE__ */ new Set();
  async init(filename) {
    if (filename) {
      filename = path.resolve(this.baseDir, filename);
      const stats = await fs.stat(filename);
      if (stats.isFile()) {
        this.filename = filename;
        this.baseDir = path.dirname(filename);
        const extname2 = path.extname(filename);
        this.mimeType = writable[extname2];
        if (!supported.has(extname2)) {
          throw new Error(`extension "${extname2}" not supported`);
        }
      } else {
        this.baseDir = filename;
        await this.findConfig();
      }
    } else {
      await this.findConfig();
    }
    if (this.mimeType && !this.options.immutable) {
      try {
        await fs.access(this.filename, constants.W_OK);
        this.writable = true;
      } catch {
      }
    }
    this.app.provide("baseDir", this.baseDir, true);
  }
  async findConfig() {
    const files = await fs.readdir(this.baseDir);
    for (const extension of supported) {
      const filename = this.options.name + extension;
      if (files.includes(filename)) {
        this.mimeType = writable[extension];
        this.filename = path.resolve(this.baseDir, filename);
        return;
      }
    }
    if (this.options.fallback) {
      const { config, extension = ".yml" } = this.options.fallback;
      this.config = config;
      this.mimeType = writable[extension];
      this.filename = path.resolve(this.baseDir, this.options.name + extension);
      return this.writeConfig(true);
    }
    throw new Error("config file not found");
  }
  async readConfig() {
    if (this.mimeType === "application/yaml") {
      this.config = yaml.load(await fs.readFile(this.filename, "utf8"));
    } else if (this.mimeType === "application/json") {
      this.config = JSON.parse(await fs.readFile(this.filename, "utf8"));
    } else {
      const module = await import(this.filename);
      this.config = module.default || module;
    }
    return this.config;
  }
  async writeConfig(silent = false) {
    this.suspend = true;
    if (!this.writable) {
      throw new Error(`cannot overwrite readonly config`);
    }
    if (this.mimeType === "application/yaml") {
      await fs.writeFile(this.filename, yaml.dump(this.config));
    } else if (this.mimeType === "application/json") {
      await fs.writeFile(this.filename, JSON.stringify(this.config, null, 2));
    }
    if (!silent)
      this.app.emit("config");
  }
  interpolate(source) {
    if (typeof source === "string") {
      return interpolate(source, this.params, /\$\{\{(.+?)\}\}/g);
    } else if (!source || typeof source !== "object") {
      return source;
    } else if (Array.isArray(source)) {
      return source.map((item) => this.interpolate(item));
    } else {
      return valueMap(source, (item) => this.interpolate(item));
    }
  }
  async resolve(name) {
    const task = this.import(name);
    this.tasks.add(task);
    task.finally(() => this.tasks.delete(task));
    return this.unwrapExports(await task);
  }
  isTruthyLike(expr) {
    if (isNullable(expr))
      return true;
    return !!this.interpolate(`\${{ ${expr} }}`);
  }
  async update(parent, options) {
    if (!options.id) {
      do {
        options.id = Math.random().toString(36).slice(2, 8);
      } while (this.entries[options.id]);
    }
    const entry = this.entries[options.id] ??= new Entry(this, parent, options);
    entry.update(parent, options);
  }
  remove(parent, options) {
    const entry = this.entries[options.id];
    if (!entry)
      return;
    entry.stop();
    delete this.entries[options.id];
  }
  paths(scope) {
    if (scope === scope.parent.scope)
      return [];
    if (scope.runtime === scope) {
      return [].concat(...scope.runtime.children.map((child) => this.paths(child)));
    }
    if (scope.entry)
      return [scope.entry.options.id];
    return this.paths(scope.parent.scope);
  }
  async start() {
    await this.readConfig();
    this.entryFork.update(this.config);
    this.app.emit("config");
    while (this.tasks.size) {
      await Promise.all(this.tasks);
    }
  }
  unwrapExports(module) {
    return module?.default || module;
  }
  exit() {
  }
};
function group(ctx, config) {
  for (const entry of config) {
    ctx.loader.update(ctx, entry);
  }
  ctx.accept((neo) => {
    const old = ctx.scope.config;
    const oldMap = Object.fromEntries(old.map((entry) => [entry.id || Symbol("anonymous"), entry]));
    const neoMap = Object.fromEntries(neo.map((entry) => [entry.id || Symbol("anonymous"), entry]));
    for (const id of Reflect.ownKeys({ ...oldMap, ...neoMap })) {
      if (!neoMap[id]) {
        ctx.loader.remove(ctx, oldMap[id]);
      } else {
        ctx.loader.update(ctx, neoMap[id]);
      }
    }
  }, { passive: true });
  ctx.on("dispose", () => {
    for (const entry of ctx.scope.config) {
      ctx.loader.remove(ctx, entry);
    }
  });
}
__name(group, "group");
defineProperty(group, "inject", ["loader"]);
defineProperty(group, "reusable", true);
var shared_default = Loader;

// src/index.ts
import { promises as fs2 } from "fs";
import * as dotenv from "dotenv";
import * as path2 from "path";
var oldEnv = { ...process.env };
var NodeLoader = class _NodeLoader extends shared_default {
  static {
    __name(this, "NodeLoader");
  }
  static exitCode = 51;
  async readConfig() {
    for (const key in process.env) {
      if (key in oldEnv) {
        process.env[key] = oldEnv[key];
      } else {
        delete process.env[key];
      }
    }
    const override = {};
    const envFiles = [".env", ".env.local"];
    for (const filename of envFiles) {
      try {
        const raw = await fs2.readFile(path2.resolve(this.baseDir, filename), "utf8");
        Object.assign(override, dotenv.parse(raw));
      } catch {
      }
    }
    for (const key in override) {
      process.env[key] = override[key];
    }
    return await super.readConfig();
  }
  async import(name) {
    try {
      return await import(name);
    } catch (err) {
      this.app.emit("internal/error", err);
    }
  }
  exit(code = _NodeLoader.exitCode) {
    const body = JSON.stringify(this.envData);
    process.send?.({ type: "shared", body }, (err) => {
      if (err)
        this.app.emit("internal/error", "failed to send shared data");
      this.app.emit("internal/info", "trigger full reload");
      process.exit(code);
    });
  }
};
var src_default = NodeLoader;
export {
  Loader,
  src_default as default,
  group
};
//# sourceMappingURL=index.js.map
