import { LoadHookContext } from 'module';
import { Dict } from 'cosmokit';
import { Context, EffectScope, ForkScope, Inject } from '@cordisjs/core';
type ModuleFormat = 'builtin' | 'commonjs' | 'json' | 'module' | 'wasm';
type ModuleSource = string | ArrayBuffer;
declare interface ResolveResult {
    format: ModuleFormat;
    url: string;
}
declare interface LoadResult {
    format: ModuleFormat;
    source?: ModuleSource;
}
type LoadCacheData = ModuleJob;
declare interface LoadCache extends Omit<Map<string, Dict<LoadCacheData>>, 'get' | 'set' | 'has'> {
    get(url: string, type?: string): LoadCacheData | undefined;
    set(url: string, type?: string, job?: LoadCacheData): this;
    has(url: string, type?: string): boolean;
}
export interface ModuleWrap {
    url: string;
    getNamespace(): any;
}
export interface ModuleJob {
    url: string;
    loader: ModuleLoader;
    module?: ModuleWrap;
    importAttributes: ImportAttributes;
    linked: Promise<ModuleJob[]>;
    instantiate(): Promise<void>;
    run(): Promise<{
        module: ModuleWrap;
    }>;
}
export interface ModuleLoader {
    loadCache: LoadCache;
    import(specifier: string, parentURL: string, importAttributes: ImportAttributes): Promise<any>;
    register(specifier: string | URL, parentURL?: string | URL, data?: any, transferList?: any[]): void;
    getModuleJob(specifier: string, parentURL: string, importAttributes: ImportAttributes): Promise<ModuleJob>;
    getModuleJobSync(specifier: string, parentURL: string, importAttributes: ImportAttributes): ModuleJob;
    resolve(originalSpecifier: string, parentURL: string, importAttributes: ImportAttributes): Promise<ResolveResult>;
    resolveSync(originalSpecifier: string, parentURL: string, importAttributes: ImportAttributes): ResolveResult;
    load(specifier: string, context: Pick<LoadHookContext, 'format' | 'importAttributes'>): Promise<LoadResult>;
    loadSync(specifier: string, context: Pick<LoadHookContext, 'format' | 'importAttributes'>): LoadResult;
}
export function interpolate(template: string, context: object, pattern?: RegExp): any;
export abstract class BaseGroup {
    ctx: Context;
    data: Entry.Options[];
    url: string;
    constructor(ctx: Context);
    _create(options: Omit<Entry.Options, 'id'>): Promise<string>;
    _unlink(options: Entry.Options): void;
    _remove(id: string): void;
    _update(config: Entry.Options[]): void;
    write(): any;
    stop(): void;
}
export const kGroup: unique symbol;
export interface GroupOptions {
    name?: string;
    initial?: Omit<Entry.Options, 'id'>[];
    allowed?: string[];
}
export function defineGroup(config?: Entry.Options[], options?: GroupOptions): {
    new (ctx: Context): {
        ctx: Context;
        data: Entry.Options[];
        url: string;
        _create(options: Omit<Entry.Options, "id">): Promise<string>;
        _unlink(options: Entry.Options): void;
        _remove(id: string): void;
        _update(config: Entry.Options[]): void;
        write(): any;
        stop(): void;
    };
    reusable: boolean;
    [kGroup]: GroupOptions;
};
export const Group: {
    new (ctx: Context): {
        ctx: Context;
        data: Entry.Options[];
        url: string;
        _create(options: Omit<Entry.Options, "id">): Promise<string>;
        _unlink(options: Entry.Options): void;
        _remove(id: string): void;
        _update(config: Entry.Options[]): void;
        write(): any;
        stop(): void;
    };
    reusable: boolean;
    [kGroup]: GroupOptions;
};
export class LoaderFile {
    loader: Loader;
    name: string;
    type?: string | undefined;
    suspend: boolean;
    readonly: boolean;
    url: string;
    groups: ImportGroup[];
    private _writeTask?;
    constructor(loader: Loader, name: string, type?: string | undefined);
    ref(group: ImportGroup): void;
    unref(group: ImportGroup): void;
    checkAccess(): Promise<void>;
    read(): Promise<Entry.Options[]>;
    private _write;
    write(config: Entry.Options[]): void;
}
export namespace LoaderFile {
    const writable: {
        '.json': string;
        '.yaml': string;
        '.yml': string;
    };
    const supported: Set<string>;
}
export class ImportGroup extends BaseGroup {
    ctx: Context;
    static reusable: boolean;
    protected file: LoaderFile;
    constructor(ctx: Context);
    start(): Promise<void>;
    refresh(): Promise<void>;
    stop(): void;
    write(): void;
    _createFile(filename: string, type: string): void;
    init(baseDir: string, options: Loader.Config): Promise<void>;
    private _init;
}
export namespace Import {
    interface Config {
        url: string;
    }
}
export class Import extends ImportGroup {
    config: Import.Config;
    constructor(ctx: Context, config: Import.Config);
    start(): Promise<void>;
}
declare module '@cordisjs/core' {
    interface Events {
        'config'(): void;
        'exit'(signal: NodeJS.Signals): Promise<void>;
        'loader/entry'(type: string, entry: Entry): void;
        'loader/patch'(entry: Entry, legacy?: Entry.Options): void;
    }
    interface Context {
        baseDir: string;
        loader: Loader;
    }
    interface EnvData {
        startTime?: number;
    }
    interface EffectScope {
        entry?: Entry;
    }
}
export namespace Loader {
    interface Config {
        name: string;
        initial?: Omit<Entry.Options, 'id'>[];
        filename?: string;
    }
}
export abstract class Loader extends ImportGroup {
    ctx: Context;
    config: Loader.Config;
    static inject: {
        optional: string[];
    };
    envData: any;
    params: {
        env: NodeJS.ProcessEnv;
    };
    files: Dict<LoaderFile>;
    entries: Dict<Entry>;
    realms: Dict<Dict<symbol>>;
    delims: Dict<symbol>;
    internal?: ModuleLoader;
    constructor(ctx: Context, config: Loader.Config);
    start(): Promise<void>;
    interpolate(source: any): any;
    isTruthyLike(expr: any): boolean;
    ensureId(options: Partial<Entry.Options>): string;
    update(id: string, options: Partial<Omit<Entry.Options, 'id' | 'name'>>): Promise<void>;
    resolveGroup(id: string | null): BaseGroup;
    create(options: Omit<Entry.Options, 'id'>, parent?: string | null, position?: number): Promise<string>;
    remove(id: string): void;
    transfer(id: string, parent: string | null, position?: number): void;
    locate(ctx?: any): string[];
    _locate(scope: EffectScope): Entry[];
    import(name: string, baseURL?: string): Promise<any>;
    exit(): void;
    unwrapExports(exports: any): any;
    _clearRealm(key: string, name: string): void;
}
export namespace Entry {
    interface Options {
        id: string;
        name: string;
        config?: any;
        disabled?: boolean | null;
        intercept?: Dict | null;
        isolate?: Dict<true | string> | null;
        inject?: string[] | Inject | null;
        when?: any;
    }
}
export class Entry {
    loader: Loader;
    parent: BaseGroup;
    static key: symbol;
    fork?: ForkScope;
    suspend: boolean;
    options: Entry.Options;
    children?: BaseGroup;
    constructor(loader: Loader, parent: BaseGroup);
    resolveRealm(label: string | true): string;
    patch(ctx: Context, ref?: Context): void;
    createContext(): Context;
    get requiredInjects(): string[];
    get optionalInjects(): string[];
    _check(): boolean;
    checkService(name: string): Promise<void>;
    update(options: Entry.Options): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
}
declare namespace NodeLoader {
    interface Config extends Loader.Config {
    }
}
declare class NodeLoader extends Loader {
    static readonly exitCode = 51;
    init(baseDir: string, options: Loader.Config): Promise<void>;
    start(): Promise<void>;
    exit(code?: number): void;
}
export default NodeLoader;
