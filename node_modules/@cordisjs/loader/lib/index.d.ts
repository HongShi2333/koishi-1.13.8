/// <reference types="node" resolution-mode="require"/>
import { Context, EffectScope, ForkScope, Service } from '@cordisjs/core';
import { Dict } from 'cosmokit';
export function interpolate(template: string, context: object, pattern?: RegExp): any;
declare module '@cordisjs/core' {
    interface Events {
        'config'(): void;
        'exit'(signal: NodeJS.Signals): Promise<void>;
        'loader/entry'(type: string, entry: Entry): void;
    }
    interface Context {
        loader: Loader;
    }
    interface EnvData {
        startTime?: number;
    }
    interface EffectScope {
        entry?: Entry;
    }
}
export namespace Loader {
    interface Options {
        name: string;
        immutable?: boolean;
        fallback?: Fallback;
    }
    interface Fallback {
        extension?: string;
        config: Omit<Entry.Options, 'id'>[];
    }
}
export abstract class Loader<T extends Loader.Options = Loader.Options> extends Service<Entry.Options[]> {
    app: Context;
    options: T;
    baseDir: string;
    envData: any;
    params: {
        env: NodeJS.ProcessEnv;
    };
    entryFork: ForkScope<Context>;
    suspend: boolean;
    writable: boolean;
    mimeType: string;
    filename: string;
    entries: Dict<Entry>;
    realms: Dict<Dict<symbol>>;
    private tasks;
    abstract import(name: string): Promise<any>;
    constructor(app: Context, options: T);
    init(filename?: string): Promise<void>;
    private findConfig;
    readConfig(): Promise<Entry.Options[]>;
    writeConfig(silent?: boolean): Promise<void>;
    interpolate(source: any): any;
    resolve(name: string): Promise<any>;
    isTruthyLike(expr: any): boolean;
    update(parent: Context, options: Entry.Options): Promise<void>;
    remove(parent: Context, options: Entry.Options): void;
    paths(scope: EffectScope): string[];
    start(): Promise<void>;
    unwrapExports(module: any): any;
    exit(): void;
}
export function group(ctx: Context, config: Entry.Options[]): void;
export namespace Entry {
    interface Options {
        id: string;
        name: string;
        config?: any;
        disabled?: boolean;
        intercept?: Dict;
        isolate?: Dict<boolean | string>;
        when?: any;
    }
}
export class Entry {
    loader: Loader;
    parent: Context;
    options: Entry.Options;
    fork: ForkScope | null;
    isUpdate: boolean;
    constructor(loader: Loader, parent: Context, options: Entry.Options);
    amend(ctx: Context): void;
    update(parent: Context, options: Entry.Options): void;
    start(): Promise<void>;
    stop(): void;
}
declare namespace NodeLoader {
    interface Options extends Loader.Options {
        type?: 'commonjs' | 'module' | 'vm-module';
    }
}
declare class NodeLoader extends Loader<NodeLoader.Options> {
    static readonly exitCode = 51;
    readConfig(): Promise<Entry.Options[]>;
    import(name: string): Promise<any>;
    exit(code?: number): void;
}
export default NodeLoader;
