var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/context.ts
import { defineProperty as defineProperty5, isNullable as isNullable2 } from "cosmokit";

// src/events.ts
import { defineProperty, remove } from "cosmokit";
function isBailed(value) {
  return value !== null && value !== false && value !== void 0;
}
__name(isBailed, "isBailed");
var Lifecycle = class {
  constructor(root) {
    this.root = root;
    defineProperty(this, Context.origin, root);
    defineProperty(this.on("internal/listener", function(name, listener, options) {
      const method = options.prepend ? "unshift" : "push";
      if (name === "ready") {
        if (!this.lifecycle.isActive)
          return;
        this.scope.ensure(async () => listener());
        return () => false;
      } else if (name === "dispose") {
        this.scope.disposables[method](listener);
        defineProperty(listener, "name", "event <dispose>");
        return () => remove(this.scope.disposables, listener);
      } else if (name === "fork") {
        this.scope.runtime.forkables[method](listener);
        return this.scope.collect("event <fork>", () => remove(this.scope.runtime.forkables, listener));
      }
    }), Context.static, root.scope);
    for (const level of ["info", "error", "warning"]) {
      defineProperty(this.on(`internal/${level}`, (format, ...param) => {
        if (this._hooks[`internal/${level}`].length > 1)
          return;
        console.info(format, ...param);
      }), Context.static, root.scope);
    }
    defineProperty(this.on("internal/before-service", function(name) {
      for (const runtime of this.registry.values()) {
        if (!runtime.using.includes(name))
          continue;
        const scopes = runtime.isReusable ? runtime.children : [runtime];
        for (const scope of scopes) {
          if (!this[symbols.filter](scope.ctx))
            continue;
          scope.updateStatus();
          scope.reset();
        }
      }
    }, { global: true }), Context.static, root.scope);
    defineProperty(this.on("internal/service", function(name) {
      for (const runtime of this.registry.values()) {
        if (!runtime.using.includes(name))
          continue;
        const scopes = runtime.isReusable ? runtime.children : [runtime];
        for (const scope of scopes) {
          if (!this[symbols.filter](scope.ctx))
            continue;
          scope.start();
        }
      }
    }, { global: true }), Context.static, root.scope);
    defineProperty(this.on("internal/inject", function(name) {
      let parent = this;
      while (parent.runtime.plugin) {
        for (const key of parent.runtime.inject) {
          if (name === Context.resolveInject(parent, key)[0])
            return true;
        }
        parent = parent.scope.parent;
      }
    }, { global: true }), Context.static, root.scope);
  }
  static {
    __name(this, "Lifecycle");
  }
  isActive = false;
  _tasks = /* @__PURE__ */ new Set();
  _hooks = {};
  async flush() {
    while (this._tasks.size) {
      await Promise.all(Array.from(this._tasks));
    }
  }
  getHooks(name, thisArg) {
    const hooks = this._hooks[name] || [];
    return hooks.slice().filter(([context, callback, options]) => {
      const filter = thisArg?.[Context.filter];
      return options.global || !filter || filter.call(thisArg, context);
    }).map(([, callback]) => callback);
  }
  prepareEvent(type, args) {
    const thisArg = typeof args[0] === "object" || typeof args[0] === "function" ? args.shift() : null;
    const name = args.shift();
    if (name !== "internal/event") {
      this.emit("internal/event", type, name, args, thisArg);
    }
    return [this.getHooks(name, thisArg), thisArg ?? this[Context.origin]];
  }
  async parallel(...args) {
    const [hooks, thisArg] = this.prepareEvent("parallel", args);
    await Promise.all(hooks.map(async (callback) => {
      await callback.apply(thisArg, args);
    }));
  }
  emit(...args) {
    const [hooks, thisArg] = this.prepareEvent("emit", args);
    for (const callback of hooks) {
      callback.apply(thisArg, args);
    }
  }
  async serial(...args) {
    const [hooks, thisArg] = this.prepareEvent("serial", args);
    for (const callback of hooks) {
      const result = await callback.apply(thisArg, args);
      if (isBailed(result))
        return result;
    }
  }
  bail(...args) {
    const [hooks, thisArg] = this.prepareEvent("bail", args);
    for (const callback of hooks) {
      const result = callback.apply(thisArg, args);
      if (isBailed(result))
        return result;
    }
  }
  register(label, hooks, listener, options) {
    const caller = this[Context.origin];
    const method = options.prepend ? "unshift" : "push";
    hooks[method]([caller, listener, options]);
    return caller.state.collect(label, () => this.unregister(hooks, listener));
  }
  unregister(hooks, listener) {
    const index = hooks.findIndex(([context, callback]) => callback === listener);
    if (index >= 0) {
      hooks.splice(index, 1);
      return true;
    }
  }
  on(name, listener, options) {
    if (typeof options !== "object") {
      options = { prepend: options };
    }
    const caller = this[Context.origin];
    caller.scope.assertActive();
    const result = this.bail(caller, "internal/listener", name, listener, options);
    if (result)
      return result;
    const hooks = this._hooks[name] ||= [];
    const label = typeof name === "string" ? `event <${name}>` : "event (Symbol)";
    return this.register(label, hooks, listener, options);
  }
  once(name, listener, options) {
    const dispose = this.on(name, function(...args) {
      dispose();
      return listener.apply(this, args);
    }, options);
    return dispose;
  }
  off(name, listener) {
    return this.unregister(this._hooks[name] || [], listener);
  }
  async start() {
    this.isActive = true;
    const hooks = this._hooks.ready || [];
    while (hooks.length) {
      const [context, callback] = hooks.shift();
      context.scope.ensure(async () => callback());
    }
    await this.flush();
  }
  async stop() {
    this.isActive = false;
    this.root.scope.reset();
  }
};

// src/registry.ts
import { defineProperty as defineProperty4 } from "cosmokit";

// src/scope.ts
import { deepEqual, defineProperty as defineProperty3, isNullable, remove as remove2 } from "cosmokit";

// src/utils.ts
import { defineProperty as defineProperty2 } from "cosmokit";
var symbols = {
  // context symbols
  origin: Symbol.for("cordis.origin"),
  events: Symbol.for("cordis.events"),
  static: Symbol.for("cordis.static"),
  filter: Symbol.for("cordis.filter"),
  expose: Symbol.for("cordis.expose"),
  isolate: Symbol.for("cordis.isolate"),
  internal: Symbol.for("cordis.internal"),
  intercept: Symbol.for("cordis.intercept"),
  // service symbols
  setup: Symbol.for("cordis.setup"),
  invoke: Symbol.for("cordis.invoke"),
  extend: Symbol.for("cordis.extend"),
  provide: Symbol.for("cordis.provide"),
  immediate: Symbol.for("cordis.immediate")
};
var GeneratorFunction = function* () {
}.constructor;
var AsyncGeneratorFunction = async function* () {
}.constructor;
function isConstructor(func) {
  if (!func.prototype)
    return false;
  if (func instanceof GeneratorFunction)
    return false;
  if (AsyncGeneratorFunction !== Function && func instanceof AsyncGeneratorFunction)
    return false;
  return true;
}
__name(isConstructor, "isConstructor");
function resolveConfig(plugin, config) {
  const schema = plugin["Config"] || plugin["schema"];
  if (schema && plugin["schema"] !== false)
    config = schema(config);
  return config ?? {};
}
__name(resolveConfig, "resolveConfig");
function isUnproxyable(value) {
  return [Map, Set, Date, Promise].some((constructor) => value instanceof constructor);
}
__name(isUnproxyable, "isUnproxyable");
function joinPrototype(proto1, proto2) {
  if (proto1 === Object.prototype)
    return proto2;
  const result = Object.create(joinPrototype(Object.getPrototypeOf(proto1), proto2));
  for (const key of Reflect.ownKeys(proto1)) {
    Object.defineProperty(result, key, Object.getOwnPropertyDescriptor(proto1, key));
  }
  return result;
}
__name(joinPrototype, "joinPrototype");
function createTraceable(ctx, value) {
  const proxy = new Proxy(value, {
    get: (target, name, receiver) => {
      if (name === symbols.origin)
        return ctx;
      return Reflect.get(target, name, receiver);
    },
    apply: (target, thisArg, args) => {
      return applyTraceable(proxy, target, thisArg, args);
    }
  });
  return proxy;
}
__name(createTraceable, "createTraceable");
function applyTraceable(proxy, value, thisArg, args) {
  if (!value[symbols.invoke])
    return Reflect.apply(value, thisArg, args);
  return value[symbols.invoke].apply(proxy, args);
}
__name(applyTraceable, "applyTraceable");
function createCallable(name, proto) {
  const self = /* @__PURE__ */ __name(function(...args) {
    const proxy = createTraceable(self[symbols.origin], self);
    return applyTraceable(proxy, self, this, args);
  }, "self");
  defineProperty2(self, "name", name);
  return Object.setPrototypeOf(self, proto);
}
__name(createCallable, "createCallable");

// src/scope.ts
var ScopeStatus = /* @__PURE__ */ ((ScopeStatus2) => {
  ScopeStatus2[ScopeStatus2["PENDING"] = 0] = "PENDING";
  ScopeStatus2[ScopeStatus2["LOADING"] = 1] = "LOADING";
  ScopeStatus2[ScopeStatus2["ACTIVE"] = 2] = "ACTIVE";
  ScopeStatus2[ScopeStatus2["FAILED"] = 3] = "FAILED";
  ScopeStatus2[ScopeStatus2["DISPOSED"] = 4] = "DISPOSED";
  return ScopeStatus2;
})(ScopeStatus || {});
var CordisError = class _CordisError extends Error {
  constructor(code, message) {
    super(message ?? _CordisError.Code[code]);
    this.code = code;
  }
  static {
    __name(this, "CordisError");
  }
};
((CordisError2) => {
  CordisError2.Code = {
    INACTIVE_EFFECT: "cannot create effect on inactive context"
  };
})(CordisError || (CordisError = {}));
var EffectScope = class {
  constructor(parent, config) {
    this.parent = parent;
    this.config = config;
    this.uid = parent.registry ? parent.registry.counter : 0;
    this.ctx = this.context = parent.extend({ scope: this });
    this.proxy = new Proxy({}, {
      get: (target, key) => Reflect.get(this.config, key)
    });
  }
  static {
    __name(this, "EffectScope");
  }
  uid;
  ctx;
  disposables = [];
  error;
  status = 0 /* PENDING */;
  isActive = false;
  // Same as `this.ctx`, but with a more specific type.
  context;
  proxy;
  acceptors = [];
  tasks = /* @__PURE__ */ new Set();
  hasError = false;
  get _config() {
    return this.runtime.isReactive ? this.proxy : this.config;
  }
  assertActive() {
    if (this.uid !== null || this.isActive)
      return;
    throw new CordisError("INACTIVE_EFFECT");
  }
  effect(callback, config) {
    this.assertActive();
    const result = isConstructor(callback) ? new callback(this.ctx, config) : callback(this.ctx, config);
    let disposed = false;
    const original = typeof result === "function" ? result : result.dispose.bind(result);
    const wrapped = /* @__PURE__ */ __name((...args) => {
      if (disposed)
        return;
      disposed = true;
      remove2(this.disposables, wrapped);
      return original(...args);
    }, "wrapped");
    this.disposables.push(wrapped);
    if (typeof result === "function")
      return wrapped;
    result.dispose = wrapped;
    return result;
  }
  collect(label, callback) {
    const dispose = defineProperty3(() => {
      remove2(this.disposables, dispose);
      return callback();
    }, "name", label);
    this.disposables.push(dispose);
    return dispose;
  }
  restart() {
    this.reset();
    this.error = null;
    this.hasError = false;
    this.status = 0 /* PENDING */;
    this.start();
  }
  _getStatus() {
    if (this.uid === null)
      return 4 /* DISPOSED */;
    if (this.hasError)
      return 3 /* FAILED */;
    if (this.tasks.size)
      return 1 /* LOADING */;
    if (this.ready)
      return 2 /* ACTIVE */;
    return 0 /* PENDING */;
  }
  updateStatus(callback) {
    const oldValue = this.status;
    callback?.();
    this.status = this._getStatus();
    if (oldValue !== this.status) {
      this.context.emit("internal/status", this, oldValue);
    }
  }
  ensure(callback) {
    const task = callback().catch((reason) => {
      this.context.emit("internal/error", reason);
      this.cancel(reason);
    }).finally(() => {
      this.updateStatus(() => this.tasks.delete(task));
      this.context.events._tasks.delete(task);
    });
    this.updateStatus(() => this.tasks.add(task));
    this.context.events._tasks.add(task);
  }
  cancel(reason) {
    this.error = reason;
    this.updateStatus(() => this.hasError = true);
    this.reset();
  }
  get ready() {
    return this.runtime.using.every((name) => !isNullable(this.ctx[name]));
  }
  reset() {
    this.isActive = false;
    this.disposables = this.disposables.splice(0).filter((dispose) => {
      if (this.uid !== null && dispose[Context.static] === this)
        return true;
      (async () => dispose())().catch((reason) => {
        this.context.emit("internal/error", reason);
      });
    });
  }
  init(error) {
    if (!this.config) {
      this.cancel(error);
    } else {
      this.start();
    }
  }
  start() {
    if (!this.ready || this.isActive || this.uid === null)
      return true;
    this.isActive = true;
    this.updateStatus(() => this.hasError = false);
  }
  accept(...args) {
    const keys = Array.isArray(args[0]) ? args.shift() : null;
    const acceptor = { keys, callback: args[0], ...args[1] };
    return this.effect(() => {
      this.acceptors.push(acceptor);
      if (acceptor.immediate)
        acceptor.callback?.(this.config);
      return () => remove2(this.acceptors, acceptor);
    });
  }
  decline(keys) {
    return this.accept(keys, () => true);
  }
  checkUpdate(resolved, forced) {
    if (forced || !this.config)
      return [true, true];
    if (forced === false)
      return [false, false];
    const modified = /* @__PURE__ */ Object.create(null);
    const checkPropertyUpdate = /* @__PURE__ */ __name((key) => {
      const result = modified[key] ??= !deepEqual(this.config[key], resolved[key]);
      hasUpdate ||= result;
      return result;
    }, "checkPropertyUpdate");
    const ignored = /* @__PURE__ */ new Set();
    let hasUpdate = false, shouldRestart = false;
    let fallback = this.runtime.isReactive || null;
    for (const { keys, callback, passive } of this.acceptors) {
      if (!keys) {
        fallback ||= !passive;
      } else if (passive) {
        keys?.forEach((key) => ignored.add(key));
      } else {
        let hasUpdate2 = false;
        for (const key of keys) {
          hasUpdate2 ||= checkPropertyUpdate(key);
        }
        if (!hasUpdate2)
          continue;
      }
      const result = callback?.(resolved);
      if (result)
        shouldRestart = true;
    }
    for (const key in { ...this.config, ...resolved }) {
      if (fallback === false)
        continue;
      if (!(key in modified) && !ignored.has(key)) {
        const hasUpdate2 = checkPropertyUpdate(key);
        if (fallback === null)
          shouldRestart ||= hasUpdate2;
      }
    }
    return [hasUpdate, shouldRestart];
  }
};
var ForkScope = class extends EffectScope {
  constructor(parent, runtime, config, error) {
    super(parent, config);
    this.runtime = runtime;
    this.dispose = defineProperty3(parent.scope.collect(`fork <${parent.runtime.name}>`, () => {
      this.uid = null;
      this.reset();
      this.context.emit("internal/fork", this);
      const result = remove2(runtime.disposables, this.dispose);
      if (remove2(runtime.children, this) && !runtime.children.length) {
        parent.registry.delete(runtime.plugin);
      }
      return result;
    }), Context.static, runtime);
    runtime.children.push(this);
    runtime.disposables.push(this.dispose);
    this.context.emit("internal/fork", this);
    this.init(error);
  }
  static {
    __name(this, "ForkScope");
  }
  dispose;
  start() {
    if (super.start())
      return true;
    for (const fork of this.runtime.forkables) {
      this.ensure(async () => fork(this.context, this._config));
    }
  }
  update(config, forced) {
    const oldConfig = this.config;
    const state = this.runtime.isForkable ? this : this.runtime;
    if (state.config !== oldConfig)
      return;
    const resolved = resolveConfig(this.runtime.plugin, config);
    const [hasUpdate, shouldRestart] = state.checkUpdate(resolved, forced);
    this.context.emit("internal/before-update", this, config);
    this.config = resolved;
    state.config = resolved;
    if (hasUpdate) {
      this.context.emit("internal/update", this, oldConfig);
    }
    if (shouldRestart)
      state.restart();
  }
};
var MainScope = class extends EffectScope {
  constructor(registry, plugin, config, error) {
    super(registry[Context.origin], config);
    this.plugin = plugin;
    registry.set(plugin, this);
    if (!plugin) {
      this.name = "root";
      this.isActive = true;
    } else {
      this.setup();
      this.init(error);
    }
  }
  static {
    __name(this, "MainScope");
  }
  value;
  runtime = this;
  schema;
  name;
  using = [];
  inject = /* @__PURE__ */ new Set();
  forkables = [];
  children = [];
  isReusable = false;
  isReactive = false;
  get isForkable() {
    return this.forkables.length > 0;
  }
  fork(parent, config, error) {
    return new ForkScope(parent, this, config, error);
  }
  dispose() {
    this.uid = null;
    this.reset();
    this.context.emit("internal/runtime", this);
    return true;
  }
  setInject(inject) {
    if (Array.isArray(inject)) {
      for (const name of inject) {
        this.using.push(name);
        this.inject.add(name);
      }
    } else if (inject) {
      for (const name of inject.required || []) {
        this.using.push(name);
        this.inject.add(name);
      }
      for (const name of inject.optional || []) {
        this.inject.add(name);
      }
    }
  }
  setup() {
    const { name } = this.plugin;
    if (name && name !== "apply")
      this.name = name;
    this.schema = this.plugin["Config"] || this.plugin["schema"];
    this.setInject(this.plugin["using"] || this.plugin["inject"]);
    this.isReusable = this.plugin["reusable"];
    this.isReactive = this.plugin["reactive"];
    this.context.emit("internal/runtime", this);
    if (this.isReusable) {
      this.forkables.push(this.apply);
    }
  }
  apply = (context, config) => {
    if (typeof this.plugin !== "function") {
      return this.plugin.apply(context, config);
    } else if (isConstructor(this.plugin)) {
      const instance = new this.plugin(context, config);
      const name = instance[Context.expose];
      if (name) {
        context.set(name, instance);
      }
      if (instance["fork"]) {
        this.forkables.push(instance["fork"].bind(instance));
      }
      return instance;
    } else {
      return this.plugin(context, config);
    }
  };
  reset() {
    super.reset();
    for (const fork of this.children) {
      fork.reset();
    }
  }
  start() {
    if (super.start())
      return true;
    if (!this.isReusable && this.plugin) {
      this.ensure(async () => this.value = this.apply(this.ctx, this._config));
    }
    for (const fork of this.children) {
      fork.start();
    }
  }
  update(config, forced) {
    if (this.isForkable) {
      this.context.emit("internal/warning", new Error(`attempting to update forkable plugin "${this.plugin.name}", which may lead to unexpected behavior`));
    }
    const oldConfig = this.config;
    const resolved = resolveConfig(this.runtime.plugin || this.context.constructor, config);
    const [hasUpdate, shouldRestart] = this.checkUpdate(resolved, forced);
    const state = this.children.find((fork) => fork.config === oldConfig);
    this.config = resolved;
    if (state) {
      this.context.emit("internal/before-update", state, config);
      state.config = resolved;
      if (hasUpdate) {
        this.context.emit("internal/update", state, oldConfig);
      }
    }
    if (shouldRestart)
      this.restart();
  }
};

// src/registry.ts
function isApplicable(object) {
  return object && typeof object === "object" && typeof object.apply === "function";
}
__name(isApplicable, "isApplicable");
var Registry = class {
  constructor(root, config) {
    this.root = root;
    defineProperty4(this, Context.origin, root);
    root.scope = new MainScope(this, null, config);
    root.scope.runtime.isReactive = true;
  }
  static {
    __name(this, "Registry");
  }
  _counter = 0;
  _internal = /* @__PURE__ */ new Map();
  get counter() {
    return ++this._counter;
  }
  get size() {
    return this._internal.size;
  }
  resolve(plugin, assert = false) {
    if (plugin === null)
      return plugin;
    if (typeof plugin === "function")
      return plugin;
    if (isApplicable(plugin))
      return plugin.apply;
    if (assert)
      throw new Error('invalid plugin, expect function or object with an "apply" method, received ' + typeof plugin);
  }
  get(plugin) {
    const key = this.resolve(plugin);
    return key && this._internal.get(key);
  }
  has(plugin) {
    const key = this.resolve(plugin);
    return !!key && this._internal.has(key);
  }
  set(plugin, state) {
    const key = this.resolve(plugin);
    this._internal.set(key, state);
  }
  delete(plugin) {
    const key = this.resolve(plugin);
    const runtime = key && this._internal.get(key);
    if (!runtime)
      return;
    this._internal.delete(key);
    runtime.dispose();
    return runtime;
  }
  keys() {
    return this._internal.keys();
  }
  values() {
    return this._internal.values();
  }
  entries() {
    return this._internal.entries();
  }
  forEach(callback) {
    return this._internal.forEach(callback);
  }
  using(inject, callback) {
    return this.inject(inject, callback);
  }
  inject(inject, callback) {
    return this.plugin({ inject, apply: callback, name: callback.name });
  }
  plugin(plugin, config) {
    this.resolve(plugin, true);
    const context = this[Context.origin];
    context.scope.assertActive();
    let error;
    try {
      config = resolveConfig(plugin, config);
    } catch (reason) {
      context.emit("internal/error", reason);
      error = reason;
      config = null;
    }
    let runtime = this.get(plugin);
    if (runtime) {
      if (!runtime.isForkable) {
        context.emit("internal/warning", new Error(`duplicate plugin detected: ${plugin.name}`));
      }
      return runtime.fork(context, config, error);
    }
    runtime = new MainScope(this, plugin, config, error);
    return runtime.fork(context, config, error);
  }
};

// src/context.ts
var Context = class _Context {
  static {
    __name(this, "Context");
  }
  static origin = symbols.origin;
  static events = symbols.events;
  static static = symbols.static;
  static filter = symbols.filter;
  static expose = symbols.expose;
  static isolate = symbols.isolate;
  static internal = symbols.internal;
  static intercept = symbols.intercept;
  /** @deprecated use `Context.origin` instead */
  static current = _Context.origin;
  static is(value) {
    return !!value?.[_Context.is];
  }
  static {
    _Context.is[Symbol.toPrimitive] = () => Symbol.for("cordis.is");
    _Context.prototype[_Context.is] = true;
  }
  static ensureInternal() {
    const ctx = this.prototype || this;
    if (Object.prototype.hasOwnProperty.call(ctx, symbols.internal)) {
      return ctx[symbols.internal];
    }
    const parent = _Context.ensureInternal.call(Object.getPrototypeOf(this));
    return ctx[symbols.internal] = Object.create(parent);
  }
  static resolveInject(ctx, name) {
    let internal = ctx[symbols.internal][name];
    while (internal?.type === "alias") {
      name = internal.name;
      internal = ctx[symbols.internal][name];
    }
    return [name, internal];
  }
  static handler = {
    get(target, prop, ctx) {
      if (typeof prop !== "string")
        return Reflect.get(target, prop, ctx);
      const checkInject = /* @__PURE__ */ __name((name2) => {
        if (Reflect.has(target, name2))
          return;
        if (["prototype", "then", "registry", "lifecycle"].includes(name2))
          return;
        if (name2[0] === "$" || name2[0] === "_")
          return;
        if (!ctx.runtime.plugin)
          return;
        if (ctx.bail("internal/inject", name2))
          return;
        ctx.emit("internal/warning", new Error(`property ${name2} is not registered, declare it as \`inject\` to suppress this warning`));
      }, "checkInject");
      const [name, internal] = _Context.resolveInject(ctx, prop);
      if (!internal) {
        checkInject(name);
        return Reflect.get(target, name, ctx);
      } else if (internal.type === "accessor") {
        return internal.get.call(ctx);
      } else {
        if (!internal.builtin)
          checkInject(name);
        return ctx.get(name);
      }
    },
    set(target, prop, value, ctx) {
      if (typeof prop !== "string")
        return Reflect.set(target, prop, value, ctx);
      const [name, internal] = _Context.resolveInject(ctx, prop);
      if (!internal)
        return Reflect.set(target, name, value, ctx);
      if (internal.type === "accessor") {
        if (!internal.set)
          return false;
        return internal.set.call(ctx, value);
      } else {
        ctx.set(name, value);
        return true;
      }
    }
  };
  static associate(object, name) {
    return new Proxy(object, {
      get(target, key, receiver) {
        if (typeof key === "symbol")
          return Reflect.get(target, key, receiver);
        const caller = receiver[symbols.origin];
        if (!caller?.[symbols.internal][`${name}.${key}`])
          return Reflect.get(target, key, receiver);
        return caller[`${name}.${key}`];
      },
      set(target, key, value, receiver) {
        if (typeof key === "symbol")
          return Reflect.set(target, key, value, receiver);
        const caller = receiver[symbols.origin];
        if (!caller?.[symbols.internal][`${name}.${key}`])
          return Reflect.set(target, key, value, receiver);
        caller[`${name}.${key}`] = value;
        return true;
      }
    });
  }
  constructor(config) {
    const self = new Proxy(this, _Context.handler);
    config = resolveConfig(this.constructor, config);
    self[symbols.isolate] = /* @__PURE__ */ Object.create(null);
    self[symbols.intercept] = /* @__PURE__ */ Object.create(null);
    self.root = self;
    self.mixin("scope", ["config", "runtime", "effect", "collect", "accept", "decline"]);
    self.mixin("registry", ["using", "inject", "plugin", "dispose"]);
    self.mixin("lifecycle", ["on", "once", "off", "after", "parallel", "emit", "serial", "bail", "start", "stop"]);
    self.provide("registry", new Registry(self, config), true);
    self.provide("lifecycle", new Lifecycle(self), true);
    const attach = /* @__PURE__ */ __name((internal) => {
      if (!internal)
        return;
      attach(Object.getPrototypeOf(internal));
      for (const key of Object.getOwnPropertyNames(internal)) {
        const constructor = internal[key]["prototype"]?.constructor;
        if (!constructor)
          continue;
        self[internal[key]["key"]] = new constructor(self, config);
        defineProperty5(self[internal[key]["key"]], symbols.origin, self);
      }
    }, "attach");
    attach(this[symbols.internal]);
    return self;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Context <${this.name}>`;
  }
  get name() {
    let runtime = this.runtime;
    while (runtime && !runtime.name) {
      runtime = runtime.parent.runtime;
    }
    return runtime?.name;
  }
  get events() {
    return this.lifecycle;
  }
  /** @deprecated */
  get state() {
    return this.scope;
  }
  get(name) {
    const internal = this[symbols.internal][name];
    if (internal?.type !== "service")
      return;
    const value = this.root[this[symbols.isolate][name]];
    if (!value || typeof value !== "object" && typeof value !== "function")
      return value;
    if (isUnproxyable(value)) {
      defineProperty5(value, symbols.origin, this);
      return value;
    }
    return createTraceable(this, value);
  }
  set(name, value) {
    this.provide(name);
    const key = this[symbols.isolate][name];
    const oldValue = this.root[key];
    value ??= void 0;
    let dispose = /* @__PURE__ */ __name(() => {
    }, "dispose");
    if (oldValue === value)
      return dispose;
    if (!isNullable2(value) && !isNullable2(oldValue)) {
      throw new Error(`service ${name} has been registered`);
    }
    const ctx = this;
    if (!isNullable2(value)) {
      dispose = ctx.effect(() => () => {
        ctx.set(name, void 0);
      });
    }
    if (isUnproxyable(value)) {
      ctx.emit("internal/warning", new Error(`service ${name} is an unproxyable object, which may lead to unexpected behavior`));
    }
    const self = Object.create(ctx);
    self[symbols.filter] = (ctx2) => {
      return ctx[symbols.isolate][name] === ctx2[symbols.isolate][name];
    };
    ctx.emit(self, "internal/before-service", name, value);
    ctx.root[key] = value;
    if (value instanceof Object) {
      defineProperty5(value, symbols.origin, ctx);
    }
    ctx.emit(self, "internal/service", name, oldValue);
    return dispose;
  }
  provide(name, value, builtin) {
    const internal = _Context.ensureInternal.call(this.root);
    if (name in internal)
      return;
    const key = Symbol(name);
    internal[name] = { type: "service", builtin };
    this.root[key] = value;
    this.root[_Context.isolate][name] = key;
  }
  accessor(name, options) {
    const internal = _Context.ensureInternal.call(this.root);
    internal[name] ||= { type: "accessor", ...options };
  }
  alias(name, aliases) {
    const internal = _Context.ensureInternal.call(this.root);
    for (const key of aliases) {
      internal[key] ||= { type: "alias", name };
    }
  }
  mixin(name, mixins) {
    const entries = Array.isArray(mixins) ? mixins.map((key) => [key, key]) : Object.entries(mixins);
    for (const [key, value] of entries) {
      this.accessor(value, {
        get() {
          const service = this[name];
          if (isNullable2(service))
            return service;
          const value2 = Reflect.get(service, key);
          if (typeof value2 !== "function")
            return value2;
          return value2.bind(service);
        },
        set(value2) {
          return Reflect.set(this[name], key, value2);
        }
      });
    }
  }
  extend(meta = {}) {
    return Object.assign(Object.create(this), meta);
  }
  isolate(name, label) {
    const shadow = Object.create(this[symbols.isolate]);
    shadow[name] = label ?? Symbol(name);
    return this.extend({ [symbols.isolate]: shadow });
  }
  intercept(name, config) {
    const intercept = Object.create(this[symbols.intercept]);
    intercept[name] = config;
    return this.extend({ [symbols.intercept]: intercept });
  }
};
Context.prototype[Context.internal] = /* @__PURE__ */ Object.create(null);

// src/service.ts
import { defineProperty as defineProperty6 } from "cosmokit";
var Service = class _Service {
  static {
    __name(this, "Service");
  }
  static setup = symbols.setup;
  static invoke = symbols.invoke;
  static extend = symbols.extend;
  static provide = symbols.provide;
  static immediate = symbols.immediate;
  start() {
  }
  stop() {
  }
  ctx;
  [symbols.origin];
  name;
  config;
  constructor(...args) {
    let _ctx, name, immediate, config;
    if (Context.is(args[0])) {
      _ctx = args[0];
      if (typeof args[1] === "string") {
        name = args[1];
        immediate = args[2];
      } else {
        config = args[1];
      }
    } else {
      config = args[0];
    }
    name ??= this.constructor[symbols.provide];
    immediate ??= this.constructor[symbols.immediate];
    let self = this;
    if (self[symbols.invoke]) {
      self = createCallable(name, joinPrototype(Object.getPrototypeOf(this), Function.prototype));
    }
    if (_ctx) {
      self.ctx = _ctx;
    } else {
      self[symbols.setup]();
    }
    self.name = name;
    self.config = config;
    defineProperty6(self, symbols.origin, self.ctx);
    self.ctx.provide(name);
    self.ctx.runtime.name = name;
    if (immediate) {
      if (_ctx)
        self[symbols.expose] = name;
      else
        self.ctx.set(name, self);
    }
    self.ctx.on("ready", async () => {
      await Promise.resolve();
      await self.start();
      if (!immediate)
        self.ctx.set(name, self);
    });
    self.ctx.on("dispose", () => self.stop());
    return Context.associate(self, name);
  }
  [symbols.filter](ctx) {
    return ctx[symbols.isolate][this.name] === this.ctx[symbols.isolate][this.name];
  }
  [symbols.setup]() {
    this.ctx = new Context();
  }
  [symbols.extend](props) {
    const caller = this[symbols.origin];
    let self;
    if (this[_Service.invoke]) {
      self = createCallable(this.name, this);
    } else {
      self = Object.create(this);
    }
    defineProperty6(self, symbols.origin, caller);
    return Context.associate(Object.assign(self, props), this.name);
  }
  static [Symbol.hasInstance](instance) {
    let constructor = instance.constructor;
    while (constructor) {
      if (constructor === this)
        return true;
      constructor = Object.getPrototypeOf(constructor);
    }
    return false;
  }
};
export {
  Context,
  CordisError,
  EffectScope,
  ForkScope,
  Lifecycle,
  MainScope,
  Registry,
  ScopeStatus,
  Service,
  applyTraceable,
  createCallable,
  createTraceable,
  isApplicable,
  isBailed,
  isConstructor,
  isUnproxyable,
  joinPrototype,
  resolveConfig,
  symbols
};
//# sourceMappingURL=index.mjs.map
