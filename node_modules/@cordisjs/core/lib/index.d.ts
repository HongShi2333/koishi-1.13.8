import { Awaitable, Dict, Promisify } from 'cosmokit';
export abstract class Service<T = unknown, C extends Context = Context> {
    static readonly setup: unique symbol;
    static readonly invoke: unique symbol;
    static readonly extend: unique symbol;
    static readonly provide: unique symbol;
    static readonly immediate: unique symbol;
    protected start(): Awaitable<void>;
    protected stop(): Awaitable<void>;
    protected fork?(ctx: C, config: any): void;
    protected ctx: C;
    protected [symbols.origin]: C;
    name: string;
    config: T;
    constructor(...args: Spread<T>);
    constructor(ctx: C, ...args: Spread<T>);
    constructor(ctx: C, name: string, immediate?: boolean);
    protected [symbols.filter](ctx: Context): boolean;
    protected [symbols.setup](): void;
    protected [symbols.extend](props?: any): this;
    static [Symbol.hasInstance](instance: any): boolean;
}
export const symbols: {
    origin: typeof Context.origin;
    events: typeof Context.events;
    static: typeof Context.static;
    filter: typeof Context.filter;
    expose: typeof Context.expose;
    isolate: typeof Context.isolate;
    internal: typeof Context.internal;
    intercept: typeof Context.intercept;
    setup: typeof Service.setup;
    invoke: typeof Service.invoke;
    extend: typeof Service.extend;
    provide: typeof Service.provide;
    immediate: typeof Service.immediate;
};
export function isConstructor(func: any): func is new (...args: any) => any;
export function resolveConfig(plugin: any, config: any): any;
export function isUnproxyable(value: any): boolean;
export function joinPrototype(proto1: {}, proto2: {}): any;
export function createTraceable(ctx: any, value: any): any;
export function applyTraceable(proxy: any, value: any, thisArg: any, args: any[]): any;
export function createCallable(name: string, proto: {}): any;
export function isApplicable(object: Plugin): boolean;
export interface Inject {
    readonly required?: string[];
    readonly optional?: string[];
}
export type Plugin<C extends Context = Context, T = any> = Plugin.Function<C, T> | Plugin.Constructor<C, T> | Plugin.Object<C, T>;
export namespace Plugin {
    interface Base<T = any> {
        name?: string;
        reactive?: boolean;
        reusable?: boolean;
        Config?: (config: any) => T;
        inject?: string[] | Inject;
        intercept?: Dict<boolean>;
    }
    interface Transform<S, T> {
        schema?: true;
        Config: (config: S) => T;
    }
    interface Function<C extends Context = Context, T = any> extends Base<T> {
        (ctx: C, config: T): void;
    }
    interface Constructor<C extends Context = Context, T = any> extends Base<T> {
        new (ctx: C, config: T): void;
    }
    interface Object<C extends Context = Context, T = any> extends Base<T> {
        apply: (ctx: C, config: T) => void;
    }
}
export type Spread<T> = undefined extends T ? [config?: T] : [config: T];
export interface Context {
    /** @deprecated use `ctx.inject()` instead */
    using(deps: string[] | Inject, callback: Plugin.Function<this, void>): ForkScope<this>;
    inject(deps: string[] | Inject, callback: Plugin.Function<this, void>): ForkScope<this>;
    plugin<T = undefined, S = T>(plugin: Plugin.Function<this, T> & Plugin.Transform<S, T>, ...args: Spread<S>): ForkScope<this>;
    plugin<T = undefined, S = T>(plugin: Plugin.Constructor<this, T> & Plugin.Transform<S, T>, ...args: Spread<S>): ForkScope<this>;
    plugin<T = undefined, S = T>(plugin: Plugin.Object<this, T> & Plugin.Transform<S, T>, ...args: Spread<S>): ForkScope<this>;
    plugin<T = undefined>(plugin: Plugin.Function<this, T>, ...args: Spread<T>): ForkScope<this>;
    plugin<T = undefined>(plugin: Plugin.Constructor<this, T>, ...args: Spread<T>): ForkScope<this>;
    plugin<T = undefined>(plugin: Plugin.Object<this, T>, ...args: Spread<T>): ForkScope<this>;
}
export class Registry<C extends Context = Context> {
    private root;
    private _counter;
    private _internal;
    constructor(root: Context, config: any);
    get counter(): number;
    get size(): number;
    resolve(plugin: Plugin, assert?: boolean): Function | undefined;
    get(plugin: Plugin): MainScope<C> | undefined;
    has(plugin: Plugin): boolean;
    set(plugin: Plugin, state: MainScope<C>): void;
    delete(plugin: Plugin): MainScope<C> | undefined;
    keys(): IterableIterator<Function>;
    values(): IterableIterator<MainScope<C>>;
    entries(): IterableIterator<[Function, MainScope<C>]>;
    forEach(callback: (value: MainScope<C>, key: Function, map: Map<Plugin, MainScope<C>>) => void): void;
    using(inject: string[] | Inject, callback: Plugin.Function<C, void>): ForkScope<C>;
    inject(inject: string[] | Inject, callback: Plugin.Function<C, void>): ForkScope<C>;
    plugin(plugin: Plugin<C>, config?: any): ForkScope<C>;
}
export interface Context {
    scope: EffectScope<this>;
    runtime: MainScope<this>;
    effect<T extends DisposableLike>(callback: Callable<T, [ctx: this]>): T;
    effect<T extends DisposableLike, R>(callback: Callable<T, [ctx: this, config: R]>, config: R): T;
    /** @deprecated use `ctx.effect()` instead */
    collect(label: string, callback: () => void): () => void;
    accept(callback?: (config: this['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    accept(keys: (keyof this['config'])[], callback?: (config: this['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    decline(keys: (keyof this['config'])[]): () => boolean;
}
export type Disposable = () => void;
export type DisposableLike = Disposable | {
    dispose: Disposable;
};
export type Callable<T, R extends unknown[]> = ((...args: R) => T) | (new (...args: R) => T);
export interface AcceptOptions {
    passive?: boolean;
    immediate?: boolean;
}
export interface Acceptor extends AcceptOptions {
    keys?: string[];
    callback?: (config: any) => void | boolean;
}
export const enum ScopeStatus {
    PENDING = 0,
    LOADING = 1,
    ACTIVE = 2,
    FAILED = 3,
    DISPOSED = 4
}
export class CordisError extends Error {
    code: CordisError.Code;
    constructor(code: CordisError.Code, message?: string);
}
export namespace CordisError {
    type Code = keyof typeof Code;
    const Code: {
        readonly INACTIVE_EFFECT: "cannot create effect on inactive context";
    };
}
export abstract class EffectScope<C extends Context = Context> {
    parent: C;
    config: C['config'];
    uid: number | null;
    ctx: C;
    disposables: Disposable[];
    error: any;
    status: ScopeStatus;
    isActive: boolean;
    protected context: Context;
    protected proxy: any;
    protected acceptors: Acceptor[];
    protected tasks: Set<Promise<void>>;
    protected hasError: boolean;
    abstract runtime: MainScope<C>;
    abstract dispose(): boolean;
    abstract update(config: C['config'], forced?: boolean): void;
    constructor(parent: C, config: C['config']);
    protected get _config(): any;
    assertActive(): void;
    effect(callback: Callable<DisposableLike, [ctx: C, config: any]>, config?: any): {
        dispose: Disposable;
    } | (() => void);
    collect(label: string, callback: () => any): () => any;
    restart(): void;
    protected _getStatus(): ScopeStatus;
    updateStatus(callback?: () => void): void;
    ensure(callback: () => Promise<void>): void;
    cancel(reason?: any): void;
    get ready(): boolean;
    reset(): void;
    protected init(error?: any): void;
    start(): true | undefined;
    accept(callback?: (config: C['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    accept(keys: string[], callback?: (config: C['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    decline(keys: string[]): () => boolean;
    checkUpdate(resolved: any, forced?: boolean): boolean[];
}
export class ForkScope<C extends Context = Context> extends EffectScope<C> {
    runtime: MainScope<C>;
    dispose: () => boolean;
    constructor(parent: Context, runtime: MainScope<C>, config: C['config'], error?: any);
    start(): true | undefined;
    update(config: any, forced?: boolean): void;
}
export class MainScope<C extends Context = Context> extends EffectScope<C> {
    plugin: Plugin;
    value: any;
    runtime: this;
    schema: any;
    name?: string;
    using: string[];
    inject: Set<string>;
    forkables: Function[];
    children: ForkScope<C>[];
    isReusable?: boolean;
    isReactive?: boolean;
    constructor(registry: Registry<C>, plugin: Plugin, config: any, error?: any);
    get isForkable(): boolean;
    fork(parent: Context, config: any, error?: any): ForkScope<C>;
    dispose(): boolean;
    private setInject;
    private setup;
    private apply;
    reset(): void;
    start(): true | undefined;
    update(config: C['config'], forced?: boolean): void;
}
export function isBailed(value: any): boolean;
export type Parameters<F> = F extends (...args: infer P) => any ? P : never;
export type ReturnType<F> = F extends (...args: any) => infer R ? R : never;
export type ThisType<F> = F extends (this: infer T, ...args: any) => any ? T : never;
export type GetEvents<C extends Context> = C[typeof Context.events];
export interface Context {
    [Context.events]: Events<this>;
    parallel<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promise<void>;
    parallel<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promise<void>;
    emit<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): void;
    emit<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): void;
    serial<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
    serial<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
    bail<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
    bail<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
    on<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K], options?: boolean | EventOptions): () => boolean;
    once<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K], options?: boolean | EventOptions): () => boolean;
    off<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K]): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
}
export interface EventOptions {
    prepend?: boolean;
    global?: boolean;
}
type Hook = [Context, (...args: any[]) => any, EventOptions];
export class Lifecycle {
    private root;
    isActive: boolean;
    _tasks: Set<Promise<void>>;
    _hooks: Record<keyof any, Hook[]>;
    constructor(root: Context);
    flush(): Promise<void>;
    getHooks(name: keyof any, thisArg?: object): ((...args: any[]) => any)[];
    prepareEvent(type: string, args: any[]): readonly [((...args: any[]) => any)[], any];
    parallel(...args: any[]): Promise<void>;
    emit(...args: any[]): void;
    serial(...args: any[]): Promise<any>;
    bail(...args: any[]): any;
    register(label: string, hooks: Hook[], listener: any, options: EventOptions): any;
    unregister(hooks: Hook[], listener: any): true | undefined;
    on(name: string, listener: (...args: any) => any, options?: boolean | EventOptions): any;
    once(name: string, listener: (...args: any) => any, options?: boolean | EventOptions): any;
    off(name: string, listener: (...args: any) => any): true | undefined;
    start(): Promise<void>;
    stop(): Promise<void>;
}
export interface Events<in C extends Context = Context> {
    'fork'(ctx: C, config: C['config']): void;
    'ready'(): Awaitable<void>;
    'dispose'(): Awaitable<void>;
    'internal/fork'(fork: ForkScope<C>): void;
    'internal/runtime'(runtime: MainScope<C>): void;
    'internal/status'(scope: EffectScope<C>, oldValue: ScopeStatus): void;
    'internal/info'(this: C, format: any, ...param: any[]): void;
    'internal/error'(this: C, format: any, ...param: any[]): void;
    'internal/warning'(this: C, format: any, ...param: any[]): void;
    'internal/before-service'(this: C, name: string, value: any): void;
    'internal/service'(this: C, name: string, value: any): void;
    'internal/before-update'(fork: ForkScope<C>, config: any): void;
    'internal/update'(fork: ForkScope<C>, oldConfig: any): void;
    'internal/inject'(this: C, name: string): boolean | undefined;
    'internal/listener'(this: C, name: string, listener: any, prepend: boolean): void;
    'internal/event'(type: 'emit' | 'parallel' | 'serial' | 'bail', name: string, args: any[], thisArg: any): void;
}
export namespace Context {
    type Parameterized<C, T = any> = C & {
        config: T;
    };
    /** @deprecated use `string[]` instead */
    interface MixinOptions {
        methods?: string[];
        accessors?: string[];
        prototype?: {};
    }
    type Internal = Internal.Service | Internal.Accessor | Internal.Alias;
    namespace Internal {
        interface Service {
            type: 'service';
            builtin?: boolean;
            prototype?: {};
        }
        interface Accessor {
            type: 'accessor';
            get: () => any;
            set?: (value: any) => boolean;
        }
        interface Alias {
            type: 'alias';
            name: string;
        }
    }
}
export interface Intercept<C extends Context = Context> {
}
export interface Context {
    [Context.isolate]: Dict<symbol>;
    [Context.intercept]: Intercept<this>;
    [Context.internal]: Dict<Context.Internal>;
    root: this;
    lifecycle: Lifecycle;
    registry: Registry<this>;
    config: any;
}
export class Context {
    static readonly origin: unique symbol;
    static readonly events: unique symbol;
    static readonly static: unique symbol;
    static readonly filter: unique symbol;
    static readonly expose: unique symbol;
    static readonly isolate: unique symbol;
    static readonly internal: unique symbol;
    static readonly intercept: unique symbol;
    /** @deprecated use `Context.origin` instead */
    static readonly current: typeof Context.origin;
    static is<C extends Context>(value: any): value is C;
    private static ensureInternal;
    static resolveInject(ctx: Context, name: string): readonly [string, Context.Internal.Service | Context.Internal.Accessor];
    static handler: ProxyHandler<Context>;
    static associate<T extends {}>(object: T, name: string): T;
    constructor(config?: any);
    get name(): string;
    get events(): Lifecycle;
    /** @deprecated */
    get state(): EffectScope<this>;
    get<K extends string & keyof this>(name: K): undefined | this[K];
    get(name: string): any;
    set<K extends string & keyof this>(name: K, value: undefined | this[K]): () => void;
    set(name: string, value: any): () => void;
    provide(name: string, value?: any, builtin?: boolean): void;
    accessor(name: string, options: Omit<Context.Internal.Accessor, 'type'>): void;
    alias(name: string, aliases: string[]): void;
    mixin(name: string, mixins: string[] | Dict<string>): void;
    extend(meta?: {}): this;
    isolate(name: string, label?: symbol): this;
    intercept<K extends keyof Intercept>(name: K, config: Intercept[K]): this;
}
