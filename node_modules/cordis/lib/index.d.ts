import { Awaitable, Promisify, Dict } from 'cosmokit';
export function isConstructor(func: any): func is new (...args: any) => any;
export function getConstructor(instance: any): any;
export function resolveConfig(plugin: any, config: any): any;
export function isUnproxyable(value: any): boolean;
export function isApplicable(object: Plugin): boolean;
export interface Inject {
    readonly required?: string[];
    readonly optional?: string[];
}
export type Plugin<C extends Context = Context, T = any> = Plugin.Function<C, T> | Plugin.Constructor<C, T> | Plugin.Object<C, T>;
export namespace Plugin {
    interface Base {
        name?: string;
        reactive?: boolean;
        reusable?: boolean;
        Config?: (config?: any) => any;
        inject?: string[] | Inject;
        /** @deprecated use `inject` instead */
        using?: string[] | Inject;
    }
    interface Function<C extends Context = Context, T = any> extends Base {
        (ctx: C, options: T): void;
    }
    interface Constructor<C extends Context = Context, T = any> extends Base {
        new (ctx: C, options: T): void;
    }
    interface Object<C extends Context = Context, T = any> extends Base {
        apply: (ctx: C, options: T) => void;
    }
}
export interface Context {
    /** @deprecated use `ctx.inject()` instead */
    using(deps: string[] | Inject, callback: Plugin.Function<Context.Parameterized<this, void>, void>): ForkScope<Context.Parameterized<this, void>>;
    inject(deps: string[] | Inject, callback: Plugin.Function<Context.Parameterized<this, void>, void>): ForkScope<Context.Parameterized<this, void>>;
    plugin<T, S = T>(plugin: Plugin.Function<Context.Parameterized<this, T>, T> & {
        schema?: true;
        Config: (config?: S) => T;
    }, config?: S): ForkScope<Context.Parameterized<this, T>>;
    plugin<T, S = T>(plugin: Plugin.Constructor<Context.Parameterized<this, T>, T> & {
        schema?: true;
        Config: (config?: S) => T;
    }, config?: S): ForkScope<Context.Parameterized<this, T>>;
    plugin<T, S = T>(plugin: Plugin.Object<Context.Parameterized<this, T>, T> & {
        schema?: true;
        Config: (config?: S) => T;
    }, config?: S): ForkScope<Context.Parameterized<this, T>>;
    plugin<T>(plugin: Plugin.Function<Context.Parameterized<this, T>, T>, config?: T): ForkScope<Context.Parameterized<this, T>>;
    plugin<T>(plugin: Plugin.Constructor<Context.Parameterized<this, T>, T>, config?: T): ForkScope<Context.Parameterized<this, T>>;
    plugin<T>(plugin: Plugin.Object<Context.Parameterized<this, T>, T>, config?: T): ForkScope<Context.Parameterized<this, T>>;
}
export namespace Registry {
    interface Config {
    }
}
export class Registry<C extends Context = Context> {
    private root;
    private _counter;
    private _internal;
    constructor(root: Context, config: Registry.Config);
    get counter(): number;
    get size(): number;
    resolve(plugin: Plugin): ((ctx: Context<any>, options: any) => void) | (Plugin.Constructor<Context<any>, any> & Function);
    get(plugin: Plugin<C>): MainScope<C> | undefined;
    has(plugin: Plugin<C>): boolean;
    set(plugin: Plugin<C>, state: MainScope<C>): Map<Plugin<C, any>, MainScope<C>>;
    delete(plugin: Plugin<C>): MainScope<C> | undefined;
    keys(): IterableIterator<Plugin<C, any>>;
    values(): IterableIterator<MainScope<C>>;
    entries(): IterableIterator<[Plugin<C, any>, MainScope<C>]>;
    forEach(callback: (value: MainScope<C>, key: Plugin<C>, map: Map<Plugin<C>, MainScope<C>>) => void): void;
    using(inject: string[] | Inject, callback: Plugin.Function<C, void>): ForkScope<C>;
    inject(inject: string[] | Inject, callback: Plugin.Function<C, void>): ForkScope<C>;
    plugin(plugin: Plugin<C>, config?: any): ForkScope<C>;
}
export interface Context {
    scope: EffectScope<this>;
    runtime: MainScope<this>;
    effect<T extends DisposableLike>(callback: () => T): T;
    /** @deprecated use `ctx.effect()` instead */
    collect(label: string, callback: () => void): () => void;
    accept(callback?: (config: this['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    accept(keys: (keyof this['config'])[], callback?: (config: this['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    decline(keys: (keyof this['config'])[]): () => boolean;
}
export type Disposable = () => void;
export type DisposableLike = Disposable | {
    dispose: Disposable;
};
export interface AcceptOptions {
    passive?: boolean;
    immediate?: boolean;
}
export interface Acceptor extends AcceptOptions {
    keys?: string[];
    callback?: (config: any) => void | boolean;
}
export const enum ScopeStatus {
    PENDING = 0,
    LOADING = 1,
    ACTIVE = 2,
    FAILED = 3,
    DISPOSED = 4
}
export class CordisError extends Error {
    code: CordisError.Code;
    constructor(code: CordisError.Code, message?: string);
}
export namespace CordisError {
    type Code = keyof typeof Code;
    const Code: {
        readonly INACTIVE_EFFECT: "cannot create effect on inactive context";
    };
}
export abstract class EffectScope<C extends Context = Context> {
    parent: C;
    config: C['config'];
    uid: number | null;
    ctx: C;
    disposables: Disposable[];
    error: any;
    status: ScopeStatus;
    isActive: boolean;
    protected context: Context;
    protected proxy: any;
    protected acceptors: Acceptor[];
    protected tasks: Set<Promise<void>>;
    protected hasError: boolean;
    abstract runtime: MainScope<C>;
    abstract dispose(): boolean;
    abstract update(config: C['config'], forced?: boolean): void;
    constructor(parent: C, config: C['config']);
    protected get _config(): any;
    assertActive(): void;
    effect(callback: () => DisposableLike): {
        dispose: Disposable;
    } | (() => void);
    collect(label: string, callback: () => any): () => any;
    restart(): void;
    protected _getStatus(): ScopeStatus;
    protected _updateStatus(callback?: () => void): void;
    ensure(callback: () => Promise<void>): void;
    cancel(reason?: any): void;
    protected setupInject(): void;
    get ready(): boolean;
    reset(): void;
    protected init(error?: any): void;
    start(): true | undefined;
    accept(callback?: (config: C['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    accept(keys: string[], callback?: (config: C['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    decline(keys: string[]): () => boolean;
    checkUpdate(resolved: any, forced?: boolean): boolean[];
}
export class ForkScope<C extends Context = Context> extends EffectScope<C> {
    runtime: MainScope<C>;
    dispose: () => boolean;
    constructor(parent: Context, runtime: MainScope<C>, config: C['config'], error?: any);
    start(): true | undefined;
    update(config: any, forced?: boolean): void;
}
export class MainScope<C extends Context = Context> extends EffectScope<C> {
    plugin: Plugin;
    runtime: this;
    schema: any;
    name?: string;
    using: string[];
    inject: Set<string>;
    forkables: Function[];
    children: ForkScope<C>[];
    isReusable?: boolean;
    isReactive?: boolean;
    constructor(registry: Registry<C>, plugin: Plugin, config: any, error?: any);
    get isForkable(): boolean;
    fork(parent: Context, config: any, error?: any): ForkScope<C>;
    dispose(): boolean;
    private setup;
    private apply;
    reset(): void;
    start(): true | undefined;
    update(config: C['config'], forced?: boolean): void;
}
export function isBailed(value: any): boolean;
export type Parameters<F> = F extends (...args: infer P) => any ? P : never;
export type ReturnType<F> = F extends (...args: any) => infer R ? R : never;
export type ThisType<F> = F extends (this: infer T, ...args: any) => any ? T : never;
export type GetEvents<C extends Context> = C[typeof Context.events];
export interface Context {
    [Context.events]: Events<this>;
    parallel<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promise<void>;
    parallel<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promise<void>;
    emit<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): void;
    emit<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): void;
    serial<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
    serial<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
    bail<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
    bail<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
    on<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K], prepend?: boolean): () => boolean;
    once<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K], prepend?: boolean): () => boolean;
    off<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K]): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
}
export namespace Lifecycle {
    interface Config {
        maxListeners?: number;
    }
}
export class Lifecycle {
    private root;
    isActive: boolean;
    _tasks: Set<Promise<void>>;
    _hooks: Record<keyof any, [Context, (...args: any[]) => any][]>;
    constructor(root: Context);
    flush(): Promise<void>;
    getHooks(name: keyof any, thisArg?: object): ((...args: any[]) => any)[];
    prepareEvent(type: string, args: any[]): readonly [((...args: any[]) => any)[], any];
    parallel(...args: any[]): Promise<void>;
    emit(...args: any[]): void;
    serial(...args: any[]): Promise<any>;
    bail(...args: any[]): any;
    register(label: string, hooks: [Context, any][], listener: any, prepend?: boolean): any;
    unregister(hooks: [Context, any][], listener: any): true | undefined;
    on(name: string, listener: (...args: any) => any, prepend?: boolean): any;
    once(name: string, listener: (...args: any) => any, prepend?: boolean): any;
    off(name: string, listener: (...args: any) => any): true | undefined;
    start(): Promise<void>;
    stop(): Promise<void>;
}
export interface Events<C extends Context = Context> {
    'fork': Plugin.Function<C, C['config']>;
    'ready'(): Awaitable<void>;
    'dispose'(): Awaitable<void>;
    'internal/fork'(fork: ForkScope<Context.Parameterized<C>>): void;
    'internal/runtime'(runtime: MainScope<Context.Parameterized<C>>): void;
    'internal/status'(scope: EffectScope<Context.Parameterized<C>>, oldValue: ScopeStatus): void;
    'internal/error'(this: C, format: any, ...param: any[]): void;
    'internal/warning'(this: C, format: any, ...param: any[]): void;
    'internal/before-service'(name: string, value: any): void;
    'internal/service'(name: string, oldValue: any): void;
    'internal/before-update'(fork: ForkScope<Context.Parameterized<C>>, config: any): void;
    'internal/update'(fork: ForkScope<Context.Parameterized<C>>, oldConfig: any): void;
    'internal/listener'(this: C, name: string, listener: any, prepend: boolean): void;
    'internal/event'(type: 'emit' | 'parallel' | 'serial' | 'bail', name: string, args: any[], thisArg: any): void;
}
export namespace Context {
    type Parameterized<C, T = any> = Omit<C, 'config'> & {
        config: T;
    };
    interface Config extends Lifecycle.Config, Registry.Config {
    }
    /** @deprecated use `string[]` instead */
    interface MixinOptions {
        methods?: string[];
        accessors?: string[];
        prototype?: {};
    }
    type Internal = Internal.Service | Internal.Accessor | Internal.Alias;
    namespace Internal {
        interface Service {
            type: 'service';
            key: symbol;
            builtin?: boolean;
            prototype?: {};
        }
        interface Accessor {
            type: 'accessor';
            get: () => any;
            set?: (value: any) => boolean;
        }
        interface Alias {
            type: 'alias';
            name: string;
        }
    }
    type Associate<P extends string, C extends Context = Context> = {
        [K in keyof C as K extends `${P}.${infer R}` ? R : never]: C[K];
    };
}
export interface Context<T = any> {
    [Context.config]: Context.Config;
    [Context.shadow]: Dict<symbol>;
    [Context.internal]: Dict<Context.Internal>;
    root: Context.Parameterized<this, this[typeof Context.config]>;
    realms: Record<string, Record<string, symbol>>;
    lifecycle: Lifecycle;
    registry: Registry<this>;
    config: T;
}
export class Context {
    static readonly config: unique symbol;
    static readonly events: unique symbol;
    static readonly static: unique symbol;
    static readonly filter: unique symbol;
    static readonly expose: unique symbol;
    static readonly shadow: unique symbol;
    /** @deprecated use `Context.current` instead */
    static readonly source: unique symbol;
    static readonly current: unique symbol;
    static readonly internal: unique symbol;
    private static ensureInternal;
    /** @deprecated */
    static service(name: string, options?: string[] | Context.MixinOptions): void;
    static resolveInject(ctx: Context, name: string): readonly [string, Context.Internal.Accessor | Context.Internal.Service];
    static handler: ProxyHandler<Context>;
    static associate<T extends {}>(object: T, name: string): T;
    constructor(config?: Context.Config);
    get name(): string | undefined;
    get events(): Lifecycle;
    /** @deprecated */
    get state(): EffectScope<this>;
    get<K extends string & keyof this>(name: K): undefined | this[K];
    get(name: string): any;
    provide(name: string, value?: any, builtin?: boolean): void;
    accessor(name: string, options: Omit<Context.Internal.Accessor, 'type'>): void;
    alias(name: string, aliases: string[]): void;
    mixin(name: string, mixins: string[]): void;
    extend(meta?: {}): this;
    isolate(names: string[], label?: string): this;
}
export interface Service extends Context.Associate<'service'> {
}
export class Service<C extends Context = Context> {
    protected ctx: C;
    name: string;
    protected start(): Awaitable<void>;
    protected stop(): Awaitable<void>;
    protected fork?(ctx: C, config: any): void;
    protected [Context.current]: C;
    constructor(ctx: C, name: string, immediate?: boolean);
    [Context.filter](ctx: Context): boolean;
}
