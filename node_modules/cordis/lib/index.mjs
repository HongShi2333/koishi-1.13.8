var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// cordis/core/src/context.ts
import { defineProperty as defineProperty4, isNullable as isNullable2 } from "cosmokit";

// cordis/core/src/events.ts
import { defineProperty, remove } from "cosmokit";
function isBailed(value) {
  return value !== null && value !== false && value !== void 0;
}
__name(isBailed, "isBailed");
var Lifecycle = class {
  constructor(root) {
    this.root = root;
    defineProperty(this, Context.current, root);
    defineProperty(this.on("internal/listener", function(name, listener, prepend) {
      const method = prepend ? "unshift" : "push";
      if (name === "ready") {
        if (!this.lifecycle.isActive)
          return;
        this.scope.ensure(async () => listener());
        return () => false;
      } else if (name === "dispose") {
        this.scope.disposables[method](listener);
        defineProperty(listener, "name", "event <dispose>");
        return () => remove(this.scope.disposables, listener);
      } else if (name === "fork") {
        this.scope.runtime.forkables[method](listener);
        return this.scope.collect("event <fork>", () => remove(this.scope.runtime.forkables, listener));
      }
    }), Context.static, root.scope);
    defineProperty(this.on("internal/error", (error) => {
      if (this._hooks["internal/error"].length > 1)
        return;
      console.error(error);
    }), Context.static, root.scope);
    defineProperty(this.on("internal/warning", (error) => {
      if (this._hooks["internal/warning"].length > 1)
        return;
      console.warn(error);
    }), Context.static, root.scope);
  }
  static {
    __name(this, "Lifecycle");
  }
  isActive = false;
  _tasks = /* @__PURE__ */ new Set();
  _hooks = {};
  async flush() {
    while (this._tasks.size) {
      await Promise.all(Array.from(this._tasks));
    }
  }
  getHooks(name, thisArg) {
    const hooks = this._hooks[name] || [];
    return hooks.slice().filter(([context]) => {
      const filter = thisArg?.[Context.filter];
      return !filter || filter.call(thisArg, context);
    }).map(([, callback]) => callback);
  }
  prepareEvent(type, args) {
    const thisArg = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    if (name !== "internal/event") {
      this.emit("internal/event", type, name, args, thisArg);
    }
    return [this.getHooks(name, thisArg), thisArg ?? this[Context.current]];
  }
  async parallel(...args) {
    const [hooks, thisArg] = this.prepareEvent("parallel", args);
    await Promise.all(hooks.map(async (callback) => {
      await callback.apply(thisArg, args);
    }));
  }
  emit(...args) {
    const [hooks, thisArg] = this.prepareEvent("emit", args);
    for (const callback of hooks) {
      callback.apply(thisArg, args);
    }
  }
  async serial(...args) {
    const [hooks, thisArg] = this.prepareEvent("serial", args);
    for (const callback of hooks) {
      const result = await callback.apply(thisArg, args);
      if (isBailed(result))
        return result;
    }
  }
  bail(...args) {
    const [hooks, thisArg] = this.prepareEvent("bail", args);
    for (const callback of hooks) {
      const result = callback.apply(thisArg, args);
      if (isBailed(result))
        return result;
    }
  }
  register(label, hooks, listener, prepend) {
    const maxListeners = this.root.config.maxListeners;
    if (hooks.length >= maxListeners) {
      this.root.emit("internal/warning", new Error(`max listener count (${maxListeners}) for ${label} exceeded, which may be caused by a memory leak`));
    }
    const caller = this[Context.current];
    const method = prepend ? "unshift" : "push";
    hooks[method]([caller, listener]);
    return caller.state.collect(label, () => this.unregister(hooks, listener));
  }
  unregister(hooks, listener) {
    const index = hooks.findIndex(([context, callback]) => callback === listener);
    if (index >= 0) {
      hooks.splice(index, 1);
      return true;
    }
  }
  on(name, listener, prepend = false) {
    const caller = this[Context.current];
    caller.scope.assertActive();
    const result = this.bail(caller, "internal/listener", name, listener, prepend);
    if (result)
      return result;
    const hooks = this._hooks[name] ||= [];
    const label = typeof name === "string" ? `event <${name}>` : "event (Symbol)";
    return this.register(label, hooks, listener, prepend);
  }
  once(name, listener, prepend = false) {
    const dispose = this.on(name, function(...args) {
      dispose();
      return listener.apply(this, args);
    }, prepend);
    return dispose;
  }
  off(name, listener) {
    return this.unregister(this._hooks[name] || [], listener);
  }
  async start() {
    this.isActive = true;
    const hooks = this._hooks.ready || [];
    while (hooks.length) {
      const [context, callback] = hooks.shift();
      context.scope.ensure(async () => callback());
    }
    await this.flush();
  }
  async stop() {
    this.isActive = false;
    this.root.scope.reset();
  }
};

// cordis/core/src/registry.ts
import { defineProperty as defineProperty3 } from "cosmokit";

// cordis/core/src/scope.ts
import { deepEqual, defineProperty as defineProperty2, isNullable, remove as remove2 } from "cosmokit";

// cordis/core/src/utils.ts
function isConstructor(func) {
  if (!func.prototype)
    return false;
  if (func.prototype.constructor !== func)
    return false;
  return true;
}
__name(isConstructor, "isConstructor");
function getConstructor(instance) {
  return Object.getPrototypeOf(instance).constructor;
}
__name(getConstructor, "getConstructor");
function resolveConfig(plugin, config) {
  const schema = plugin["Config"] || plugin["schema"];
  if (schema && plugin["schema"] !== false)
    config = schema(config);
  return config ?? {};
}
__name(resolveConfig, "resolveConfig");
function isUnproxyable(value) {
  return [Map, Set, Date, Promise].some((constructor) => value instanceof constructor);
}
__name(isUnproxyable, "isUnproxyable");

// cordis/core/src/scope.ts
var ScopeStatus = /* @__PURE__ */ ((ScopeStatus2) => {
  ScopeStatus2[ScopeStatus2["PENDING"] = 0] = "PENDING";
  ScopeStatus2[ScopeStatus2["LOADING"] = 1] = "LOADING";
  ScopeStatus2[ScopeStatus2["ACTIVE"] = 2] = "ACTIVE";
  ScopeStatus2[ScopeStatus2["FAILED"] = 3] = "FAILED";
  ScopeStatus2[ScopeStatus2["DISPOSED"] = 4] = "DISPOSED";
  return ScopeStatus2;
})(ScopeStatus || {});
var CordisError = class _CordisError extends Error {
  constructor(code, message) {
    super(message ?? _CordisError.Code[code]);
    this.code = code;
  }
  static {
    __name(this, "CordisError");
  }
};
((CordisError2) => {
  CordisError2.Code = {
    INACTIVE_EFFECT: "cannot create effect on inactive context"
  };
})(CordisError || (CordisError = {}));
var EffectScope = class {
  constructor(parent, config) {
    this.parent = parent;
    this.config = config;
    this.uid = parent.registry ? parent.registry.counter : 0;
    this.ctx = this.context = parent.extend({ scope: this });
    this.proxy = new Proxy({}, {
      get: (target, key) => Reflect.get(this.config, key)
    });
  }
  static {
    __name(this, "EffectScope");
  }
  uid;
  ctx;
  disposables = [];
  error;
  status = 0 /* PENDING */;
  isActive = false;
  // Same as `this.ctx`, but with a more specific type.
  context;
  proxy;
  acceptors = [];
  tasks = /* @__PURE__ */ new Set();
  hasError = false;
  get _config() {
    return this.runtime.isReactive ? this.proxy : this.config;
  }
  assertActive() {
    if (this.uid !== null || this.isActive)
      return;
    throw new CordisError("INACTIVE_EFFECT");
  }
  effect(callback) {
    this.assertActive();
    const result = callback();
    const original = typeof result === "function" ? result : result.dispose.bind(result);
    const wrapped = /* @__PURE__ */ __name(() => {
      if (!remove2(this.disposables, wrapped))
        return;
      return original();
    }, "wrapped");
    this.disposables.push(wrapped);
    if (typeof result === "function")
      return wrapped;
    result.dispose = wrapped;
    return result;
  }
  collect(label, callback) {
    const dispose = defineProperty2(() => {
      remove2(this.disposables, dispose);
      return callback();
    }, "name", label);
    this.disposables.push(dispose);
    return dispose;
  }
  restart() {
    this.reset();
    this.error = null;
    this.hasError = false;
    this.status = 0 /* PENDING */;
    this.start();
  }
  _getStatus() {
    if (this.uid === null)
      return 4 /* DISPOSED */;
    if (this.hasError)
      return 3 /* FAILED */;
    if (this.tasks.size)
      return 1 /* LOADING */;
    if (this.ready)
      return 2 /* ACTIVE */;
    return 0 /* PENDING */;
  }
  _updateStatus(callback) {
    const oldValue = this.status;
    callback?.();
    this.status = this._getStatus();
    if (oldValue !== this.status) {
      this.context.emit("internal/status", this, oldValue);
    }
  }
  ensure(callback) {
    const task = callback().catch((reason) => {
      this.context.emit("internal/error", reason);
      this.cancel(reason);
    }).finally(() => {
      this._updateStatus(() => this.tasks.delete(task));
      this.context.events._tasks.delete(task);
    });
    this._updateStatus(() => this.tasks.add(task));
    this.context.events._tasks.add(task);
  }
  cancel(reason) {
    this.error = reason;
    this._updateStatus(() => this.hasError = true);
    this.reset();
  }
  setupInject() {
    if (!this.runtime.using.length)
      return;
    defineProperty2(this.context.on("internal/before-service", (name) => {
      if (!this.runtime.using.includes(name))
        return;
      this._updateStatus();
      this.reset();
    }), Context.static, this);
    defineProperty2(this.context.on("internal/service", (name) => {
      if (!this.runtime.using.includes(name))
        return;
      this.start();
    }), Context.static, this);
  }
  get ready() {
    return this.runtime.using.every((name) => !isNullable(this.ctx[name]));
  }
  reset() {
    this.isActive = false;
    this.disposables = this.disposables.splice(0).filter((dispose) => {
      if (this.uid !== null && dispose[Context.static] === this)
        return true;
      (async () => dispose())().catch((reason) => {
        this.context.emit("internal/error", reason);
      });
    });
  }
  init(error) {
    if (!this.config) {
      this.cancel(error);
    } else {
      this.start();
    }
  }
  start() {
    if (!this.ready || this.isActive || this.uid === null)
      return true;
    this.isActive = true;
    this._updateStatus(() => this.hasError = false);
  }
  accept(...args) {
    const keys = Array.isArray(args[0]) ? args.shift() : null;
    const acceptor = { keys, callback: args[0], ...args[1] };
    return this.effect(() => {
      this.acceptors.push(acceptor);
      if (acceptor.immediate)
        acceptor.callback?.(this.config);
      return () => remove2(this.acceptors, acceptor);
    });
  }
  decline(keys) {
    return this.accept(keys, () => true);
  }
  checkUpdate(resolved, forced) {
    if (forced || !this.config)
      return [true, true];
    if (forced === false)
      return [false, false];
    const modified = /* @__PURE__ */ Object.create(null);
    const checkPropertyUpdate = /* @__PURE__ */ __name((key) => {
      const result = modified[key] ??= !deepEqual(this.config[key], resolved[key]);
      hasUpdate ||= result;
      return result;
    }, "checkPropertyUpdate");
    const ignored = /* @__PURE__ */ new Set();
    let hasUpdate = false, shouldRestart = false;
    let fallback = this.runtime.isReactive || null;
    for (const { keys, callback, passive } of this.acceptors) {
      if (!keys) {
        fallback ||= !passive;
      } else if (passive) {
        keys?.forEach((key) => ignored.add(key));
      } else {
        let hasUpdate2 = false;
        for (const key of keys) {
          hasUpdate2 ||= checkPropertyUpdate(key);
        }
        if (!hasUpdate2)
          continue;
      }
      const result = callback?.(resolved);
      if (result)
        shouldRestart = true;
    }
    for (const key in { ...this.config, ...resolved }) {
      if (fallback === false)
        continue;
      if (!(key in modified) && !ignored.has(key)) {
        const hasUpdate2 = checkPropertyUpdate(key);
        if (fallback === null)
          shouldRestart ||= hasUpdate2;
      }
    }
    return [hasUpdate, shouldRestart];
  }
};
var ForkScope = class extends EffectScope {
  constructor(parent, runtime, config, error) {
    super(parent, config);
    this.runtime = runtime;
    this.dispose = defineProperty2(parent.scope.collect(`fork <${parent.runtime.name}>`, () => {
      this.uid = null;
      this.reset();
      this.context.emit("internal/fork", this);
      const result = remove2(runtime.disposables, this.dispose);
      if (remove2(runtime.children, this) && !runtime.children.length) {
        parent.registry.delete(runtime.plugin);
      }
      return result;
    }), Context.static, runtime);
    runtime.children.push(this);
    runtime.disposables.push(this.dispose);
    this.context.emit("internal/fork", this);
    if (runtime.isReusable) {
      this.setupInject();
    }
    this.init(error);
  }
  static {
    __name(this, "ForkScope");
  }
  dispose;
  start() {
    if (super.start())
      return true;
    for (const fork of this.runtime.forkables) {
      this.ensure(async () => fork(this.context, this._config));
    }
  }
  update(config, forced) {
    const oldConfig = this.config;
    const state = this.runtime.isForkable ? this : this.runtime;
    if (state.config !== oldConfig)
      return;
    const resolved = resolveConfig(this.runtime.plugin, config);
    const [hasUpdate, shouldRestart] = state.checkUpdate(resolved, forced);
    this.context.emit("internal/before-update", this, config);
    this.config = resolved;
    state.config = resolved;
    if (hasUpdate) {
      this.context.emit("internal/update", this, oldConfig);
    }
    if (shouldRestart)
      state.restart();
  }
};
var MainScope = class extends EffectScope {
  constructor(registry, plugin, config, error) {
    super(registry[Context.current], config);
    this.plugin = plugin;
    registry.set(plugin, this);
    if (!plugin) {
      this.name = "root";
      this.isActive = true;
    } else {
      this.setup();
      this.init(error);
    }
  }
  static {
    __name(this, "MainScope");
  }
  runtime = this;
  schema;
  name;
  using = [];
  inject = /* @__PURE__ */ new Set();
  forkables = [];
  children = [];
  isReusable = false;
  isReactive = false;
  get isForkable() {
    return this.forkables.length > 0;
  }
  fork(parent, config, error) {
    return new ForkScope(parent, this, config, error);
  }
  dispose() {
    this.uid = null;
    this.reset();
    this.context.emit("internal/runtime", this);
    return true;
  }
  setup() {
    const { name } = this.plugin;
    if (name && name !== "apply")
      this.name = name;
    this.schema = this.plugin["Config"] || this.plugin["schema"];
    const inject = this.plugin["using"] || this.plugin["inject"] || [];
    if (Array.isArray(inject)) {
      this.using = inject;
      this.inject = new Set(inject);
    } else {
      this.using = inject.required || [];
      this.inject = /* @__PURE__ */ new Set([...this.using, ...inject.optional || []]);
    }
    this.isReusable = this.plugin["reusable"];
    this.isReactive = this.plugin["reactive"];
    this.context.emit("internal/runtime", this);
    if (this.isReusable) {
      this.forkables.push(this.apply);
    } else {
      super.setupInject();
    }
  }
  apply = (context, config) => {
    if (typeof this.plugin !== "function") {
      return this.plugin.apply(context, config);
    } else if (isConstructor(this.plugin)) {
      const instance = new this.plugin(context, config);
      const name = instance[Context.expose];
      if (name) {
        context[name] = instance;
      }
      if (instance["fork"]) {
        this.forkables.push(instance["fork"].bind(instance));
      }
    } else {
      return this.plugin(context, config);
    }
  };
  reset() {
    super.reset();
    for (const fork of this.children) {
      fork.reset();
    }
  }
  start() {
    if (super.start())
      return true;
    if (!this.isReusable && this.plugin) {
      this.ensure(async () => this.apply(this.context, this._config));
    }
    for (const fork of this.children) {
      fork.start();
    }
  }
  update(config, forced) {
    if (this.isForkable) {
      this.context.emit("internal/warning", new Error(`attempting to update forkable plugin "${this.plugin.name}", which may lead to unexpected behavior`));
    }
    const oldConfig = this.config;
    const resolved = resolveConfig(this.runtime.plugin || getConstructor(this.context), config);
    const [hasUpdate, shouldRestart] = this.checkUpdate(resolved, forced);
    const state = this.children.find((fork) => fork.config === oldConfig);
    this.config = resolved;
    if (state) {
      this.context.emit("internal/before-update", state, config);
      state.config = resolved;
      if (hasUpdate) {
        this.context.emit("internal/update", state, oldConfig);
      }
    }
    if (shouldRestart)
      this.restart();
  }
};

// cordis/core/src/registry.ts
function isApplicable(object) {
  return object && typeof object === "object" && typeof object.apply === "function";
}
__name(isApplicable, "isApplicable");
var Registry = class {
  constructor(root, config) {
    this.root = root;
    defineProperty3(this, Context.current, root);
    root.scope = new MainScope(this, null, config);
    root.scope.runtime.isReactive = true;
  }
  static {
    __name(this, "Registry");
  }
  _counter = 0;
  _internal = /* @__PURE__ */ new Map();
  get counter() {
    return ++this._counter;
  }
  get size() {
    return this._internal.size;
  }
  resolve(plugin) {
    if (plugin === null)
      return plugin;
    if (typeof plugin === "function")
      return plugin;
    if (isApplicable(plugin))
      return plugin.apply;
    throw new Error('invalid plugin, expect function or object with an "apply" method, received ' + typeof plugin);
  }
  get(plugin) {
    return this._internal.get(this.resolve(plugin));
  }
  has(plugin) {
    return this._internal.has(this.resolve(plugin));
  }
  set(plugin, state) {
    return this._internal.set(this.resolve(plugin), state);
  }
  delete(plugin) {
    plugin = this.resolve(plugin);
    const runtime = this.get(plugin);
    if (!runtime)
      return;
    this._internal.delete(plugin);
    runtime.dispose();
    return runtime;
  }
  keys() {
    return this._internal.keys();
  }
  values() {
    return this._internal.values();
  }
  entries() {
    return this._internal.entries();
  }
  forEach(callback) {
    return this._internal.forEach(callback);
  }
  using(inject, callback) {
    return this.inject(inject, callback);
  }
  inject(inject, callback) {
    return this.plugin({ inject, apply: callback, name: callback.name });
  }
  plugin(plugin, config) {
    this.resolve(plugin);
    const context = this[Context.current];
    context.scope.assertActive();
    let error;
    try {
      config = resolveConfig(plugin, config);
    } catch (reason) {
      context.emit("internal/error", reason);
      error = reason;
      config = null;
    }
    let runtime = this.get(plugin);
    if (runtime) {
      if (!runtime.isForkable) {
        context.emit("internal/warning", new Error(`duplicate plugin detected: ${plugin.name}`));
      }
      return runtime.fork(context, config, error);
    }
    runtime = new MainScope(this, plugin, config, error);
    return runtime.fork(context, config, error);
  }
};

// cordis/core/src/context.ts
var Context = class _Context {
  static {
    __name(this, "Context");
  }
  static config = Symbol.for("cordis.config");
  static events = Symbol.for("cordis.events");
  static static = Symbol.for("cordis.static");
  static filter = Symbol.for("cordis.filter");
  static expose = Symbol.for("cordis.expose");
  static shadow = Symbol.for("cordis.shadow");
  /** @deprecated use `Context.current` instead */
  static source = Symbol.for("cordis.current");
  static current = Symbol.for("cordis.current");
  static internal = Symbol.for("cordis.internal");
  static ensureInternal() {
    const ctx = this.prototype || this;
    if (Object.prototype.hasOwnProperty.call(ctx, _Context.internal)) {
      return ctx[_Context.internal];
    }
    const parent = _Context.ensureInternal.call(Object.getPrototypeOf(this));
    return ctx[_Context.internal] = Object.create(parent);
  }
  /** @deprecated */
  static service(name, options = {}) {
    const internal = this.ensureInternal();
    if (name in internal)
      return;
    const key = typeof name === "symbol" ? name : Symbol(name);
    internal[name] = { type: "service", key };
    if (isConstructor(options)) {
      internal[name]["prototype"] = options.prototype;
    }
  }
  static resolveInject(ctx, name) {
    let internal = ctx[_Context.internal][name];
    while (internal?.type === "alias") {
      name = internal.name;
      internal = ctx[_Context.internal][name];
    }
    return [name, internal];
  }
  static handler = {
    get(target, prop, ctx) {
      if (typeof prop !== "string")
        return Reflect.get(target, prop, ctx);
      const checkInject = /* @__PURE__ */ __name((name2) => {
        if (Reflect.has(target, name2))
          return;
        if (["prototype", "then", "registry", "lifecycle"].includes(name2))
          return;
        if (name2[0] === "$" || name2[0] === "_")
          return;
        if (!ctx.runtime.plugin)
          return;
        let parent = ctx;
        while (parent.runtime.plugin) {
          for (const key of parent.runtime.inject) {
            if (name2 === _Context.resolveInject(parent, key)[0])
              return;
          }
          parent = parent.scope.parent;
        }
        ctx.emit("internal/warning", new Error(`property ${name2} is not registered, declare it as \`inject\` to suppress this warning`));
      }, "checkInject");
      const [name, internal] = _Context.resolveInject(ctx, prop);
      if (!internal) {
        checkInject(name);
        return Reflect.get(target, name, ctx);
      }
      if (internal.type === "accessor") {
        return internal.get.call(ctx);
      } else if (internal.type === "service") {
        if (!internal.builtin)
          checkInject(name);
        return ctx.get(name);
      }
    },
    set(target, prop, value, ctx) {
      if (typeof prop !== "string")
        return Reflect.set(target, prop, value, ctx);
      const [name, internal] = _Context.resolveInject(ctx, prop);
      if (!internal)
        return Reflect.set(target, name, value, ctx);
      if (internal.type === "accessor") {
        if (!internal.set)
          return false;
        return internal.set.call(ctx, value);
      }
      const key = ctx[_Context.shadow][name] || internal.key;
      const oldValue = ctx.root[key];
      if (oldValue === value)
        return true;
      if (value && oldValue) {
        throw new Error(`service ${name} has been registered`);
      }
      if (value) {
        ctx.on("dispose", () => ctx[name] = void 0);
      }
      if (isUnproxyable(value)) {
        ctx.emit("internal/warning", new Error(`service ${name} is an unproxyable object, which may lead to unexpected behavior`));
      }
      const self = /* @__PURE__ */ Object.create(null);
      self[_Context.filter] = (ctx2) => {
        return ctx[_Context.shadow][name] === ctx2[_Context.shadow][name];
      };
      ctx.root.emit(self, "internal/before-service", name, value);
      ctx.root[key] = value;
      if (value instanceof Object) {
        defineProperty4(value, _Context.current, ctx);
      }
      ctx.root.emit(self, "internal/service", name, oldValue);
      return true;
    }
  };
  static associate(object, name) {
    return new Proxy(object, {
      get(target, key, receiver) {
        if (typeof key === "symbol" || key in target)
          return Reflect.get(target, key, receiver);
        const caller = receiver[_Context.current];
        if (!caller?.[_Context.internal][`${name}.${key}`])
          return Reflect.get(target, key, receiver);
        return caller.get(`${name}.${key}`);
      },
      set(target, key, value, receiver) {
        if (typeof key === "symbol" || key in target)
          return Reflect.set(target, key, value, receiver);
        const caller = receiver[_Context.current];
        if (!caller?.[_Context.internal][`${name}.${key}`])
          return Reflect.set(target, key, value, receiver);
        caller[`${name}.${key}`] = value;
        return true;
      }
    });
  }
  constructor(config) {
    const self = new Proxy(this, _Context.handler);
    config = resolveConfig(getConstructor(this), config);
    self[_Context.shadow] = /* @__PURE__ */ Object.create(null);
    self.root = self;
    self.realms = /* @__PURE__ */ Object.create(null);
    self.mixin("scope", ["config", "runtime", "effect", "collect", "accept", "decline"]);
    self.mixin("registry", ["using", "inject", "plugin", "dispose"]);
    self.mixin("lifecycle", ["on", "once", "off", "after", "parallel", "emit", "serial", "bail", "start", "stop"]);
    self.provide("registry", new Registry(self, config), true);
    self.provide("lifecycle", new Lifecycle(self), true);
    const attach = /* @__PURE__ */ __name((internal) => {
      if (!internal)
        return;
      attach(Object.getPrototypeOf(internal));
      for (const key of Object.getOwnPropertyNames(internal)) {
        const constructor = internal[key]["prototype"]?.constructor;
        if (!constructor)
          continue;
        self[internal[key]["key"]] = new constructor(self, config);
        defineProperty4(self[internal[key]["key"]], _Context.current, self);
      }
    }, "attach");
    attach(this[_Context.internal]);
    return self;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Context <${this.name}>`;
  }
  get name() {
    let runtime = this.runtime;
    while (runtime && !runtime.name) {
      runtime = runtime.parent.runtime;
    }
    return runtime?.name;
  }
  get events() {
    return this.lifecycle;
  }
  /** @deprecated */
  get state() {
    return this.scope;
  }
  get(name) {
    const internal = this[_Context.internal][name];
    if (internal?.type !== "service")
      return;
    const key = this[_Context.shadow][name] || internal.key;
    const value = this.root[key];
    if (!value || typeof value !== "object")
      return value;
    if (isUnproxyable(value)) {
      defineProperty4(value, _Context.current, this);
      return value;
    }
    return new Proxy(value, {
      get: (target, name2, receiver) => {
        if (name2 === _Context.current || name2 === "caller")
          return this;
        return Reflect.get(target, name2, receiver);
      }
    });
  }
  provide(name, value, builtin) {
    const internal = _Context.ensureInternal.call(this.root);
    if (name in internal)
      return;
    const key = Symbol(name);
    internal[name] = { type: "service", key, builtin };
    this.root[key] = value;
  }
  accessor(name, options) {
    const internal = _Context.ensureInternal.call(this.root);
    internal[name] ||= { type: "accessor", ...options };
  }
  alias(name, aliases) {
    const internal = _Context.ensureInternal.call(this.root);
    for (const key of aliases) {
      internal[key] ||= { type: "alias", name };
    }
  }
  mixin(name, mixins) {
    for (const key of mixins) {
      this.accessor(key, {
        get() {
          const service = this[name];
          if (isNullable2(service))
            return service;
          const value = Reflect.get(service, key);
          if (typeof value !== "function")
            return value;
          return value.bind(service);
        },
        set(value) {
          return Reflect.set(this[name], key, value);
        }
      });
    }
  }
  extend(meta = {}) {
    return Object.assign(Object.create(this), meta);
  }
  isolate(names, label) {
    const self = this.extend();
    self[_Context.shadow] = Object.create(this[_Context.shadow]);
    for (const name of names) {
      self[_Context.shadow][name] = label ? (this.realms[label] ??= /* @__PURE__ */ Object.create(null))[name] ??= Symbol(name) : Symbol(name);
    }
    return self;
  }
};
Context.prototype[Context.internal] = /* @__PURE__ */ Object.create(null);

// cordis/core/src/service.ts
import { defineProperty as defineProperty5 } from "cosmokit";
var Service = class {
  constructor(ctx, name, immediate) {
    this.ctx = ctx;
    this.name = name;
    ctx.provide(name);
    defineProperty5(this, Context.current, ctx);
    if (immediate) {
      this[Context.expose] = name;
    }
    ctx.on("ready", async () => {
      await Promise.resolve();
      await this.start();
      if (!immediate)
        ctx[name] = this;
    });
    ctx.on("dispose", () => this.stop());
    return Context.associate(Context.associate(this, "service"), name);
  }
  static {
    __name(this, "Service");
  }
  start() {
  }
  stop() {
  }
  [Context.current];
  [Context.filter](ctx) {
    return ctx[Context.shadow][this.name] === this.ctx[Context.shadow][this.name];
  }
};
export {
  Context,
  CordisError,
  EffectScope,
  ForkScope,
  Lifecycle,
  MainScope,
  Registry,
  ScopeStatus,
  Service,
  getConstructor,
  isApplicable,
  isBailed,
  isConstructor,
  isUnproxyable,
  resolveConfig
};
//# sourceMappingURL=index.mjs.map
