"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// satori/packages/axios/src/index.ts
var src_exports = {};
__export(src_exports, {
  Quester: () => Quester,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_cosmokit = require("cosmokit");
var import_mime_db = __toESM(require("mime-db"), 1);
var import_axios = __toESM(require("axios"), 1);

// satori/packages/axios/src/ip.ts
var import_dns = require("dns");
var bogonV4 = [
  "0.0.0.0/8",
  // RFC 1122 'this' network
  "10.0.0.0/8",
  // RFC 1918 private space
  "100.64.0.0/10",
  // RFC 6598 Carrier grade nat space
  "127.0.0.0/8",
  // RFC 1122 localhost
  "169.254.0.0/16",
  // RFC 3927 link local
  "172.16.0.0/12",
  // RFC 1918 private space
  "192.0.2.0/24",
  // RFC 5737 TEST-NET-1
  "192.88.99.0/24",
  // RFC 7526 6to4 anycast relay
  "192.168.0.0/16",
  // RFC 1918 private space
  "198.18.0.0/15",
  // RFC 2544 benchmarking
  "198.51.100.0/24",
  // RFC 5737 TEST-NET-2
  "203.0.113.0/24",
  // RFC 5737 TEST-NET-3
  "224.0.0.0/4",
  // multicast
  "240.0.0.0/4"
  // reserved
];
var bogonV6 = [
  "::/8",
  // RFC 4291 IPv4-compatible, loopback, et al
  "0100::/64",
  // RFC 6666 Discard-Only
  "2001:2::/48",
  // RFC 5180 BMWG
  "2001:10::/28",
  // RFC 4843 ORCHID
  "2001:db8::/32",
  // RFC 3849 documentation
  "2002::/16",
  // RFC 7526 6to4 anycast relay
  "3ffe::/16",
  // RFC 3701 old 6bone
  "fc00::/7",
  // RFC 4193 unique local unicast
  "fe80::/10",
  // RFC 4291 link local unicast
  "fec0::/10",
  // RFC 3879 old site local unicast
  "ff00::/8"
  // RFC 4291 multicast
];
async function isPrivate(hostname) {
  try {
    const { address, family } = await import_dns.promises.lookup(hostname);
    if (family !== 4 && family !== 6)
      return false;
    const { bogons, length, parse } = family === 4 ? { bogons: bogonV4, length: 32, parse: parseIPv4 } : { bogons: bogonV6, length: 128, parse: parseIPv6 };
    const num = parse(address);
    for (const bogon of bogons) {
      const [prefix, cidr] = bogon.split("/");
      const mask = (1n << BigInt(cidr)) - 1n << BigInt(length - +cidr);
      if ((num & mask) === parse(prefix))
        return true;
    }
    return false;
  } catch (e) {
    return false;
  }
}
__name(isPrivate, "isPrivate");
function parseIPv4(ip) {
  return ip.split(".").reduce((a, b) => (a << 8n) + BigInt(b), 0n);
}
__name(parseIPv4, "parseIPv4");
function parseIPv6(ip) {
  const exp = ip.indexOf("::");
  let num = 0n;
  if (exp !== -1 && exp !== 0) {
    ip.slice(0, exp).split(":").forEach((piece, i) => {
      num |= BigInt(`0x${piece}`) << BigInt((7 - i) * 16);
    });
  }
  if (exp === ip.length - 2) {
    return num;
  }
  const rest = exp === -1 ? ip : ip.slice(exp + 2);
  const v4 = rest.includes(".");
  const pieces = rest.split(":");
  let start = 0;
  if (v4) {
    start += 2;
    const [addr] = pieces.splice(-1, 1);
    num |= parseIPv4(addr);
  }
  pieces.reverse().forEach((piece, i) => {
    num |= BigInt(`0x${piece}`) << BigInt((start + i) * 8);
  });
  return num;
}
__name(parseIPv6, "parseIPv6");

// satori/packages/axios/src/index.ts
var _Quester = class _Quester {
  constructor(config = {}) {
    const request = /* @__PURE__ */ __name(async (config2 = {}) => {
      const options = http.prepare();
      const error = new Error();
      return (0, import_axios.default)({
        ...options,
        ...config2,
        url: http.resolve(config2.url),
        headers: {
          ...options.headers,
          ...config2.headers
        }
      }).catch((cause) => {
        if (!import_axios.default.isAxiosError(cause))
          throw cause;
        Object.assign(error, cause);
        error.isAxiosError = true;
        error.cause = cause;
        throw error;
      });
    }, "request");
    const http = /* @__PURE__ */ __name(async (method, url, config2) => {
      const response = await request({ url, ...config2, method });
      return response.data;
    }, "http");
    Object.setPrototypeOf(http, Object.getPrototypeOf(this));
    for (const key of ["extend", "get", "delete", "post", "put", "patch", "head", "ws"]) {
      http[key] = this[key].bind(http);
    }
    http.config = config;
    http.axios = (...args) => {
      if (typeof args[0] === "string") {
        return request({ url: args[0], ...args[1] });
      } else {
        return request(args[0]);
      }
    };
    return http;
  }
  extend(newConfig) {
    return new _Quester({
      ...this.config,
      ...newConfig,
      headers: {
        ...this.config.headers,
        ...newConfig.headers
      }
    });
  }
  agent(url, persist = true) {
    var _a;
    if (!url)
      return;
    if (_Quester.agents[url])
      return _Quester.agents[url];
    const { protocol } = new URL(url);
    const Callback = _Quester.proxies[protocol.slice(0, -1)];
    if (!Callback)
      return;
    const agent = new Callback(url, { keepAlive: (_a = this.config.keepAlive) != null ? _a : false });
    if (persist)
      _Quester.agents[url] = agent;
    return agent;
  }
  get(url, config) {
    return this("GET", url, config);
  }
  delete(url, config) {
    return this("DELETE", url, config);
  }
  post(url, data, config) {
    return this("POST", url, { ...config, data });
  }
  put(url, data, config) {
    return this("PUT", url, { ...config, data });
  }
  patch(url, data, config) {
    return this("PATCH", url, { ...config, data });
  }
  async head(url, config) {
    const response = await this.axios(url, { ...config, method: "HEAD" });
    return response.headers;
  }
  ws(url, options) {
    return new WebSocket(url);
  }
  prepare() {
    return (0, import_cosmokit.pick)(this.config, ["timeout", "headers"]);
  }
  resolve(url) {
    try {
      new URL(url);
      return url;
    } catch {
      return (0, import_cosmokit.trimSlash)(this.config.endpoint || "") + url;
    }
  }
  async file(url, options = {}) {
    var _a, _b, _c, _d;
    const capture = /^data:([\w/-]+);base64,(.*)$/.exec(url);
    if (capture) {
      const [, mime2, base64] = capture;
      const ext = (_b = (_a = import_mime_db.default[mime2]) == null ? void 0 : _a.extensions) == null ? void 0 : _b[0];
      const name2 = "file" + (ext ? "." + ext : "");
      return { mime: mime2, filename: name2, data: (0, import_cosmokit.base64ToArrayBuffer)(base64) };
    }
    const { headers, data, request } = await this.axios(url, {
      method: "GET",
      responseType: "arraybuffer",
      timeout: +options.timeout || void 0
    });
    const mime = headers["content-type"];
    let [, name] = this.resolve(request.res.responseUrl).match(/.+\/([^/?]*)(?=\?)?/);
    if (!name.includes(".")) {
      const ext = (_d = (_c = import_mime_db.default[mime]) == null ? void 0 : _c.extensions) == null ? void 0 : _d[0];
      name += ext ? "." + ext : "";
    }
    return { mime, filename: name, data };
  }
  async isPrivate(url) {
    let { hostname, protocol } = new URL(url);
    if (protocol !== "http:" && protocol !== "https:")
      return true;
    if (/^\[.+\]$/.test(hostname)) {
      hostname = hostname.slice(1, -1);
    }
    return await isPrivate(hostname);
  }
  async toPublic(url) {
    if (!await this.isPrivate(url))
      return url;
    const { headers, data } = await this.axios(url, {
      method: "GET",
      responseType: "arraybuffer"
    });
    const mime = headers["content-type"];
    return `data:${mime};base64,${(0, import_cosmokit.arrayBufferToBase64)(data)}`;
  }
};
__name(_Quester, "Quester");
var Quester = _Quester;
((Quester2) => {
  Quester2.agents = /* @__PURE__ */ Object.create(null);
  Quester2.proxies = /* @__PURE__ */ Object.create(null);
  function defineAgent(protocols, callback) {
    for (const protocol of protocols) {
      Quester2.proxies[protocol] = callback;
    }
  }
  Quester2.defineAgent = defineAgent;
  __name(defineAgent, "defineAgent");
  Quester2.isAxiosError = import_axios.default.isAxiosError;
})(Quester || (Quester = {}));
var src_default = Quester;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Quester
});
//# sourceMappingURL=index.cjs.map
