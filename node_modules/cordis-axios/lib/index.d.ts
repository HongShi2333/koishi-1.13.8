/// <reference types="node" />
/// <reference types="ws" />
import { Agent } from 'agent-base';
import { Dict } from 'cosmokit';
import { AgentOptions, ClientRequestArgs } from 'http';
import { AxiosRequestConfig, AxiosResponse, Method } from 'axios';
import * as Axios from 'axios';
export interface Quester {
    <T = any>(method: Method, url: string, config?: AxiosRequestConfig): Promise<T>;
    axios<T = any>(config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    axios<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    config: Quester.Config;
}
export declare class Quester {
    constructor(config?: Quester.Config);
    extend(newConfig: Quester.Config): Quester;
    agent(url: string, persist?: boolean): Agent | undefined;
    get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
    delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
    post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    head(url: string, config?: AxiosRequestConfig): Promise<Dict<any>>;
    ws(url: string, options?: ClientRequestArgs): import("ws").WebSocket;
    prepare(): AxiosRequestConfig;
    resolve(url: string): string;
    file(url: string, options?: Quester.FileOptions): Promise<Quester.File>;
    isPrivate(url: string): Promise<boolean>;
    toPublic(url: string): Promise<string>;
}
export declare namespace Quester {
    type Method = Axios.Method;
    type AxiosResponse = Axios.AxiosResponse;
    type AxiosRequestConfig = Axios.AxiosRequestConfig;
    type CreateAgent = new (uri: string, opts: AgentOptions) => Agent;
    const agents: Dict<Agent>;
    const proxies: Dict<CreateAgent>;
    function defineAgent(protocols: string[], callback: CreateAgent): void;
    interface File {
        mime?: string;
        filename: string;
        data: ArrayBufferLike;
    }
    interface FileOptions {
        timeout?: number | string;
    }
    const isAxiosError: typeof Axios.isAxiosError;
    interface Config {
        headers?: Dict;
        endpoint?: string;
        timeout?: number;
        proxyAgent?: string;
        keepAlive?: boolean;
    }
}
export default Quester;
