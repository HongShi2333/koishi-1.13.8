var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// satori/packages/axios/src/index.ts
import { arrayBufferToBase64, base64ToArrayBuffer, pick, trimSlash } from "cosmokit";
import mimedb from "mime-db";
import axios from "axios";

// satori/packages/axios/src/ip.ts
import { promises as dns } from "dns";
var bogonV4 = [
  "0.0.0.0/8",
  // RFC 1122 'this' network
  "10.0.0.0/8",
  // RFC 1918 private space
  "100.64.0.0/10",
  // RFC 6598 Carrier grade nat space
  "127.0.0.0/8",
  // RFC 1122 localhost
  "169.254.0.0/16",
  // RFC 3927 link local
  "172.16.0.0/12",
  // RFC 1918 private space
  "192.0.2.0/24",
  // RFC 5737 TEST-NET-1
  "192.88.99.0/24",
  // RFC 7526 6to4 anycast relay
  "192.168.0.0/16",
  // RFC 1918 private space
  "198.18.0.0/15",
  // RFC 2544 benchmarking
  "198.51.100.0/24",
  // RFC 5737 TEST-NET-2
  "203.0.113.0/24",
  // RFC 5737 TEST-NET-3
  "224.0.0.0/4",
  // multicast
  "240.0.0.0/4"
  // reserved
];
var bogonV6 = [
  "::/8",
  // RFC 4291 IPv4-compatible, loopback, et al
  "0100::/64",
  // RFC 6666 Discard-Only
  "2001:2::/48",
  // RFC 5180 BMWG
  "2001:10::/28",
  // RFC 4843 ORCHID
  "2001:db8::/32",
  // RFC 3849 documentation
  "2002::/16",
  // RFC 7526 6to4 anycast relay
  "3ffe::/16",
  // RFC 3701 old 6bone
  "fc00::/7",
  // RFC 4193 unique local unicast
  "fe80::/10",
  // RFC 4291 link local unicast
  "fec0::/10",
  // RFC 3879 old site local unicast
  "ff00::/8"
  // RFC 4291 multicast
];
async function isPrivate(hostname) {
  try {
    const { address, family } = await dns.lookup(hostname);
    if (family !== 4 && family !== 6)
      return false;
    const { bogons, length, parse } = family === 4 ? { bogons: bogonV4, length: 32, parse: parseIPv4 } : { bogons: bogonV6, length: 128, parse: parseIPv6 };
    const num = parse(address);
    for (const bogon of bogons) {
      const [prefix, cidr] = bogon.split("/");
      const mask = (1n << BigInt(cidr)) - 1n << BigInt(length - +cidr);
      if ((num & mask) === parse(prefix))
        return true;
    }
    return false;
  } catch (e) {
    return false;
  }
}
__name(isPrivate, "isPrivate");
function parseIPv4(ip) {
  return ip.split(".").reduce((a, b) => (a << 8n) + BigInt(b), 0n);
}
__name(parseIPv4, "parseIPv4");
function parseIPv6(ip) {
  const exp = ip.indexOf("::");
  let num = 0n;
  if (exp !== -1 && exp !== 0) {
    ip.slice(0, exp).split(":").forEach((piece, i) => {
      num |= BigInt(`0x${piece}`) << BigInt((7 - i) * 16);
    });
  }
  if (exp === ip.length - 2) {
    return num;
  }
  const rest = exp === -1 ? ip : ip.slice(exp + 2);
  const v4 = rest.includes(".");
  const pieces = rest.split(":");
  let start = 0;
  if (v4) {
    start += 2;
    const [addr] = pieces.splice(-1, 1);
    num |= parseIPv4(addr);
  }
  pieces.reverse().forEach((piece, i) => {
    num |= BigInt(`0x${piece}`) << BigInt((start + i) * 8);
  });
  return num;
}
__name(parseIPv6, "parseIPv6");

// satori/packages/axios/src/index.ts
var Quester = class _Quester {
  static {
    __name(this, "Quester");
  }
  constructor(config = {}) {
    const request = /* @__PURE__ */ __name(async (config2 = {}) => {
      const options = http.prepare();
      const error = new Error();
      return axios({
        ...options,
        ...config2,
        url: http.resolve(config2.url),
        headers: {
          ...options.headers,
          ...config2.headers
        }
      }).catch((cause) => {
        if (!axios.isAxiosError(cause))
          throw cause;
        Object.assign(error, cause);
        error.isAxiosError = true;
        error.cause = cause;
        throw error;
      });
    }, "request");
    const http = /* @__PURE__ */ __name(async (method, url, config2) => {
      const response = await request({ url, ...config2, method });
      return response.data;
    }, "http");
    Object.setPrototypeOf(http, Object.getPrototypeOf(this));
    for (const key of ["extend", "get", "delete", "post", "put", "patch", "head", "ws"]) {
      http[key] = this[key].bind(http);
    }
    http.config = config;
    http.axios = (...args) => {
      if (typeof args[0] === "string") {
        return request({ url: args[0], ...args[1] });
      } else {
        return request(args[0]);
      }
    };
    return http;
  }
  extend(newConfig) {
    return new _Quester({
      ...this.config,
      ...newConfig,
      headers: {
        ...this.config.headers,
        ...newConfig.headers
      }
    });
  }
  agent(url, persist = true) {
    if (!url)
      return;
    if (_Quester.agents[url])
      return _Quester.agents[url];
    const { protocol } = new URL(url);
    const Callback = _Quester.proxies[protocol.slice(0, -1)];
    if (!Callback)
      return;
    const agent = new Callback(url, { keepAlive: this.config.keepAlive ?? false });
    if (persist)
      _Quester.agents[url] = agent;
    return agent;
  }
  get(url, config) {
    return this("GET", url, config);
  }
  delete(url, config) {
    return this("DELETE", url, config);
  }
  post(url, data, config) {
    return this("POST", url, { ...config, data });
  }
  put(url, data, config) {
    return this("PUT", url, { ...config, data });
  }
  patch(url, data, config) {
    return this("PATCH", url, { ...config, data });
  }
  async head(url, config) {
    const response = await this.axios(url, { ...config, method: "HEAD" });
    return response.headers;
  }
  ws(url, options) {
    return new WebSocket(url);
  }
  prepare() {
    return pick(this.config, ["timeout", "headers"]);
  }
  resolve(url) {
    try {
      new URL(url);
      return url;
    } catch {
      return trimSlash(this.config.endpoint || "") + url;
    }
  }
  async file(url, options = {}) {
    const capture = /^data:([\w/-]+);base64,(.*)$/.exec(url);
    if (capture) {
      const [, mime2, base64] = capture;
      const ext = mimedb[mime2]?.extensions?.[0];
      const name2 = "file" + (ext ? "." + ext : "");
      return { mime: mime2, filename: name2, data: base64ToArrayBuffer(base64) };
    }
    const { headers, data, request } = await this.axios(url, {
      method: "GET",
      responseType: "arraybuffer",
      timeout: +options.timeout || void 0
    });
    const mime = headers["content-type"];
    let [, name] = this.resolve(request.res.responseUrl).match(/.+\/([^/?]*)(?=\?)?/);
    if (!name.includes(".")) {
      const ext = mimedb[mime]?.extensions?.[0];
      name += ext ? "." + ext : "";
    }
    return { mime, filename: name, data };
  }
  async isPrivate(url) {
    let { hostname, protocol } = new URL(url);
    if (protocol !== "http:" && protocol !== "https:")
      return true;
    if (/^\[.+\]$/.test(hostname)) {
      hostname = hostname.slice(1, -1);
    }
    return await isPrivate(hostname);
  }
  async toPublic(url) {
    if (!await this.isPrivate(url))
      return url;
    const { headers, data } = await this.axios(url, {
      method: "GET",
      responseType: "arraybuffer"
    });
    const mime = headers["content-type"];
    return `data:${mime};base64,${arrayBufferToBase64(data)}`;
  }
};
((Quester2) => {
  Quester2.agents = /* @__PURE__ */ Object.create(null);
  Quester2.proxies = /* @__PURE__ */ Object.create(null);
  function defineAgent(protocols, callback) {
    for (const protocol of protocols) {
      Quester2.proxies[protocol] = callback;
    }
  }
  Quester2.defineAgent = defineAgent;
  __name(defineAgent, "defineAgent");
  Quester2.isAxiosError = axios.isAxiosError;
})(Quester || (Quester = {}));
var src_default = Quester;
export {
  Quester,
  src_default as default
};
//# sourceMappingURL=index.mjs.map
