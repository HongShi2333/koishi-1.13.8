"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  HTTP: () => HTTP,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_cordis = require("cordis");
var import_cosmokit = require("cosmokit");
var import_adapter = require("undios/adapter");
var kHTTPError = Symbol.for("undios.error");
var HTTPError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
  static {
    __name(this, "HTTPError");
  }
  [kHTTPError] = true;
  response;
  static is(error) {
    return !!error?.[kHTTPError];
  }
};
function encodeRequest(data) {
  if (data instanceof URLSearchParams)
    return [null, data];
  if (data instanceof ArrayBuffer)
    return [null, data];
  if (ArrayBuffer.isView(data))
    return [null, data];
  if (data instanceof Blob)
    return [null, data];
  if (data instanceof FormData)
    return [null, data];
  return ["application/json", JSON.stringify(data)];
}
__name(encodeRequest, "encodeRequest");
var HTTP = class _HTTP extends import_cordis.Service {
  static {
    __name(this, "HTTP");
  }
  static Error = HTTPError;
  /** @deprecated use `HTTP.Error.is()` instead */
  static isAxiosError = HTTPError.is;
  static [import_cordis.Service.provide] = "http";
  static [import_cordis.Service.immediate] = true;
  static {
    for (const method of ["get", "delete"]) {
      (0, import_cosmokit.defineProperty)(_HTTP.prototype, method, async function(url, config) {
        const response = await this(url, { method, ...config });
        return response.data;
      });
    }
    for (const method of ["patch", "post", "put"]) {
      (0, import_cosmokit.defineProperty)(_HTTP.prototype, method, async function(url, data, config) {
        const response = await this(url, { method, data, ...config });
        return response.data;
      });
    }
  }
  _decoders = /* @__PURE__ */ Object.create(null);
  constructor(...args) {
    super(args[0], args[1]);
    this.decoder("json", (raw) => raw.json());
    this.decoder("text", (raw) => raw.text());
    this.decoder("blob", (raw) => raw.blob());
    this.decoder("arraybuffer", (raw) => raw.arrayBuffer());
    this.decoder("formdata", (raw) => raw.formData());
    this.decoder("stream", (raw) => raw.body);
  }
  static mergeConfig = (target, source) => ({
    ...target,
    ...source,
    headers: {
      ...target?.headers,
      ...source?.headers
    }
  });
  decoder(type, decoder) {
    return this[import_cordis.Context.origin].effect(() => {
      this._decoders[type] = decoder;
      return () => delete this._decoders[type];
    });
  }
  extend(config = {}) {
    return this[import_cordis.Service.extend]({
      config: _HTTP.mergeConfig(this.config, config)
    });
  }
  resolveConfig(init) {
    const caller = this[import_cordis.Context.origin];
    let result = { headers: {}, ...this.config };
    caller.emit("http/config", result);
    let intercept = caller[import_cordis.Context.intercept];
    while (intercept) {
      result = _HTTP.mergeConfig(result, intercept.http);
      intercept = Object.getPrototypeOf(intercept);
    }
    result = _HTTP.mergeConfig(result, init);
    return result;
  }
  resolveURL(url, config) {
    if (config.endpoint) {
      try {
        new URL(url);
      } catch {
        url = (0, import_cosmokit.trimSlash)(config.endpoint) + url;
      }
    }
    try {
      url = new URL(url, config.baseURL);
    } catch (error) {
      throw new TypeError(`Invalid URL: ${url}`);
    }
    for (const [key, value] of Object.entries(config.params ?? {})) {
      url.searchParams.append(key, value);
    }
    return url;
  }
  defaultDecoder(response) {
    const type = response.headers.get("Content-Type");
    if (type?.startsWith("application/json")) {
      return response.json();
    } else if (type?.startsWith("text/")) {
      return response.text();
    } else {
      return response.arrayBuffer();
    }
  }
  async [import_cordis.Service.invoke](...args) {
    const caller = this[import_cordis.Context.origin];
    let method;
    if (typeof args[1] === "string" || args[1] instanceof URL) {
      method = args.shift();
    }
    const config = this.resolveConfig(args[1]);
    const url = this.resolveURL(args[0], config);
    method ??= config.method ?? "GET";
    const controller = new AbortController();
    if (config.signal) {
      if (config.signal.aborted) {
        throw config.signal.reason;
      }
      config.signal.addEventListener("abort", () => {
        controller.abort(config.signal.reason);
      });
    }
    const dispose = caller.effect(() => {
      const timer = config.timeout && setTimeout(() => {
        controller.abort(new HTTPError("request timeout", "ETIMEDOUT"));
      }, config.timeout);
      return (done) => {
        clearTimeout(timer);
        if (done)
          return;
        controller.abort(new HTTPError("context disposed", "ETIMEDOUT"));
      };
    });
    controller.signal.addEventListener("abort", () => dispose());
    try {
      const headers = new Headers(config.headers);
      const init = {
        method,
        headers,
        body: config.data,
        keepalive: config.keepAlive,
        redirect: config.redirect,
        signal: controller.signal
      };
      if (config.data && typeof config.data === "object") {
        const [type, body] = encodeRequest(config.data);
        init.body = body;
        if (type && !headers.has("Content-Type")) {
          headers.append("Content-Type", type);
        }
      }
      caller.emit("http/fetch-init", url, init, config);
      const raw = await fetch(url, init).catch((cause) => {
        if (_HTTP.Error.is(cause))
          throw cause;
        const error = new _HTTP.Error(`fetch ${url} failed`);
        error.cause = cause;
        throw error;
      });
      const response = {
        data: null,
        url: raw.url,
        status: raw.status,
        statusText: raw.statusText,
        headers: raw.headers
      };
      const validateStatus = config.validateStatus ?? ((status) => status < 400);
      if (!validateStatus(raw.status)) {
        const error = new _HTTP.Error(raw.statusText);
        error.response = response;
        try {
          response.data = await this.defaultDecoder(raw);
        } catch {
        }
        throw error;
      }
      if (config.responseType) {
        if (!(config.responseType in this._decoders)) {
          throw new TypeError(`Unknown responseType: ${config.responseType}`);
        }
        const decoder = this._decoders[config.responseType];
        response.data = await decoder(raw);
      } else {
        response.data = await this.defaultDecoder(raw);
      }
      return response;
    } finally {
      dispose(true);
    }
  }
  async head(url, config) {
    const response = await this(url, { method: "HEAD", ...config });
    return response.headers;
  }
  axios(...args) {
    const caller = this[import_cordis.Context.origin];
    caller.emit("internal/warning", "ctx.http.axios() is deprecated, use ctx.http() instead");
    if (typeof args[0] === "string") {
      return this(args[0], args[1]);
    } else {
      return this(args[0].url, args[0]);
    }
  }
  ws(url, init) {
    const caller = this[import_cordis.Context.origin];
    const config = this.resolveConfig(init);
    url = this.resolveURL(url, config);
    let options;
    if ("Server" in import_adapter.WebSocket) {
      options = {
        handshakeTimeout: config?.timeout,
        headers: config?.headers
      };
      caller.emit("http/websocket-init", url, options, config);
    }
    const socket = new import_adapter.WebSocket(url, options);
    const dispose = caller.on("dispose", () => {
      socket.close(1001, "context disposed");
    });
    socket.addEventListener("close", () => {
      dispose();
    });
    return socket;
  }
};
var src_default = HTTP;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HTTP
});
